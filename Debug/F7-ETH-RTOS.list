
F7-ETH-RTOS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c8  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00009a78  080001c8  080001c8  000101c8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000200  08009c40  08009c40  00019c40  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08009e40  08009e40  00019e40  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08009e44  08009e44  00019e44  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000048  20000000  08009e48  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          0000abdc  20000048  08009e90  00020048  2**2
                  ALLOC
  7 ._user_heap_stack 00000604  2000ac24  08009e90  0002ac24  2**0
                  ALLOC
  8 .ARM.attributes 00000030  00000000  00000000  00020048  2**0
                  CONTENTS, READONLY
  9 .debug_line   00023b94  00000000  00000000  00020078  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0004ef3f  00000000  00000000  00043c0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00009b90  00000000  00000000  00092b4b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00001b78  00000000  00000000  0009c6e0  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00002858  00000000  00000000  0009e258  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00017976  00000000  00000000  000a0ab0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_macro  000271c9  00000000  00000000  000b8426  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000abf6d  00000000  00000000  000df5ef  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007c  00000000  00000000  0018b55c  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00005184  00000000  00000000  0018b5d8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001c8 <__do_global_dtors_aux>:
 80001c8:	b510      	push	{r4, lr}
 80001ca:	4c05      	ldr	r4, [pc, #20]	; (80001e0 <__do_global_dtors_aux+0x18>)
 80001cc:	7823      	ldrb	r3, [r4, #0]
 80001ce:	b933      	cbnz	r3, 80001de <__do_global_dtors_aux+0x16>
 80001d0:	4b04      	ldr	r3, [pc, #16]	; (80001e4 <__do_global_dtors_aux+0x1c>)
 80001d2:	b113      	cbz	r3, 80001da <__do_global_dtors_aux+0x12>
 80001d4:	4804      	ldr	r0, [pc, #16]	; (80001e8 <__do_global_dtors_aux+0x20>)
 80001d6:	f3af 8000 	nop.w
 80001da:	2301      	movs	r3, #1
 80001dc:	7023      	strb	r3, [r4, #0]
 80001de:	bd10      	pop	{r4, pc}
 80001e0:	20000048 	.word	0x20000048
 80001e4:	00000000 	.word	0x00000000
 80001e8:	08009c28 	.word	0x08009c28

080001ec <frame_dummy>:
 80001ec:	b508      	push	{r3, lr}
 80001ee:	4b03      	ldr	r3, [pc, #12]	; (80001fc <frame_dummy+0x10>)
 80001f0:	b11b      	cbz	r3, 80001fa <frame_dummy+0xe>
 80001f2:	4903      	ldr	r1, [pc, #12]	; (8000200 <frame_dummy+0x14>)
 80001f4:	4803      	ldr	r0, [pc, #12]	; (8000204 <frame_dummy+0x18>)
 80001f6:	f3af 8000 	nop.w
 80001fa:	bd08      	pop	{r3, pc}
 80001fc:	00000000 	.word	0x00000000
 8000200:	2000004c 	.word	0x2000004c
 8000204:	08009c28 	.word	0x08009c28

08000208 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 8000208:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000240 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 800020c:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800020e:	e003      	b.n	8000218 <LoopCopyDataInit>

08000210 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8000210:	4b0c      	ldr	r3, [pc, #48]	; (8000244 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 8000212:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8000214:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8000216:	3104      	adds	r1, #4

08000218 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8000218:	480b      	ldr	r0, [pc, #44]	; (8000248 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 800021a:	4b0c      	ldr	r3, [pc, #48]	; (800024c <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 800021c:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800021e:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8000220:	d3f6      	bcc.n	8000210 <CopyDataInit>
  ldr  r2, =_sbss
 8000222:	4a0b      	ldr	r2, [pc, #44]	; (8000250 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8000224:	e002      	b.n	800022c <LoopFillZerobss>

08000226 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8000226:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8000228:	f842 3b04 	str.w	r3, [r2], #4

0800022c <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800022c:	4b09      	ldr	r3, [pc, #36]	; (8000254 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 800022e:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8000230:	d3f9      	bcc.n	8000226 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 8000232:	f000 f813 	bl	800025c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8000236:	f009 fcb1 	bl	8009b9c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800023a:	f009 fa79 	bl	8009730 <main>
  bx  lr    
 800023e:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 8000240:	20050000 	.word	0x20050000
  ldr  r3, =_sidata
 8000244:	08009e48 	.word	0x08009e48
  ldr  r0, =_sdata
 8000248:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800024c:	20000048 	.word	0x20000048
  ldr  r2, =_sbss
 8000250:	20000048 	.word	0x20000048
  ldr  r3, = _ebss
 8000254:	2000ac24 	.word	0x2000ac24

08000258 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8000258:	e7fe      	b.n	8000258 <ADC_IRQHandler>
	...

0800025c <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800025c:	490f      	ldr	r1, [pc, #60]	; (800029c <SystemInit+0x40>)
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800025e:	2000      	movs	r0, #0
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000260:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8000264:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8000268:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  RCC->CR |= (uint32_t)0x00000001;
 800026c:	4b0c      	ldr	r3, [pc, #48]	; (80002a0 <SystemInit+0x44>)
 800026e:	681a      	ldr	r2, [r3, #0]
 8000270:	f042 0201 	orr.w	r2, r2, #1
 8000274:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 8000276:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000278:	681a      	ldr	r2, [r3, #0]
 800027a:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 800027e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000282:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8000284:	4a07      	ldr	r2, [pc, #28]	; (80002a4 <SystemInit+0x48>)
 8000286:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000288:	681a      	ldr	r2, [r3, #0]
 800028a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800028e:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8000290:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = RAMDTCM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000292:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000296:	608b      	str	r3, [r1, #8]
 8000298:	4770      	bx	lr
 800029a:	bf00      	nop
 800029c:	e000ed00 	.word	0xe000ed00
 80002a0:	40023800 	.word	0x40023800
 80002a4:	24003010 	.word	0x24003010

080002a8 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80002a8:	b508      	push	{r3, lr}
#if (ART_ACCLERATOR_ENABLE != 0)
   __HAL_FLASH_ART_ENABLE();
#endif /* ART_ACCLERATOR_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80002aa:	2003      	movs	r0, #3
 80002ac:	f000 f824 	bl	80002f8 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 80002b0:	2000      	movs	r0, #0
 80002b2:	f009 fb85 	bl	80099c0 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 80002b6:	f009 fafd 	bl	80098b4 <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
}
 80002ba:	2000      	movs	r0, #0
 80002bc:	bd08      	pop	{r3, pc}
	...

080002c0 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 80002c0:	4a02      	ldr	r2, [pc, #8]	; (80002cc <HAL_IncTick+0xc>)
 80002c2:	6813      	ldr	r3, [r2, #0]
 80002c4:	3301      	adds	r3, #1
 80002c6:	6013      	str	r3, [r2, #0]
 80002c8:	4770      	bx	lr
 80002ca:	bf00      	nop
 80002cc:	20003f48 	.word	0x20003f48

080002d0 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80002d0:	4b01      	ldr	r3, [pc, #4]	; (80002d8 <HAL_GetTick+0x8>)
 80002d2:	6818      	ldr	r0, [r3, #0]
}
 80002d4:	4770      	bx	lr
 80002d6:	bf00      	nop
 80002d8:	20003f48 	.word	0x20003f48

080002dc <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 80002dc:	b513      	push	{r0, r1, r4, lr}
 80002de:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0;
  tickstart = HAL_GetTick();
 80002e0:	f7ff fff6 	bl	80002d0 <HAL_GetTick>
 80002e4:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 80002e6:	f7ff fff3 	bl	80002d0 <HAL_GetTick>
 80002ea:	9b01      	ldr	r3, [sp, #4]
 80002ec:	1b00      	subs	r0, r0, r4
 80002ee:	4298      	cmp	r0, r3
 80002f0:	d3f9      	bcc.n	80002e6 <HAL_Delay+0xa>
  {
  }
}
 80002f2:	b002      	add	sp, #8
 80002f4:	bd10      	pop	{r4, pc}
	...

080002f8 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80002f8:	4a07      	ldr	r2, [pc, #28]	; (8000318 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 80002fa:	0200      	lsls	r0, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80002fc:	68d3      	ldr	r3, [r2, #12]
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 80002fe:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000302:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000306:	041b      	lsls	r3, r3, #16
 8000308:	0c1b      	lsrs	r3, r3, #16
 800030a:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800030e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
 8000312:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8000314:	60d3      	str	r3, [r2, #12]
 8000316:	4770      	bx	lr
 8000318:	e000ed00 	.word	0xe000ed00

0800031c <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800031c:	4b19      	ldr	r3, [pc, #100]	; (8000384 <HAL_NVIC_SetPriority+0x68>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800031e:	b530      	push	{r4, r5, lr}
 8000320:	68dc      	ldr	r4, [r3, #12]
 8000322:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000326:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800032a:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800032c:	2b04      	cmp	r3, #4
 800032e:	bf28      	it	cs
 8000330:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000332:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000334:	f04f 0501 	mov.w	r5, #1
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000338:	bf8c      	ite	hi
 800033a:	3c03      	subhi	r4, #3
 800033c:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800033e:	fa05 f303 	lsl.w	r3, r5, r3
  if ((int32_t)(IRQn) < 0)
 8000342:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000344:	f103 33ff 	add.w	r3, r3, #4294967295
 8000348:	ea01 0103 	and.w	r1, r1, r3
 800034c:	fa01 f104 	lsl.w	r1, r1, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8000350:	fa05 f404 	lsl.w	r4, r5, r4
 8000354:	f104 34ff 	add.w	r4, r4, #4294967295
 8000358:	ea02 0204 	and.w	r2, r2, r4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800035c:	ea42 0201 	orr.w	r2, r2, r1
 8000360:	ea4f 1202 	mov.w	r2, r2, lsl #4
  if ((int32_t)(IRQn) < 0)
 8000364:	da05      	bge.n	8000372 <HAL_NVIC_SetPriority+0x56>
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000366:	f000 000f 	and.w	r0, r0, #15
 800036a:	b2d2      	uxtb	r2, r2
 800036c:	4b06      	ldr	r3, [pc, #24]	; (8000388 <HAL_NVIC_SetPriority+0x6c>)
 800036e:	541a      	strb	r2, [r3, r0]
 8000370:	bd30      	pop	{r4, r5, pc}
    NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000372:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8000376:	b2d2      	uxtb	r2, r2
 8000378:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 800037c:	f880 2300 	strb.w	r2, [r0, #768]	; 0x300
 8000380:	bd30      	pop	{r4, r5, pc}
 8000382:	bf00      	nop
 8000384:	e000ed00 	.word	0xe000ed00
 8000388:	e000ed14 	.word	0xe000ed14

0800038c <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800038c:	0942      	lsrs	r2, r0, #5
 800038e:	2301      	movs	r3, #1
 8000390:	f000 001f 	and.w	r0, r0, #31
 8000394:	fa03 f000 	lsl.w	r0, r3, r0
 8000398:	4b01      	ldr	r3, [pc, #4]	; (80003a0 <HAL_NVIC_EnableIRQ+0x14>)
 800039a:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 800039e:	4770      	bx	lr
 80003a0:	e000e100 	.word	0xe000e100

080003a4 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80003a4:	3801      	subs	r0, #1
 80003a6:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80003aa:	d20a      	bcs.n	80003c2 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80003ac:	4b06      	ldr	r3, [pc, #24]	; (80003c8 <HAL_SYSTICK_Config+0x24>)
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80003ae:	21f0      	movs	r1, #240	; 0xf0
 80003b0:	4a06      	ldr	r2, [pc, #24]	; (80003cc <HAL_SYSTICK_Config+0x28>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80003b2:	6058      	str	r0, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80003b4:	2000      	movs	r0, #0
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80003b6:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80003ba:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80003bc:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80003be:	601a      	str	r2, [r3, #0]
 80003c0:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 80003c2:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80003c4:	4770      	bx	lr
 80003c6:	bf00      	nop
 80003c8:	e000e010 	.word	0xe000e010
 80003cc:	e000ed00 	.word	0xe000ed00

080003d0 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 80003d0:	4b04      	ldr	r3, [pc, #16]	; (80003e4 <HAL_SYSTICK_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 80003d2:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 80003d4:	681a      	ldr	r2, [r3, #0]
 80003d6:	bf0c      	ite	eq
 80003d8:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 80003dc:	f022 0204 	bicne.w	r2, r2, #4
 80003e0:	601a      	str	r2, [r3, #0]
 80003e2:	4770      	bx	lr
 80003e4:	e000e010 	.word	0xe000e010

080003e8 <ETH_FlushTransmitFIFO>:
  *         the configuration information for ETHERNET module
  * @retval None
  */
static void ETH_FlushTransmitFIFO(ETH_HandleTypeDef *heth)
{
  __IO uint32_t tmpreg = 0;
 80003e8:	2300      	movs	r3, #0
{
 80003ea:	b537      	push	{r0, r1, r2, r4, r5, lr}
  
  /* Set the Flush Transmit FIFO bit */
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_FTF;
 80003ec:	f241 0418 	movw	r4, #4120	; 0x1018
  __IO uint32_t tmpreg = 0;
 80003f0:	9301      	str	r3, [sp, #4]
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_FTF;
 80003f2:	6803      	ldr	r3, [r0, #0]
{
 80003f4:	4605      	mov	r5, r0
  
  /* Wait until the write operation will be taken into account:
     at least four TX_CLK/RX_CLK clock cycles */
  tmpreg = (heth->Instance)->DMAOMR;
  HAL_Delay(ETH_REG_WRITE_DELAY);
 80003f6:	2001      	movs	r0, #1
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_FTF;
 80003f8:	591a      	ldr	r2, [r3, r4]
 80003fa:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 80003fe:	511a      	str	r2, [r3, r4]
  tmpreg = (heth->Instance)->DMAOMR;
 8000400:	591b      	ldr	r3, [r3, r4]
 8000402:	9301      	str	r3, [sp, #4]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8000404:	f7ff ff6a 	bl	80002dc <HAL_Delay>
  (heth->Instance)->DMAOMR = tmpreg;
 8000408:	682b      	ldr	r3, [r5, #0]
 800040a:	9a01      	ldr	r2, [sp, #4]
 800040c:	511a      	str	r2, [r3, r4]
}
 800040e:	b003      	add	sp, #12
 8000410:	bd30      	pop	{r4, r5, pc}
	...

08000414 <ETH_MACDMAConfig>:
{
 8000414:	b570      	push	{r4, r5, r6, lr}
 8000416:	4604      	mov	r4, r0
  if (err != ETH_SUCCESS) /* Auto-negotiation failed */
 8000418:	b129      	cbz	r1, 8000426 <ETH_MACDMAConfig+0x12>
    (heth->Init).DuplexMode = ETH_MODE_FULLDUPLEX;
 800041a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800041e:	60c3      	str	r3, [r0, #12]
    (heth->Init).Speed = ETH_SPEED_100M;
 8000420:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8000424:	6083      	str	r3, [r0, #8]
  if(heth->Init.ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
 8000426:	69e3      	ldr	r3, [r4, #28]
  tmpreg = (heth->Instance)->MACCR;
 8000428:	6822      	ldr	r2, [r4, #0]
    macinit.ChecksumOffload = ETH_CHECKSUMOFFLAOD_DISABLE;
 800042a:	2b00      	cmp	r3, #0
                       macinit.LoopbackMode |
 800042c:	68e0      	ldr	r0, [r4, #12]
 800042e:	68a3      	ldr	r3, [r4, #8]
  tmpreg = (heth->Instance)->MACCR;
 8000430:	6815      	ldr	r5, [r2, #0]
    macinit.ChecksumOffload = ETH_CHECKSUMOFFLAOD_DISABLE;
 8000432:	bf08      	it	eq
 8000434:	f44f 6180 	moveq.w	r1, #1024	; 0x400
                       macinit.LoopbackMode |
 8000438:	ea43 0300 	orr.w	r3, r3, r0
  tmpreg &= ETH_MACCR_CLEAR_MASK;
 800043c:	482e      	ldr	r0, [pc, #184]	; (80004f8 <ETH_MACDMAConfig+0xe4>)
    macinit.ChecksumOffload = ETH_CHECKSUMOFFLAOD_DISABLE;
 800043e:	bf18      	it	ne
 8000440:	2100      	movne	r1, #0
  tmpreg &= ETH_MACCR_CLEAR_MASK;
 8000442:	4028      	ands	r0, r5
 8000444:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000448:	4303      	orrs	r3, r0
  HAL_Delay(ETH_REG_WRITE_DELAY);
 800044a:	2001      	movs	r0, #1
  tmpreg |= (uint32_t)(macinit.Watchdog | 
 800044c:	430b      	orrs	r3, r1
  (heth->Instance)->MACCR = (uint32_t)tmpreg;
 800044e:	6013      	str	r3, [r2, #0]
  tmpreg = (heth->Instance)->MACCR;
 8000450:	6815      	ldr	r5, [r2, #0]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8000452:	f7ff ff43 	bl	80002dc <HAL_Delay>
  (heth->Instance)->MACCR = tmpreg; 
 8000456:	6823      	ldr	r3, [r4, #0]
  (heth->Instance)->MACFFR = (uint32_t)(macinit.ReceiveAll | 
 8000458:	2240      	movs	r2, #64	; 0x40
   HAL_Delay(ETH_REG_WRITE_DELAY);
 800045a:	2001      	movs	r0, #1
  (heth->Instance)->MACCR = tmpreg; 
 800045c:	601d      	str	r5, [r3, #0]
  (heth->Instance)->MACFFR = (uint32_t)(macinit.ReceiveAll | 
 800045e:	605a      	str	r2, [r3, #4]
   tmpreg = (heth->Instance)->MACFFR;
 8000460:	685d      	ldr	r5, [r3, #4]
   HAL_Delay(ETH_REG_WRITE_DELAY);
 8000462:	f7ff ff3b 	bl	80002dc <HAL_Delay>
   (heth->Instance)->MACFFR = tmpreg;
 8000466:	6823      	ldr	r3, [r4, #0]
   HAL_Delay(ETH_REG_WRITE_DELAY);
 8000468:	2001      	movs	r0, #1
   (heth->Instance)->MACFFR = tmpreg;
 800046a:	605d      	str	r5, [r3, #4]
   (heth->Instance)->MACHTHR = (uint32_t)macinit.HashTableHigh;
 800046c:	2500      	movs	r5, #0
 800046e:	609d      	str	r5, [r3, #8]
   (heth->Instance)->MACHTLR = (uint32_t)macinit.HashTableLow;
 8000470:	60dd      	str	r5, [r3, #12]
   tmpreg = (heth->Instance)->MACFCR;
 8000472:	699a      	ldr	r2, [r3, #24]
   tmpreg &= ETH_MACFCR_CLEAR_MASK;
 8000474:	f022 02be 	bic.w	r2, r2, #190	; 0xbe
 8000478:	0412      	lsls	r2, r2, #16
 800047a:	0c12      	lsrs	r2, r2, #16
   tmpreg |= (uint32_t)((macinit.PauseTime << 16) | 
 800047c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   (heth->Instance)->MACFCR = (uint32_t)tmpreg;
 8000480:	619a      	str	r2, [r3, #24]
   tmpreg = (heth->Instance)->MACFCR;
 8000482:	699e      	ldr	r6, [r3, #24]
   HAL_Delay(ETH_REG_WRITE_DELAY);
 8000484:	f7ff ff2a 	bl	80002dc <HAL_Delay>
   (heth->Instance)->MACFCR = tmpreg;
 8000488:	6823      	ldr	r3, [r4, #0]
    HAL_Delay(ETH_REG_WRITE_DELAY);
 800048a:	2001      	movs	r0, #1
   (heth->Instance)->MACFCR = tmpreg;
 800048c:	619e      	str	r6, [r3, #24]
   (heth->Instance)->MACVLANTR = (uint32_t)(macinit.VLANTagComparison | 
 800048e:	61dd      	str	r5, [r3, #28]
    tmpreg = (heth->Instance)->MACVLANTR;
 8000490:	69dd      	ldr	r5, [r3, #28]
    HAL_Delay(ETH_REG_WRITE_DELAY);
 8000492:	f7ff ff23 	bl	80002dc <HAL_Delay>
    (heth->Instance)->MACVLANTR = tmpreg;
 8000496:	6822      	ldr	r2, [r4, #0]
    HAL_Delay(ETH_REG_WRITE_DELAY);
 8000498:	2001      	movs	r0, #1
    tmpreg &= ETH_DMAOMR_CLEAR_MASK;
 800049a:	4b18      	ldr	r3, [pc, #96]	; (80004fc <ETH_MACDMAConfig+0xe8>)
    (heth->Instance)->MACVLANTR = tmpreg;
 800049c:	61d5      	str	r5, [r2, #28]
    tmpreg = (heth->Instance)->DMAOMR;
 800049e:	f241 0518 	movw	r5, #4120	; 0x1018
 80004a2:	5951      	ldr	r1, [r2, r5]
    tmpreg &= ETH_DMAOMR_CLEAR_MASK;
 80004a4:	400b      	ands	r3, r1
    tmpreg |= (uint32_t)(dmainit.DropTCPIPChecksumErrorFrame | 
 80004a6:	f043 7308 	orr.w	r3, r3, #35651584	; 0x2200000
 80004aa:	f043 0304 	orr.w	r3, r3, #4
    (heth->Instance)->DMAOMR = (uint32_t)tmpreg;
 80004ae:	5153      	str	r3, [r2, r5]
    tmpreg = (heth->Instance)->DMAOMR;
 80004b0:	5956      	ldr	r6, [r2, r5]
    HAL_Delay(ETH_REG_WRITE_DELAY);
 80004b2:	f7ff ff13 	bl	80002dc <HAL_Delay>
    (heth->Instance)->DMAOMR = tmpreg;
 80004b6:	6823      	ldr	r3, [r4, #0]
     HAL_Delay(ETH_REG_WRITE_DELAY);
 80004b8:	2001      	movs	r0, #1
    (heth->Instance)->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats | 
 80004ba:	4a11      	ldr	r2, [pc, #68]	; (8000500 <ETH_MACDMAConfig+0xec>)
    (heth->Instance)->DMAOMR = tmpreg;
 80004bc:	515e      	str	r6, [r3, r5]
    (heth->Instance)->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats | 
 80004be:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80004c2:	601a      	str	r2, [r3, #0]
     tmpreg = (heth->Instance)->DMABMR;
 80004c4:	681d      	ldr	r5, [r3, #0]
     HAL_Delay(ETH_REG_WRITE_DELAY);
 80004c6:	f7ff ff09 	bl	80002dc <HAL_Delay>
     (heth->Instance)->DMABMR = tmpreg;
 80004ca:	6822      	ldr	r2, [r4, #0]
 80004cc:	f502 5380 	add.w	r3, r2, #4096	; 0x1000
 80004d0:	601d      	str	r5, [r3, #0]
     if((heth->Init).RxMode == ETH_RXINTERRUPT_MODE)
 80004d2:	69a3      	ldr	r3, [r4, #24]
 80004d4:	2b01      	cmp	r3, #1
 80004d6:	d107      	bne.n	80004e8 <ETH_MACDMAConfig+0xd4>
       __HAL_ETH_DMA_ENABLE_IT((heth), ETH_DMA_IT_NIS | ETH_DMA_IT_R);
 80004d8:	f241 011c 	movw	r1, #4124	; 0x101c
 80004dc:	5853      	ldr	r3, [r2, r1]
 80004de:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80004e2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80004e6:	5053      	str	r3, [r2, r1]
     ETH_MACAddressConfig(heth, ETH_MAC_ADDRESS0, heth->Init.MACAddr);
 80004e8:	6963      	ldr	r3, [r4, #20]
  (*(__IO uint32_t *)((uint32_t)(ETH_MAC_ADDR_HBASE + MacAddr))) = tmpreg;
 80004ea:	4a06      	ldr	r2, [pc, #24]	; (8000504 <ETH_MACDMAConfig+0xf0>)
  tmpreg = ((uint32_t)Addr[5] << 8) | (uint32_t)Addr[4];
 80004ec:	8899      	ldrh	r1, [r3, #4]
  (*(__IO uint32_t *)((uint32_t)(ETH_MAC_ADDR_HBASE + MacAddr))) = tmpreg;
 80004ee:	6011      	str	r1, [r2, #0]
  tmpreg = ((uint32_t)Addr[3] << 24) | ((uint32_t)Addr[2] << 16) | ((uint32_t)Addr[1] << 8) | Addr[0];
 80004f0:	681a      	ldr	r2, [r3, #0]
  (*(__IO uint32_t *)((uint32_t)(ETH_MAC_ADDR_LBASE + MacAddr))) = tmpreg;
 80004f2:	4b05      	ldr	r3, [pc, #20]	; (8000508 <ETH_MACDMAConfig+0xf4>)
 80004f4:	601a      	str	r2, [r3, #0]
 80004f6:	bd70      	pop	{r4, r5, r6, pc}
 80004f8:	ff20810f 	.word	0xff20810f
 80004fc:	f8de3f23 	.word	0xf8de3f23
 8000500:	02c12080 	.word	0x02c12080
 8000504:	40028040 	.word	0x40028040
 8000508:	40028044 	.word	0x40028044

0800050c <HAL_ETH_DMATxDescListInit>:
{
 800050c:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LOCK(heth);
 800050e:	f890 4045 	ldrb.w	r4, [r0, #69]	; 0x45
 8000512:	2c01      	cmp	r4, #1
 8000514:	f04f 0402 	mov.w	r4, #2
 8000518:	d033      	beq.n	8000582 <HAL_ETH_DMATxDescListInit+0x76>
 800051a:	2501      	movs	r5, #1
  heth->State = HAL_ETH_STATE_BUSY;
 800051c:	f880 4044 	strb.w	r4, [r0, #68]	; 0x44
    dmatxdesc->Status = ETH_DMATXDESC_TCH;  
 8000520:	f44f 1780 	mov.w	r7, #1048576	; 0x100000
 8000524:	f101 0420 	add.w	r4, r1, #32
  __HAL_LOCK(heth);
 8000528:	f880 5045 	strb.w	r5, [r0, #69]	; 0x45
    dmatxdesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_TX_BUF_SIZE]);
 800052c:	f240 5ef4 	movw	lr, #1524	; 0x5f4
  for(i=0; i < TxBuffCount; i++)
 8000530:	2500      	movs	r5, #0
    if(i < (TxBuffCount-1))
 8000532:	f103 3cff 	add.w	ip, r3, #4294967295
  heth->TxDesc = DMATxDescTab;
 8000536:	62c1      	str	r1, [r0, #44]	; 0x2c
  for(i=0; i < TxBuffCount; i++)
 8000538:	429d      	cmp	r5, r3
 800053a:	d10b      	bne.n	8000554 <HAL_ETH_DMATxDescListInit+0x48>
  (heth->Instance)->DMATDLAR = (uint32_t) DMATxDescTab;
 800053c:	6802      	ldr	r2, [r0, #0]
 800053e:	f241 0310 	movw	r3, #4112	; 0x1010
 8000542:	50d1      	str	r1, [r2, r3]
  heth->State= HAL_ETH_STATE_READY;
 8000544:	2301      	movs	r3, #1
 8000546:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 800054a:	2300      	movs	r3, #0
 800054c:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  return HAL_OK;
 8000550:	4618      	mov	r0, r3
 8000552:	bdf0      	pop	{r4, r5, r6, r7, pc}
    dmatxdesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_TX_BUF_SIZE]);
 8000554:	fb0e 2605 	mla	r6, lr, r5, r2
    dmatxdesc->Status = ETH_DMATXDESC_TCH;  
 8000558:	f844 7c20 	str.w	r7, [r4, #-32]
    dmatxdesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_TX_BUF_SIZE]);
 800055c:	f844 6c18 	str.w	r6, [r4, #-24]
    if ((heth->Init).ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
 8000560:	69c6      	ldr	r6, [r0, #28]
 8000562:	b92e      	cbnz	r6, 8000570 <HAL_ETH_DMATxDescListInit+0x64>
      dmatxdesc->Status |= ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL;
 8000564:	f854 6c20 	ldr.w	r6, [r4, #-32]
 8000568:	f446 0640 	orr.w	r6, r6, #12582912	; 0xc00000
 800056c:	f844 6c20 	str.w	r6, [r4, #-32]
      dmatxdesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
 8000570:	4565      	cmp	r5, ip
 8000572:	bf2c      	ite	cs
 8000574:	460e      	movcs	r6, r1
 8000576:	4626      	movcc	r6, r4
  for(i=0; i < TxBuffCount; i++)
 8000578:	3501      	adds	r5, #1
 800057a:	3420      	adds	r4, #32
      dmatxdesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
 800057c:	f844 6c34 	str.w	r6, [r4, #-52]
 8000580:	e7da      	b.n	8000538 <HAL_ETH_DMATxDescListInit+0x2c>
  __HAL_LOCK(heth);
 8000582:	4620      	mov	r0, r4
}
 8000584:	bdf0      	pop	{r4, r5, r6, r7, pc}

08000586 <HAL_ETH_DMARxDescListInit>:
{
 8000586:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(heth);
 800058a:	f890 4045 	ldrb.w	r4, [r0, #69]	; 0x45
 800058e:	2c01      	cmp	r4, #1
 8000590:	f04f 0402 	mov.w	r4, #2
 8000594:	d030      	beq.n	80005f8 <HAL_ETH_DMARxDescListInit+0x72>
 8000596:	2501      	movs	r5, #1
  heth->State = HAL_ETH_STATE_BUSY;
 8000598:	f880 4044 	strb.w	r4, [r0, #68]	; 0x44
    DMARxDesc->Status = ETH_DMARXDESC_OWN;
 800059c:	f04f 4600 	mov.w	r6, #2147483648	; 0x80000000
 80005a0:	f101 0420 	add.w	r4, r1, #32
  __HAL_LOCK(heth);
 80005a4:	f880 5045 	strb.w	r5, [r0, #69]	; 0x45
    DMARxDesc->ControlBufferSize = ETH_DMARXDESC_RCH | ETH_RX_BUF_SIZE;  
 80005a8:	f244 57f4 	movw	r7, #17908	; 0x45f4
  for(i=0; i < RxBuffCount; i++)
 80005ac:	2500      	movs	r5, #0
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_RX_BUF_SIZE]);
 80005ae:	f240 5ef4 	movw	lr, #1524	; 0x5f4
    if(i < (RxBuffCount-1))
 80005b2:	f103 3cff 	add.w	ip, r3, #4294967295
  heth->RxDesc = DMARxDescTab; 
 80005b6:	6281      	str	r1, [r0, #40]	; 0x28
  for(i=0; i < RxBuffCount; i++)
 80005b8:	429d      	cmp	r5, r3
 80005ba:	d10c      	bne.n	80005d6 <HAL_ETH_DMARxDescListInit+0x50>
  (heth->Instance)->DMARDLAR = (uint32_t) DMARxDescTab;
 80005bc:	6802      	ldr	r2, [r0, #0]
 80005be:	f241 030c 	movw	r3, #4108	; 0x100c
 80005c2:	50d1      	str	r1, [r2, r3]
  heth->State= HAL_ETH_STATE_READY;
 80005c4:	2301      	movs	r3, #1
 80005c6:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 80005ca:	2300      	movs	r3, #0
 80005cc:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  return HAL_OK;
 80005d0:	4618      	mov	r0, r3
 80005d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_RX_BUF_SIZE]);
 80005d6:	fb0e 2805 	mla	r8, lr, r5, r2
    DMARxDesc->Status = ETH_DMARXDESC_OWN;
 80005da:	f844 6c20 	str.w	r6, [r4, #-32]
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_RX_BUF_SIZE]);
 80005de:	f844 8c18 	str.w	r8, [r4, #-24]
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
 80005e2:	4565      	cmp	r5, ip
 80005e4:	bf2c      	ite	cs
 80005e6:	4688      	movcs	r8, r1
 80005e8:	46a0      	movcc	r8, r4
    DMARxDesc->ControlBufferSize = ETH_DMARXDESC_RCH | ETH_RX_BUF_SIZE;  
 80005ea:	f844 7c1c 	str.w	r7, [r4, #-28]
  for(i=0; i < RxBuffCount; i++)
 80005ee:	3501      	adds	r5, #1
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
 80005f0:	f844 8c14 	str.w	r8, [r4, #-20]
 80005f4:	3420      	adds	r4, #32
 80005f6:	e7df      	b.n	80005b8 <HAL_ETH_DMARxDescListInit+0x32>
  __HAL_LOCK(heth);
 80005f8:	4620      	mov	r0, r4
}
 80005fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08000600 <HAL_ETH_TransmitFrame>:
  __HAL_LOCK(heth);
 8000600:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8000604:	2b01      	cmp	r3, #1
 8000606:	f04f 0302 	mov.w	r3, #2
{
 800060a:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LOCK(heth);
 800060c:	d066      	beq.n	80006dc <HAL_ETH_TransmitFrame+0xdc>
 800060e:	2201      	movs	r2, #1
  heth->State = HAL_ETH_STATE_BUSY;
 8000610:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_LOCK(heth);
 8000614:	f880 2045 	strb.w	r2, [r0, #69]	; 0x45
  if (FrameLength == 0) 
 8000618:	b929      	cbnz	r1, 8000626 <HAL_ETH_TransmitFrame+0x26>
    heth->State = HAL_ETH_STATE_READY;
 800061a:	f880 2044 	strb.w	r2, [r0, #68]	; 0x44
    __HAL_UNLOCK(heth);
 800061e:	f880 1045 	strb.w	r1, [r0, #69]	; 0x45
    return HAL_ERROR;
 8000622:	4610      	mov	r0, r2
 8000624:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if(((heth->TxDesc)->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
 8000626:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8000628:	681c      	ldr	r4, [r3, #0]
 800062a:	2c00      	cmp	r4, #0
 800062c:	da06      	bge.n	800063c <HAL_ETH_TransmitFrame+0x3c>
    heth->State = HAL_ETH_STATE_BUSY_TX;
 800062e:	2312      	movs	r3, #18
 8000630:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
    __HAL_UNLOCK(heth);
 8000634:	2300      	movs	r3, #0
 8000636:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
 800063a:	e7f2      	b.n	8000622 <HAL_ETH_TransmitFrame+0x22>
  if (FrameLength > ETH_TX_BUF_SIZE)
 800063c:	f240 54f4 	movw	r4, #1524	; 0x5f4
 8000640:	42a1      	cmp	r1, r4
 8000642:	d92c      	bls.n	800069e <HAL_ETH_TransmitFrame+0x9e>
    bufcount = FrameLength/ETH_TX_BUF_SIZE;
 8000644:	fbb1 f2f4 	udiv	r2, r1, r4
    if (FrameLength % ETH_TX_BUF_SIZE) 
 8000648:	fb04 1412 	mls	r4, r4, r2, r1
 800064c:	b32c      	cbz	r4, 800069a <HAL_ETH_TransmitFrame+0x9a>
      bufcount++;
 800064e:	3201      	adds	r2, #1
        size = FrameLength - (bufcount-1)*ETH_TX_BUF_SIZE;
 8000650:	4c23      	ldr	r4, [pc, #140]	; (80006e0 <HAL_ETH_TransmitFrame+0xe0>)
 8000652:	f201 51f4 	addw	r1, r1, #1524	; 0x5f4
      heth->TxDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATXDESC_TBS1);
 8000656:	f240 56f4 	movw	r6, #1524	; 0x5f4
      if (i == (bufcount-1))
 800065a:	1e57      	subs	r7, r2, #1
        size = FrameLength - (bufcount-1)*ETH_TX_BUF_SIZE;
 800065c:	fb04 1102 	mla	r1, r4, r2, r1
        heth->TxDesc->ControlBufferSize = (size & ETH_DMATXDESC_TBS1);
 8000660:	2400      	movs	r4, #0
 8000662:	f3c1 010c 	ubfx	r1, r1, #0, #13
      heth->TxDesc->Status &= ~(ETH_DMATXDESC_FS | ETH_DMATXDESC_LS);
 8000666:	681d      	ldr	r5, [r3, #0]
 8000668:	f025 5540 	bic.w	r5, r5, #805306368	; 0x30000000
 800066c:	601d      	str	r5, [r3, #0]
      if (i == 0) 
 800066e:	b91c      	cbnz	r4, 8000678 <HAL_ETH_TransmitFrame+0x78>
        heth->TxDesc->Status |= ETH_DMATXDESC_FS;  
 8000670:	681d      	ldr	r5, [r3, #0]
 8000672:	f045 5580 	orr.w	r5, r5, #268435456	; 0x10000000
 8000676:	601d      	str	r5, [r3, #0]
      if (i == (bufcount-1))
 8000678:	42a7      	cmp	r7, r4
      heth->TxDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATXDESC_TBS1);
 800067a:	605e      	str	r6, [r3, #4]
      if (i == (bufcount-1))
 800067c:	d104      	bne.n	8000688 <HAL_ETH_TransmitFrame+0x88>
        heth->TxDesc->Status |= ETH_DMATXDESC_LS;
 800067e:	681d      	ldr	r5, [r3, #0]
        heth->TxDesc->ControlBufferSize = (size & ETH_DMATXDESC_TBS1);
 8000680:	6059      	str	r1, [r3, #4]
        heth->TxDesc->Status |= ETH_DMATXDESC_LS;
 8000682:	f045 5500 	orr.w	r5, r5, #536870912	; 0x20000000
 8000686:	601d      	str	r5, [r3, #0]
      heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 8000688:	681d      	ldr	r5, [r3, #0]
    for (i=0; i< bufcount; i++)
 800068a:	3401      	adds	r4, #1
      heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 800068c:	f045 4500 	orr.w	r5, r5, #2147483648	; 0x80000000
    for (i=0; i< bufcount; i++)
 8000690:	4294      	cmp	r4, r2
      heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 8000692:	601d      	str	r5, [r3, #0]
      heth->TxDesc = (ETH_DMADescTypeDef *)(heth->TxDesc->Buffer2NextDescAddr);
 8000694:	68db      	ldr	r3, [r3, #12]
    for (i=0; i< bufcount; i++)
 8000696:	d1e6      	bne.n	8000666 <HAL_ETH_TransmitFrame+0x66>
 8000698:	e00d      	b.n	80006b6 <HAL_ETH_TransmitFrame+0xb6>
  if (bufcount == 1)
 800069a:	2a01      	cmp	r2, #1
 800069c:	d1d8      	bne.n	8000650 <HAL_ETH_TransmitFrame+0x50>
    heth->TxDesc->Status |=ETH_DMATXDESC_FS|ETH_DMATXDESC_LS;
 800069e:	681a      	ldr	r2, [r3, #0]
    heth->TxDesc->ControlBufferSize = (FrameLength & ETH_DMATXDESC_TBS1);
 80006a0:	f3c1 010c 	ubfx	r1, r1, #0, #13
    heth->TxDesc->Status |=ETH_DMATXDESC_FS|ETH_DMATXDESC_LS;
 80006a4:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
    heth->TxDesc->ControlBufferSize = (FrameLength & ETH_DMATXDESC_TBS1);
 80006a8:	6059      	str	r1, [r3, #4]
    heth->TxDesc->Status |=ETH_DMATXDESC_FS|ETH_DMATXDESC_LS;
 80006aa:	601a      	str	r2, [r3, #0]
    heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 80006ac:	681a      	ldr	r2, [r3, #0]
 80006ae:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 80006b2:	601a      	str	r2, [r3, #0]
    heth->TxDesc= (ETH_DMADescTypeDef *)(heth->TxDesc->Buffer2NextDescAddr);
 80006b4:	68db      	ldr	r3, [r3, #12]
 80006b6:	62c3      	str	r3, [r0, #44]	; 0x2c
  if (((heth->Instance)->DMASR & ETH_DMASR_TBUS) != (uint32_t)RESET)
 80006b8:	f241 0214 	movw	r2, #4116	; 0x1014
 80006bc:	6803      	ldr	r3, [r0, #0]
 80006be:	5899      	ldr	r1, [r3, r2]
 80006c0:	0749      	lsls	r1, r1, #29
 80006c2:	d505      	bpl.n	80006d0 <HAL_ETH_TransmitFrame+0xd0>
    (heth->Instance)->DMASR = ETH_DMASR_TBUS;
 80006c4:	2104      	movs	r1, #4
 80006c6:	5099      	str	r1, [r3, r2]
    (heth->Instance)->DMATPDR = 0;
 80006c8:	2100      	movs	r1, #0
 80006ca:	f241 0204 	movw	r2, #4100	; 0x1004
 80006ce:	5099      	str	r1, [r3, r2]
  heth->State = HAL_ETH_STATE_READY;
 80006d0:	2301      	movs	r3, #1
 80006d2:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 80006d6:	2300      	movs	r3, #0
 80006d8:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  __HAL_LOCK(heth);
 80006dc:	4618      	mov	r0, r3
}
 80006de:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80006e0:	fffffa0c 	.word	0xfffffa0c

080006e4 <HAL_ETH_GetReceivedFrame_IT>:
  __HAL_LOCK(heth);
 80006e4:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 80006e8:	2b01      	cmp	r3, #1
 80006ea:	f04f 0302 	mov.w	r3, #2
{
 80006ee:	b530      	push	{r4, r5, lr}
  __HAL_LOCK(heth);
 80006f0:	d03b      	beq.n	800076a <HAL_ETH_GetReceivedFrame_IT+0x86>
 80006f2:	2201      	movs	r2, #1
  while (((heth->RxDesc->Status & ETH_DMARXDESC_OWN) == (uint32_t)RESET) && (descriptorscancounter < ETH_RXBUFNB))
 80006f4:	2405      	movs	r4, #5
  heth->State = HAL_ETH_STATE_BUSY;
 80006f6:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
      heth->RxFrameInfos.SegCount = 1;   
 80006fa:	4611      	mov	r1, r2
  __HAL_LOCK(heth);
 80006fc:	f880 2045 	strb.w	r2, [r0, #69]	; 0x45
  while (((heth->RxDesc->Status & ETH_DMARXDESC_OWN) == (uint32_t)RESET) && (descriptorscancounter < ETH_RXBUFNB))
 8000700:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8000702:	681a      	ldr	r2, [r3, #0]
 8000704:	2a00      	cmp	r2, #0
 8000706:	db01      	blt.n	800070c <HAL_ETH_GetReceivedFrame_IT+0x28>
 8000708:	3c01      	subs	r4, #1
 800070a:	d106      	bne.n	800071a <HAL_ETH_GetReceivedFrame_IT+0x36>
  heth->State = HAL_ETH_STATE_READY;
 800070c:	2301      	movs	r3, #1
  __HAL_UNLOCK(heth);
 800070e:	2200      	movs	r2, #0
  heth->State = HAL_ETH_STATE_READY;
 8000710:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 8000714:	f880 2045 	strb.w	r2, [r0, #69]	; 0x45
  return HAL_ERROR;
 8000718:	e027      	b.n	800076a <HAL_ETH_GetReceivedFrame_IT+0x86>
    if((heth->RxDesc->Status & (ETH_DMARXDESC_FS | ETH_DMARXDESC_LS)) == (uint32_t)ETH_DMARXDESC_FS)
 800071a:	681a      	ldr	r2, [r3, #0]
 800071c:	68dd      	ldr	r5, [r3, #12]
 800071e:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8000722:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8000726:	d103      	bne.n	8000730 <HAL_ETH_GetReceivedFrame_IT+0x4c>
      heth->RxFrameInfos.FSRxDesc = heth->RxDesc;
 8000728:	6303      	str	r3, [r0, #48]	; 0x30
      heth->RxFrameInfos.SegCount = 1;   
 800072a:	6381      	str	r1, [r0, #56]	; 0x38
      heth->RxDesc = (ETH_DMADescTypeDef*)(heth->RxDesc->Buffer2NextDescAddr);
 800072c:	6285      	str	r5, [r0, #40]	; 0x28
 800072e:	e7e7      	b.n	8000700 <HAL_ETH_GetReceivedFrame_IT+0x1c>
    else if ((heth->RxDesc->Status & (ETH_DMARXDESC_LS | ETH_DMARXDESC_FS)) == (uint32_t)RESET)
 8000730:	681a      	ldr	r2, [r3, #0]
 8000732:	f412 7f40 	tst.w	r2, #768	; 0x300
 8000736:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8000738:	d102      	bne.n	8000740 <HAL_ETH_GetReceivedFrame_IT+0x5c>
      (heth->RxFrameInfos.SegCount)++;
 800073a:	3201      	adds	r2, #1
 800073c:	6382      	str	r2, [r0, #56]	; 0x38
 800073e:	e7f5      	b.n	800072c <HAL_ETH_GetReceivedFrame_IT+0x48>
      (heth->RxFrameInfos.SegCount)++;
 8000740:	3201      	adds	r2, #1
      heth->RxFrameInfos.LSRxDesc = heth->RxDesc;
 8000742:	6343      	str	r3, [r0, #52]	; 0x34
      if ((heth->RxFrameInfos.SegCount) == 1)
 8000744:	2a01      	cmp	r2, #1
      (heth->RxFrameInfos.SegCount)++;
 8000746:	6382      	str	r2, [r0, #56]	; 0x38
        heth->RxFrameInfos.FSRxDesc = heth->RxDesc;
 8000748:	bf08      	it	eq
 800074a:	6303      	streq	r3, [r0, #48]	; 0x30
      heth->RxFrameInfos.length = (((heth->RxDesc)->Status & ETH_DMARXDESC_FL) >> ETH_DMARXDESC_FRAMELENGTHSHIFT) - 4;
 800074c:	681b      	ldr	r3, [r3, #0]
 800074e:	f3c3 430d 	ubfx	r3, r3, #16, #14
 8000752:	3b04      	subs	r3, #4
 8000754:	63c3      	str	r3, [r0, #60]	; 0x3c
      heth->RxFrameInfos.buffer =((heth->RxFrameInfos).FSRxDesc)->Buffer1Addr;
 8000756:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8000758:	689b      	ldr	r3, [r3, #8]
      heth->RxDesc = (ETH_DMADescTypeDef*) (heth->RxDesc->Buffer2NextDescAddr);
 800075a:	6285      	str	r5, [r0, #40]	; 0x28
      heth->RxFrameInfos.buffer =((heth->RxFrameInfos).FSRxDesc)->Buffer1Addr;
 800075c:	6403      	str	r3, [r0, #64]	; 0x40
      heth->State = HAL_ETH_STATE_READY;
 800075e:	2301      	movs	r3, #1
 8000760:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
      __HAL_UNLOCK(heth);
 8000764:	2300      	movs	r3, #0
 8000766:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
}
 800076a:	4618      	mov	r0, r3
 800076c:	bd30      	pop	{r4, r5, pc}

0800076e <HAL_ETH_TxCpltCallback>:
 800076e:	4770      	bx	lr

08000770 <HAL_ETH_ErrorCallback>:
{
 8000770:	4770      	bx	lr

08000772 <HAL_ETH_IRQHandler>:
{
 8000772:	b570      	push	{r4, r5, r6, lr}
  if (__HAL_ETH_DMA_GET_FLAG(heth, ETH_DMA_FLAG_R)) 
 8000774:	6802      	ldr	r2, [r0, #0]
 8000776:	f241 0614 	movw	r6, #4116	; 0x1014
{
 800077a:	4604      	mov	r4, r0
  if (__HAL_ETH_DMA_GET_FLAG(heth, ETH_DMA_FLAG_R)) 
 800077c:	5995      	ldr	r5, [r2, r6]
 800077e:	f015 0540 	ands.w	r5, r5, #64	; 0x40
 8000782:	d021      	beq.n	80007c8 <HAL_ETH_IRQHandler+0x56>
    HAL_ETH_RxCpltCallback(heth);
 8000784:	f008 fe5c 	bl	8009440 <HAL_ETH_RxCpltCallback>
    __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_IT_R);
 8000788:	6823      	ldr	r3, [r4, #0]
 800078a:	2240      	movs	r2, #64	; 0x40
 800078c:	519a      	str	r2, [r3, r6]
    heth->State = HAL_ETH_STATE_READY;
 800078e:	2301      	movs	r3, #1
 8000790:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    __HAL_UNLOCK(heth);
 8000794:	2300      	movs	r3, #0
 8000796:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_IT_NIS);
 800079a:	6823      	ldr	r3, [r4, #0]
 800079c:	f241 0514 	movw	r5, #4116	; 0x1014
 80007a0:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80007a4:	515a      	str	r2, [r3, r5]
  if(__HAL_ETH_DMA_GET_FLAG(heth, ETH_DMA_FLAG_AIS))
 80007a6:	595b      	ldr	r3, [r3, r5]
 80007a8:	041b      	lsls	r3, r3, #16
 80007aa:	d50c      	bpl.n	80007c6 <HAL_ETH_IRQHandler+0x54>
    HAL_ETH_ErrorCallback(heth);
 80007ac:	4620      	mov	r0, r4
 80007ae:	f7ff ffdf 	bl	8000770 <HAL_ETH_ErrorCallback>
    __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_FLAG_AIS);
 80007b2:	6823      	ldr	r3, [r4, #0]
 80007b4:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80007b8:	515a      	str	r2, [r3, r5]
    heth->State = HAL_ETH_STATE_READY;
 80007ba:	2301      	movs	r3, #1
 80007bc:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    __HAL_UNLOCK(heth);
 80007c0:	2300      	movs	r3, #0
 80007c2:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 80007c6:	bd70      	pop	{r4, r5, r6, pc}
  else if (__HAL_ETH_DMA_GET_FLAG(heth, ETH_DMA_FLAG_T)) 
 80007c8:	5993      	ldr	r3, [r2, r6]
 80007ca:	07da      	lsls	r2, r3, #31
 80007cc:	d5e5      	bpl.n	800079a <HAL_ETH_IRQHandler+0x28>
    HAL_ETH_TxCpltCallback(heth);
 80007ce:	f7ff ffce 	bl	800076e <HAL_ETH_TxCpltCallback>
    __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_IT_T);
 80007d2:	2301      	movs	r3, #1
 80007d4:	6822      	ldr	r2, [r4, #0]
 80007d6:	5193      	str	r3, [r2, r6]
    heth->State = HAL_ETH_STATE_READY;
 80007d8:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    __HAL_UNLOCK(heth);
 80007dc:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
 80007e0:	e7db      	b.n	800079a <HAL_ETH_IRQHandler+0x28>

080007e2 <HAL_ETH_ReadPHYRegister>:
{
 80007e2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(heth->State == HAL_ETH_STATE_BUSY_RD)
 80007e4:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
{
 80007e8:	4605      	mov	r5, r0
 80007ea:	4616      	mov	r6, r2
  if(heth->State == HAL_ETH_STATE_BUSY_RD)
 80007ec:	2b82      	cmp	r3, #130	; 0x82
 80007ee:	d030      	beq.n	8000852 <HAL_ETH_ReadPHYRegister+0x70>
  tmpreg = heth->Instance->MACMIIAR;
 80007f0:	6802      	ldr	r2, [r0, #0]
  heth->State = HAL_ETH_STATE_BUSY_RD;
 80007f2:	2382      	movs	r3, #130	; 0x82
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);                   /* Set the PHY register address */
 80007f4:	0189      	lsls	r1, r1, #6
  heth->State = HAL_ETH_STATE_BUSY_RD;
 80007f6:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  tmpreg = heth->Instance->MACMIIAR;
 80007fa:	6913      	ldr	r3, [r2, #16]
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);                   /* Set the PHY register address */
 80007fc:	f401 64f8 	and.w	r4, r1, #1984	; 0x7c0
  tmpreg &= ~ETH_MACMIIAR_CR_MASK;
 8000800:	f003 011c 	and.w	r1, r3, #28
 8000804:	4321      	orrs	r1, r4
  tmpreg |=(((uint32_t)heth->Init.PhyAddress << 11) & ETH_MACMIIAR_PA); /* Set the PHY device address   */
 8000806:	8a04      	ldrh	r4, [r0, #16]
 8000808:	02e4      	lsls	r4, r4, #11
 800080a:	b2a4      	uxth	r4, r4
  tmpreg &= ~ETH_MACMIIAR_MW;                                           /* Set the read mode            */
 800080c:	430c      	orrs	r4, r1
  tmpreg |= ETH_MACMIIAR_MB;                                            /* Set the MII Busy bit         */
 800080e:	f044 0401 	orr.w	r4, r4, #1
  heth->Instance->MACMIIAR = tmpreg;
 8000812:	6114      	str	r4, [r2, #16]
  tickstart = HAL_GetTick();
 8000814:	f7ff fd5c 	bl	80002d0 <HAL_GetTick>
 8000818:	4607      	mov	r7, r0
  while((tmpreg & ETH_MACMIIAR_MB) == ETH_MACMIIAR_MB)
 800081a:	f014 0001 	ands.w	r0, r4, #1
 800081e:	d107      	bne.n	8000830 <HAL_ETH_ReadPHYRegister+0x4e>
  *RegValue = (uint16_t)(heth->Instance->MACMIIDR);
 8000820:	682b      	ldr	r3, [r5, #0]
 8000822:	695b      	ldr	r3, [r3, #20]
 8000824:	b29b      	uxth	r3, r3
 8000826:	6033      	str	r3, [r6, #0]
  heth->State = HAL_ETH_STATE_READY;
 8000828:	2301      	movs	r3, #1
 800082a:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
 800082e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((HAL_GetTick() - tickstart ) > PHY_READ_TO)
 8000830:	f7ff fd4e 	bl	80002d0 <HAL_GetTick>
 8000834:	1bc0      	subs	r0, r0, r7
 8000836:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 800083a:	d307      	bcc.n	800084c <HAL_ETH_ReadPHYRegister+0x6a>
      heth->State= HAL_ETH_STATE_READY;
 800083c:	2301      	movs	r3, #1
      return HAL_TIMEOUT;
 800083e:	2003      	movs	r0, #3
      heth->State= HAL_ETH_STATE_READY;
 8000840:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
      __HAL_UNLOCK(heth);
 8000844:	2300      	movs	r3, #0
 8000846:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
      return HAL_TIMEOUT;
 800084a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    tmpreg = heth->Instance->MACMIIAR;
 800084c:	682b      	ldr	r3, [r5, #0]
 800084e:	691c      	ldr	r4, [r3, #16]
 8000850:	e7e3      	b.n	800081a <HAL_ETH_ReadPHYRegister+0x38>
    return HAL_BUSY;
 8000852:	2002      	movs	r0, #2
}
 8000854:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000856 <HAL_ETH_WritePHYRegister>:
  if(heth->State == HAL_ETH_STATE_BUSY_WR)
 8000856:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 800085a:	2b42      	cmp	r3, #66	; 0x42
{
 800085c:	b570      	push	{r4, r5, r6, lr}
 800085e:	4605      	mov	r5, r0
  if(heth->State == HAL_ETH_STATE_BUSY_WR)
 8000860:	d02e      	beq.n	80008c0 <HAL_ETH_WritePHYRegister+0x6a>
  heth->State = HAL_ETH_STATE_BUSY_WR;
 8000862:	2342      	movs	r3, #66	; 0x42
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);                 /* Set the PHY register address */
 8000864:	018c      	lsls	r4, r1, #6
 8000866:	b292      	uxth	r2, r2
  heth->State = HAL_ETH_STATE_BUSY_WR;
 8000868:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);                 /* Set the PHY register address */
 800086c:	f404 64f8 	and.w	r4, r4, #1984	; 0x7c0
  tmpreg = heth->Instance->MACMIIAR;
 8000870:	6803      	ldr	r3, [r0, #0]
 8000872:	f044 0403 	orr.w	r4, r4, #3
 8000876:	6918      	ldr	r0, [r3, #16]
  tmpreg &= ~ETH_MACMIIAR_CR_MASK;
 8000878:	f000 001c 	and.w	r0, r0, #28
 800087c:	4320      	orrs	r0, r4
  tmpreg |=(((uint32_t)heth->Init.PhyAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
 800087e:	8a2c      	ldrh	r4, [r5, #16]
  heth->Instance->MACMIIDR = (uint16_t)RegValue;
 8000880:	615a      	str	r2, [r3, #20]
  tmpreg |=(((uint32_t)heth->Init.PhyAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
 8000882:	02e4      	lsls	r4, r4, #11
 8000884:	b2a4      	uxth	r4, r4
  tmpreg |= ETH_MACMIIAR_MB;                                          /* Set the MII Busy bit */
 8000886:	4304      	orrs	r4, r0
  heth->Instance->MACMIIAR = tmpreg;
 8000888:	611c      	str	r4, [r3, #16]
  tickstart = HAL_GetTick();
 800088a:	f7ff fd21 	bl	80002d0 <HAL_GetTick>
 800088e:	4606      	mov	r6, r0
  while((tmpreg & ETH_MACMIIAR_MB) == ETH_MACMIIAR_MB)
 8000890:	f014 0001 	ands.w	r0, r4, #1
 8000894:	d103      	bne.n	800089e <HAL_ETH_WritePHYRegister+0x48>
  heth->State = HAL_ETH_STATE_READY;
 8000896:	2301      	movs	r3, #1
 8000898:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
 800089c:	bd70      	pop	{r4, r5, r6, pc}
    if((HAL_GetTick() - tickstart ) > PHY_WRITE_TO)
 800089e:	f7ff fd17 	bl	80002d0 <HAL_GetTick>
 80008a2:	1b80      	subs	r0, r0, r6
 80008a4:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 80008a8:	d307      	bcc.n	80008ba <HAL_ETH_WritePHYRegister+0x64>
      heth->State= HAL_ETH_STATE_READY;
 80008aa:	2301      	movs	r3, #1
      return HAL_TIMEOUT;
 80008ac:	2003      	movs	r0, #3
      heth->State= HAL_ETH_STATE_READY;
 80008ae:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
      __HAL_UNLOCK(heth);
 80008b2:	2300      	movs	r3, #0
 80008b4:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
 80008b8:	bd70      	pop	{r4, r5, r6, pc}
    tmpreg = heth->Instance->MACMIIAR;
 80008ba:	682b      	ldr	r3, [r5, #0]
 80008bc:	691c      	ldr	r4, [r3, #16]
 80008be:	e7e7      	b.n	8000890 <HAL_ETH_WritePHYRegister+0x3a>
    return HAL_BUSY;
 80008c0:	2002      	movs	r0, #2
}
 80008c2:	bd70      	pop	{r4, r5, r6, pc}

080008c4 <HAL_ETH_Init>:
  uint32_t tempreg = 0, phyreg = 0;
 80008c4:	2300      	movs	r3, #0
{
 80008c6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if(heth == NULL)
 80008c8:	4604      	mov	r4, r0
  uint32_t tempreg = 0, phyreg = 0;
 80008ca:	9300      	str	r3, [sp, #0]
  if(heth == NULL)
 80008cc:	2800      	cmp	r0, #0
 80008ce:	f000 80dc 	beq.w	8000a8a <HAL_ETH_Init+0x1c6>
  if(heth->State == HAL_ETH_STATE_RESET)
 80008d2:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 80008d6:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80008da:	b91b      	cbnz	r3, 80008e4 <HAL_ETH_Init+0x20>
    heth->Lock = HAL_UNLOCKED;
 80008dc:	f880 2045 	strb.w	r2, [r0, #69]	; 0x45
    HAL_ETH_MspInit(heth);
 80008e0:	f008 fd48 	bl	8009374 <HAL_ETH_MspInit>
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80008e4:	4b6a      	ldr	r3, [pc, #424]	; (8000a90 <HAL_ETH_Init+0x1cc>)
 80008e6:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80008e8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80008ec:	645a      	str	r2, [r3, #68]	; 0x44
 80008ee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80008f0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80008f4:	9301      	str	r3, [sp, #4]
 80008f6:	9b01      	ldr	r3, [sp, #4]
  SYSCFG->PMC &= ~(SYSCFG_PMC_MII_RMII_SEL);
 80008f8:	4b66      	ldr	r3, [pc, #408]	; (8000a94 <HAL_ETH_Init+0x1d0>)
 80008fa:	685a      	ldr	r2, [r3, #4]
 80008fc:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8000900:	605a      	str	r2, [r3, #4]
  SYSCFG->PMC |= (uint32_t)heth->Init.MediaInterface;
 8000902:	685a      	ldr	r2, [r3, #4]
 8000904:	6a21      	ldr	r1, [r4, #32]
 8000906:	430a      	orrs	r2, r1
 8000908:	605a      	str	r2, [r3, #4]
  (heth->Instance)->DMABMR |= ETH_DMABMR_SR;
 800090a:	6823      	ldr	r3, [r4, #0]
 800090c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8000910:	681a      	ldr	r2, [r3, #0]
 8000912:	f042 0201 	orr.w	r2, r2, #1
 8000916:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 8000918:	f7ff fcda 	bl	80002d0 <HAL_GetTick>
 800091c:	4605      	mov	r5, r0
  while (((heth->Instance)->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
 800091e:	6823      	ldr	r3, [r4, #0]
 8000920:	f503 5280 	add.w	r2, r3, #4096	; 0x1000
 8000924:	6812      	ldr	r2, [r2, #0]
 8000926:	07d0      	lsls	r0, r2, #31
 8000928:	d41d      	bmi.n	8000966 <HAL_ETH_Init+0xa2>
  tempreg = (heth->Instance)->MACMIIAR;
 800092a:	691d      	ldr	r5, [r3, #16]
  hclk = HAL_RCC_GetHCLKFreq();
 800092c:	f000 fd2e 	bl	800138c <HAL_RCC_GetHCLKFreq>
  if((hclk >= 20000000)&&(hclk < 35000000))
 8000930:	4b59      	ldr	r3, [pc, #356]	; (8000a98 <HAL_ETH_Init+0x1d4>)
 8000932:	4a5a      	ldr	r2, [pc, #360]	; (8000a9c <HAL_ETH_Init+0x1d8>)
  tempreg &= ETH_MACMIIAR_CR_MASK;
 8000934:	f025 051c 	bic.w	r5, r5, #28
  if((hclk >= 20000000)&&(hclk < 35000000))
 8000938:	4403      	add	r3, r0
 800093a:	4293      	cmp	r3, r2
 800093c:	d822      	bhi.n	8000984 <HAL_ETH_Init+0xc0>
    tempreg |= (uint32_t)ETH_MACMIIAR_CR_Div16;
 800093e:	f045 0508 	orr.w	r5, r5, #8
  (heth->Instance)->MACMIIAR = (uint32_t)tempreg;
 8000942:	6823      	ldr	r3, [r4, #0]
  if((HAL_ETH_WritePHYRegister(heth, PHY_BCR, PHY_RESET)) != HAL_OK)
 8000944:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8000948:	2100      	movs	r1, #0
 800094a:	4620      	mov	r0, r4
  (heth->Instance)->MACMIIAR = (uint32_t)tempreg;
 800094c:	611d      	str	r5, [r3, #16]
  if((HAL_ETH_WritePHYRegister(heth, PHY_BCR, PHY_RESET)) != HAL_OK)
 800094e:	f7ff ff82 	bl	8000856 <HAL_ETH_WritePHYRegister>
 8000952:	4605      	mov	r5, r0
 8000954:	b368      	cbz	r0, 80009b2 <HAL_ETH_Init+0xee>
      heth->State = HAL_ETH_STATE_READY;
 8000956:	2501      	movs	r5, #1
      ETH_MACDMAConfig(heth, err);
 8000958:	2101      	movs	r1, #1
 800095a:	4620      	mov	r0, r4
 800095c:	f7ff fd5a 	bl	8000414 <ETH_MACDMAConfig>
      heth->State = HAL_ETH_STATE_READY;
 8000960:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
      return HAL_ERROR;
 8000964:	e00b      	b.n	800097e <HAL_ETH_Init+0xba>
    if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_SWRESET)
 8000966:	f7ff fcb3 	bl	80002d0 <HAL_GetTick>
 800096a:	1b40      	subs	r0, r0, r5
 800096c:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 8000970:	d9d5      	bls.n	800091e <HAL_ETH_Init+0x5a>
      heth->State= HAL_ETH_STATE_TIMEOUT;
 8000972:	2503      	movs	r5, #3
      __HAL_UNLOCK(heth);
 8000974:	2300      	movs	r3, #0
      heth->State= HAL_ETH_STATE_TIMEOUT;
 8000976:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
      __HAL_UNLOCK(heth);
 800097a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
}
 800097e:	4628      	mov	r0, r5
 8000980:	b003      	add	sp, #12
 8000982:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if((hclk >= 35000000)&&(hclk < 60000000))
 8000984:	4b46      	ldr	r3, [pc, #280]	; (8000aa0 <HAL_ETH_Init+0x1dc>)
 8000986:	4a47      	ldr	r2, [pc, #284]	; (8000aa4 <HAL_ETH_Init+0x1e0>)
 8000988:	4403      	add	r3, r0
 800098a:	4293      	cmp	r3, r2
 800098c:	d802      	bhi.n	8000994 <HAL_ETH_Init+0xd0>
    tempreg |= (uint32_t)ETH_MACMIIAR_CR_Div26;
 800098e:	f045 050c 	orr.w	r5, r5, #12
 8000992:	e7d6      	b.n	8000942 <HAL_ETH_Init+0x7e>
  else if((hclk >= 60000000)&&(hclk < 100000000))
 8000994:	4b44      	ldr	r3, [pc, #272]	; (8000aa8 <HAL_ETH_Init+0x1e4>)
 8000996:	4a45      	ldr	r2, [pc, #276]	; (8000aac <HAL_ETH_Init+0x1e8>)
 8000998:	4403      	add	r3, r0
 800099a:	4293      	cmp	r3, r2
 800099c:	d9d1      	bls.n	8000942 <HAL_ETH_Init+0x7e>
  else if((hclk >= 100000000)&&(hclk < 150000000))
 800099e:	4b44      	ldr	r3, [pc, #272]	; (8000ab0 <HAL_ETH_Init+0x1ec>)
 80009a0:	4a44      	ldr	r2, [pc, #272]	; (8000ab4 <HAL_ETH_Init+0x1f0>)
 80009a2:	4403      	add	r3, r0
 80009a4:	4293      	cmp	r3, r2
    tempreg |= (uint32_t)ETH_MACMIIAR_CR_Div62;
 80009a6:	bf94      	ite	ls
 80009a8:	f045 0504 	orrls.w	r5, r5, #4
    tempreg |= (uint32_t)ETH_MACMIIAR_CR_Div102;    
 80009ac:	f045 0510 	orrhi.w	r5, r5, #16
 80009b0:	e7c7      	b.n	8000942 <HAL_ETH_Init+0x7e>
  HAL_Delay(PHY_RESET_DELAY);
 80009b2:	20ff      	movs	r0, #255	; 0xff
 80009b4:	f7ff fc92 	bl	80002dc <HAL_Delay>
  if((heth->Init).AutoNegotiation != ETH_AUTONEGOTIATION_DISABLE)
 80009b8:	6863      	ldr	r3, [r4, #4]
 80009ba:	2b00      	cmp	r3, #0
 80009bc:	d053      	beq.n	8000a66 <HAL_ETH_Init+0x1a2>
    tickstart = HAL_GetTick();
 80009be:	f7ff fc87 	bl	80002d0 <HAL_GetTick>
      if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_LINKED_STATE)
 80009c2:	f241 3788 	movw	r7, #5000	; 0x1388
    tickstart = HAL_GetTick();
 80009c6:	4606      	mov	r6, r0
      HAL_ETH_ReadPHYRegister(heth, PHY_BSR, &phyreg);
 80009c8:	466a      	mov	r2, sp
 80009ca:	2101      	movs	r1, #1
 80009cc:	4620      	mov	r0, r4
 80009ce:	f7ff ff08 	bl	80007e2 <HAL_ETH_ReadPHYRegister>
      if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_LINKED_STATE)
 80009d2:	f7ff fc7d 	bl	80002d0 <HAL_GetTick>
 80009d6:	1b80      	subs	r0, r0, r6
 80009d8:	42b8      	cmp	r0, r7
 80009da:	d90b      	bls.n	80009f4 <HAL_ETH_Init+0x130>
        ETH_MACDMAConfig(heth, err);
 80009dc:	2101      	movs	r1, #1
 80009de:	4620      	mov	r0, r4
 80009e0:	f7ff fd18 	bl	8000414 <ETH_MACDMAConfig>
        heth->State= HAL_ETH_STATE_READY;
 80009e4:	2301      	movs	r3, #1
        return HAL_TIMEOUT;
 80009e6:	2503      	movs	r5, #3
        heth->State= HAL_ETH_STATE_READY;
 80009e8:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(heth);
 80009ec:	2300      	movs	r3, #0
 80009ee:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
        return HAL_TIMEOUT;
 80009f2:	e7c4      	b.n	800097e <HAL_ETH_Init+0xba>
    } while (((phyreg & PHY_LINKED_STATUS) != PHY_LINKED_STATUS));
 80009f4:	9b00      	ldr	r3, [sp, #0]
 80009f6:	0759      	lsls	r1, r3, #29
 80009f8:	d5e6      	bpl.n	80009c8 <HAL_ETH_Init+0x104>
    if((HAL_ETH_WritePHYRegister(heth, PHY_BCR, PHY_AUTONEGOTIATION)) != HAL_OK)
 80009fa:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80009fe:	2100      	movs	r1, #0
 8000a00:	4620      	mov	r0, r4
 8000a02:	f7ff ff28 	bl	8000856 <HAL_ETH_WritePHYRegister>
 8000a06:	2800      	cmp	r0, #0
 8000a08:	d1a5      	bne.n	8000956 <HAL_ETH_Init+0x92>
    tickstart = HAL_GetTick();
 8000a0a:	f7ff fc61 	bl	80002d0 <HAL_GetTick>
      if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_AUTONEGO_COMPLETED)
 8000a0e:	f241 3788 	movw	r7, #5000	; 0x1388
    tickstart = HAL_GetTick();
 8000a12:	4606      	mov	r6, r0
      HAL_ETH_ReadPHYRegister(heth, PHY_BSR, &phyreg);
 8000a14:	466a      	mov	r2, sp
 8000a16:	2101      	movs	r1, #1
 8000a18:	4620      	mov	r0, r4
 8000a1a:	f7ff fee2 	bl	80007e2 <HAL_ETH_ReadPHYRegister>
      if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_AUTONEGO_COMPLETED)
 8000a1e:	f7ff fc57 	bl	80002d0 <HAL_GetTick>
 8000a22:	1b80      	subs	r0, r0, r6
 8000a24:	42b8      	cmp	r0, r7
 8000a26:	d8d9      	bhi.n	80009dc <HAL_ETH_Init+0x118>
    } while (((phyreg & PHY_AUTONEGO_COMPLETE) != PHY_AUTONEGO_COMPLETE));
 8000a28:	9b00      	ldr	r3, [sp, #0]
 8000a2a:	069a      	lsls	r2, r3, #26
 8000a2c:	d5f2      	bpl.n	8000a14 <HAL_ETH_Init+0x150>
    if((HAL_ETH_ReadPHYRegister(heth, PHY_SR, &phyreg)) != HAL_OK)
 8000a2e:	466a      	mov	r2, sp
 8000a30:	2110      	movs	r1, #16
 8000a32:	4620      	mov	r0, r4
 8000a34:	f7ff fed5 	bl	80007e2 <HAL_ETH_ReadPHYRegister>
 8000a38:	2800      	cmp	r0, #0
 8000a3a:	d18c      	bne.n	8000956 <HAL_ETH_Init+0x92>
    if((phyreg & PHY_DUPLEX_STATUS) != (uint32_t)RESET)
 8000a3c:	9b00      	ldr	r3, [sp, #0]
 8000a3e:	f013 0204 	ands.w	r2, r3, #4
      (heth->Init).DuplexMode = ETH_MODE_FULLDUPLEX;  
 8000a42:	bf18      	it	ne
 8000a44:	f44f 6200 	movne.w	r2, #2048	; 0x800
    if((phyreg & PHY_SPEED_STATUS) == PHY_SPEED_STATUS)
 8000a48:	079b      	lsls	r3, r3, #30
      (heth->Init).Speed = ETH_SPEED_10M; 
 8000a4a:	bf4c      	ite	mi
 8000a4c:	2300      	movmi	r3, #0
      (heth->Init).Speed = ETH_SPEED_100M;
 8000a4e:	f44f 4380 	movpl.w	r3, #16384	; 0x4000
      (heth->Init).DuplexMode = ETH_MODE_HALFDUPLEX;           
 8000a52:	60e2      	str	r2, [r4, #12]
      (heth->Init).Speed = ETH_SPEED_100M;
 8000a54:	60a3      	str	r3, [r4, #8]
  ETH_MACDMAConfig(heth, err);
 8000a56:	2100      	movs	r1, #0
 8000a58:	4620      	mov	r0, r4
 8000a5a:	f7ff fcdb 	bl	8000414 <ETH_MACDMAConfig>
  heth->State= HAL_ETH_STATE_READY;
 8000a5e:	2301      	movs	r3, #1
 8000a60:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
  return HAL_OK;
 8000a64:	e78b      	b.n	800097e <HAL_ETH_Init+0xba>
                                                (uint16_t)((heth->Init).Speed >> 1))) != HAL_OK)
 8000a66:	68a3      	ldr	r3, [r4, #8]
    if(HAL_ETH_WritePHYRegister(heth, PHY_BCR, ((uint16_t)((heth->Init).DuplexMode >> 3) |
 8000a68:	4629      	mov	r1, r5
 8000a6a:	68e2      	ldr	r2, [r4, #12]
 8000a6c:	4620      	mov	r0, r4
                                                (uint16_t)((heth->Init).Speed >> 1))) != HAL_OK)
 8000a6e:	085b      	lsrs	r3, r3, #1
    if(HAL_ETH_WritePHYRegister(heth, PHY_BCR, ((uint16_t)((heth->Init).DuplexMode >> 3) |
 8000a70:	ea43 02d2 	orr.w	r2, r3, r2, lsr #3
 8000a74:	b292      	uxth	r2, r2
 8000a76:	f7ff feee 	bl	8000856 <HAL_ETH_WritePHYRegister>
 8000a7a:	2800      	cmp	r0, #0
 8000a7c:	f47f af6b 	bne.w	8000956 <HAL_ETH_Init+0x92>
    HAL_Delay(PHY_CONFIG_DELAY);
 8000a80:	f640 70ff 	movw	r0, #4095	; 0xfff
 8000a84:	f7ff fc2a 	bl	80002dc <HAL_Delay>
 8000a88:	e7e5      	b.n	8000a56 <HAL_ETH_Init+0x192>
    return HAL_ERROR;
 8000a8a:	2501      	movs	r5, #1
 8000a8c:	e777      	b.n	800097e <HAL_ETH_Init+0xba>
 8000a8e:	bf00      	nop
 8000a90:	40023800 	.word	0x40023800
 8000a94:	40013800 	.word	0x40013800
 8000a98:	feced300 	.word	0xfeced300
 8000a9c:	00e4e1bf 	.word	0x00e4e1bf
 8000aa0:	fde9f140 	.word	0xfde9f140
 8000aa4:	017d783f 	.word	0x017d783f
 8000aa8:	fc6c7900 	.word	0xfc6c7900
 8000aac:	026259ff 	.word	0x026259ff
 8000ab0:	fa0a1f00 	.word	0xfa0a1f00
 8000ab4:	02faf07f 	.word	0x02faf07f

08000ab8 <HAL_ETH_Start>:
  __HAL_LOCK(heth);
 8000ab8:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8000abc:	2b01      	cmp	r3, #1
{  
 8000abe:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8000ac0:	4605      	mov	r5, r0
 8000ac2:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(heth);
 8000ac6:	d033      	beq.n	8000b30 <HAL_ETH_Start+0x78>
  __IO uint32_t tmpreg = 0;
 8000ac8:	2400      	movs	r4, #0
  (heth->Instance)->MACCR |= ETH_MACCR_TE;
 8000aca:	682b      	ldr	r3, [r5, #0]
  heth->State = HAL_ETH_STATE_BUSY;
 8000acc:	f885 0044 	strb.w	r0, [r5, #68]	; 0x44
  __HAL_LOCK(heth);
 8000ad0:	2601      	movs	r6, #1
  __IO uint32_t tmpreg = 0;
 8000ad2:	9401      	str	r4, [sp, #4]
  (heth->Instance)->MACCR |= ETH_MACCR_TE;
 8000ad4:	681a      	ldr	r2, [r3, #0]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8000ad6:	4630      	mov	r0, r6
  __HAL_LOCK(heth);
 8000ad8:	f885 6045 	strb.w	r6, [r5, #69]	; 0x45
  (heth->Instance)->MACCR |= ETH_MACCR_TE;
 8000adc:	f042 0208 	orr.w	r2, r2, #8
 8000ae0:	601a      	str	r2, [r3, #0]
  tmpreg = (heth->Instance)->MACCR;
 8000ae2:	681b      	ldr	r3, [r3, #0]
 8000ae4:	9301      	str	r3, [sp, #4]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8000ae6:	f7ff fbf9 	bl	80002dc <HAL_Delay>
  (heth->Instance)->MACCR = tmpreg;
 8000aea:	9a01      	ldr	r2, [sp, #4]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8000aec:	4630      	mov	r0, r6
  (heth->Instance)->MACCR = tmpreg;
 8000aee:	682b      	ldr	r3, [r5, #0]
 8000af0:	601a      	str	r2, [r3, #0]
  __IO uint32_t tmpreg = 0;
 8000af2:	9400      	str	r4, [sp, #0]
  (heth->Instance)->MACCR |= ETH_MACCR_RE;
 8000af4:	681a      	ldr	r2, [r3, #0]
 8000af6:	f042 0204 	orr.w	r2, r2, #4
 8000afa:	601a      	str	r2, [r3, #0]
  tmpreg = (heth->Instance)->MACCR;
 8000afc:	681b      	ldr	r3, [r3, #0]
 8000afe:	9300      	str	r3, [sp, #0]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8000b00:	f7ff fbec 	bl	80002dc <HAL_Delay>
  (heth->Instance)->MACCR = tmpreg;
 8000b04:	682b      	ldr	r3, [r5, #0]
  ETH_FlushTransmitFIFO(heth);
 8000b06:	4628      	mov	r0, r5
  (heth->Instance)->MACCR = tmpreg;
 8000b08:	9a00      	ldr	r2, [sp, #0]
 8000b0a:	601a      	str	r2, [r3, #0]
  ETH_FlushTransmitFIFO(heth);
 8000b0c:	f7ff fc6c 	bl	80003e8 <ETH_FlushTransmitFIFO>
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_ST;  
 8000b10:	682a      	ldr	r2, [r5, #0]
 8000b12:	f241 0318 	movw	r3, #4120	; 0x1018
  return HAL_OK;
 8000b16:	4620      	mov	r0, r4
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_ST;  
 8000b18:	58d1      	ldr	r1, [r2, r3]
 8000b1a:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 8000b1e:	50d1      	str	r1, [r2, r3]
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_SR;  
 8000b20:	58d1      	ldr	r1, [r2, r3]
 8000b22:	f041 0102 	orr.w	r1, r1, #2
 8000b26:	50d1      	str	r1, [r2, r3]
  heth->State= HAL_ETH_STATE_READY;
 8000b28:	f885 6044 	strb.w	r6, [r5, #68]	; 0x44
  __HAL_UNLOCK(heth);
 8000b2c:	f885 4045 	strb.w	r4, [r5, #69]	; 0x45
}
 8000b30:	b002      	add	sp, #8
 8000b32:	bd70      	pop	{r4, r5, r6, pc}

08000b34 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000b34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  for(position = 0; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000b38:	680b      	ldr	r3, [r1, #0]
{
 8000b3a:	b085      	sub	sp, #20
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000b3c:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 8000d00 <HAL_GPIO_Init+0x1cc>
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000b40:	9301      	str	r3, [sp, #4]
  for(position = 0; position < GPIO_NUMBER; position++)
 8000b42:	2300      	movs	r3, #0
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000b44:	4a6c      	ldr	r2, [pc, #432]	; (8000cf8 <HAL_GPIO_Init+0x1c4>)
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000b46:	f8df 91bc 	ldr.w	r9, [pc, #444]	; 8000d04 <HAL_GPIO_Init+0x1d0>
    ioposition = ((uint32_t)0x01) << position;
 8000b4a:	f04f 0e01 	mov.w	lr, #1
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000b4e:	9c01      	ldr	r4, [sp, #4]
    ioposition = ((uint32_t)0x01) << position;
 8000b50:	fa0e fe03 	lsl.w	lr, lr, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000b54:	ea0e 0604 	and.w	r6, lr, r4
    if(iocurrent == ioposition)
 8000b58:	45b6      	cmp	lr, r6
 8000b5a:	f040 80b3 	bne.w	8000cc4 <HAL_GPIO_Init+0x190>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000b5e:	684c      	ldr	r4, [r1, #4]
 8000b60:	f024 0710 	bic.w	r7, r4, #16
 8000b64:	2f02      	cmp	r7, #2
 8000b66:	d116      	bne.n	8000b96 <HAL_GPIO_Init+0x62>
        temp = GPIOx->AFR[position >> 3];
 8000b68:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000b6c:	f003 0b07 	and.w	fp, r3, #7
 8000b70:	f04f 0c0f 	mov.w	ip, #15
 8000b74:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
 8000b78:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
        temp = GPIOx->AFR[position >> 3];
 8000b7c:	f8da 5020 	ldr.w	r5, [sl, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000b80:	fa0c fc0b 	lsl.w	ip, ip, fp
 8000b84:	ea25 0c0c 	bic.w	ip, r5, ip
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8000b88:	690d      	ldr	r5, [r1, #16]
 8000b8a:	fa05 f50b 	lsl.w	r5, r5, fp
 8000b8e:	ea45 050c 	orr.w	r5, r5, ip
        GPIOx->AFR[position >> 3] = temp;
 8000b92:	f8ca 5020 	str.w	r5, [sl, #32]
 8000b96:	ea4f 0a43 	mov.w	sl, r3, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000b9a:	2503      	movs	r5, #3
      temp = GPIOx->MODER;
 8000b9c:	f8d0 b000 	ldr.w	fp, [r0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000ba0:	f004 0c03 	and.w	ip, r4, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000ba4:	fa05 f50a 	lsl.w	r5, r5, sl
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000ba8:	3f01      	subs	r7, #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000baa:	fa0c fc0a 	lsl.w	ip, ip, sl
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000bae:	43ed      	mvns	r5, r5
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000bb0:	2f01      	cmp	r7, #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000bb2:	ea0b 0b05 	and.w	fp, fp, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000bb6:	ea4c 0c0b 	orr.w	ip, ip, fp
      GPIOx->MODER = temp;
 8000bba:	f8c0 c000 	str.w	ip, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000bbe:	d811      	bhi.n	8000be4 <HAL_GPIO_Init+0xb0>
        temp = GPIOx->OSPEEDR; 
 8000bc0:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8000bc2:	ea07 0b05 	and.w	fp, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2));
 8000bc6:	68cf      	ldr	r7, [r1, #12]
 8000bc8:	fa07 fc0a 	lsl.w	ip, r7, sl
 8000bcc:	ea4c 070b 	orr.w	r7, ip, fp
        GPIOx->OSPEEDR = temp;
 8000bd0:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 8000bd2:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8000bd4:	ea27 0e0e 	bic.w	lr, r7, lr
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8000bd8:	f3c4 1700 	ubfx	r7, r4, #4, #1
 8000bdc:	409f      	lsls	r7, r3
 8000bde:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 8000be2:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 8000be4:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8000be6:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8000be8:	688f      	ldr	r7, [r1, #8]
 8000bea:	fa07 f70a 	lsl.w	r7, r7, sl
 8000bee:	433d      	orrs	r5, r7
      GPIOx->PUPDR = temp;
 8000bf0:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000bf2:	00e5      	lsls	r5, r4, #3
 8000bf4:	d566      	bpl.n	8000cc4 <HAL_GPIO_Init+0x190>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000bf6:	f8d8 5044 	ldr.w	r5, [r8, #68]	; 0x44
 8000bfa:	f023 0703 	bic.w	r7, r3, #3
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000bfe:	f003 0e03 	and.w	lr, r3, #3
 8000c02:	f04f 0c0f 	mov.w	ip, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000c06:	f445 4580 	orr.w	r5, r5, #16384	; 0x4000
 8000c0a:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000c0e:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000c12:	f8c8 5044 	str.w	r5, [r8, #68]	; 0x44
 8000c16:	f507 379c 	add.w	r7, r7, #79872	; 0x13800
 8000c1a:	f8d8 5044 	ldr.w	r5, [r8, #68]	; 0x44
 8000c1e:	f405 4580 	and.w	r5, r5, #16384	; 0x4000
 8000c22:	9503      	str	r5, [sp, #12]
 8000c24:	9d03      	ldr	r5, [sp, #12]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000c26:	fa0c f50e 	lsl.w	r5, ip, lr
        temp = SYSCFG->EXTICR[position >> 2];
 8000c2a:	f8d7 a008 	ldr.w	sl, [r7, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000c2e:	ea2a 0c05 	bic.w	ip, sl, r5
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000c32:	4d32      	ldr	r5, [pc, #200]	; (8000cfc <HAL_GPIO_Init+0x1c8>)
 8000c34:	42a8      	cmp	r0, r5
 8000c36:	d04c      	beq.n	8000cd2 <HAL_GPIO_Init+0x19e>
 8000c38:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000c3c:	42a8      	cmp	r0, r5
 8000c3e:	d04a      	beq.n	8000cd6 <HAL_GPIO_Init+0x1a2>
 8000c40:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000c44:	42a8      	cmp	r0, r5
 8000c46:	d048      	beq.n	8000cda <HAL_GPIO_Init+0x1a6>
 8000c48:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000c4c:	42a8      	cmp	r0, r5
 8000c4e:	d046      	beq.n	8000cde <HAL_GPIO_Init+0x1aa>
 8000c50:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000c54:	42a8      	cmp	r0, r5
 8000c56:	d044      	beq.n	8000ce2 <HAL_GPIO_Init+0x1ae>
 8000c58:	4548      	cmp	r0, r9
 8000c5a:	d044      	beq.n	8000ce6 <HAL_GPIO_Init+0x1b2>
 8000c5c:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8000c60:	42a8      	cmp	r0, r5
 8000c62:	d042      	beq.n	8000cea <HAL_GPIO_Init+0x1b6>
 8000c64:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000c68:	42a8      	cmp	r0, r5
 8000c6a:	d040      	beq.n	8000cee <HAL_GPIO_Init+0x1ba>
 8000c6c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000c70:	42a8      	cmp	r0, r5
 8000c72:	d03e      	beq.n	8000cf2 <HAL_GPIO_Init+0x1be>
 8000c74:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000c78:	42a8      	cmp	r0, r5
 8000c7a:	bf14      	ite	ne
 8000c7c:	250a      	movne	r5, #10
 8000c7e:	2509      	moveq	r5, #9
 8000c80:	fa05 f50e 	lsl.w	r5, r5, lr
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000c84:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000c88:	ea45 050c 	orr.w	r5, r5, ip
        SYSCFG->EXTICR[position >> 2] = temp;
 8000c8c:	60bd      	str	r5, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
 8000c8e:	ea6f 0706 	mvn.w	r7, r6
        temp = EXTI->IMR;
 8000c92:	6815      	ldr	r5, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
 8000c94:	bf0c      	ite	eq
 8000c96:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 8000c98:	4335      	orrne	r5, r6
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000c9a:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        EXTI->IMR = temp;
 8000c9e:	6015      	str	r5, [r2, #0]
        temp = EXTI->EMR;
 8000ca0:	6855      	ldr	r5, [r2, #4]
        temp &= ~((uint32_t)iocurrent);
 8000ca2:	bf0c      	ite	eq
 8000ca4:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 8000ca6:	4335      	orrne	r5, r6
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000ca8:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        EXTI->EMR = temp;
 8000cac:	6055      	str	r5, [r2, #4]
        temp = EXTI->RTSR;
 8000cae:	6895      	ldr	r5, [r2, #8]
        temp &= ~((uint32_t)iocurrent);
 8000cb0:	bf0c      	ite	eq
 8000cb2:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 8000cb4:	4335      	orrne	r5, r6
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000cb6:	02a4      	lsls	r4, r4, #10
        EXTI->RTSR = temp;
 8000cb8:	6095      	str	r5, [r2, #8]
        temp = EXTI->FTSR;
 8000cba:	68d5      	ldr	r5, [r2, #12]
        temp &= ~((uint32_t)iocurrent);
 8000cbc:	bf54      	ite	pl
 8000cbe:	403d      	andpl	r5, r7
        {
          temp |= iocurrent;
 8000cc0:	4335      	orrmi	r5, r6
        }
        EXTI->FTSR = temp;
 8000cc2:	60d5      	str	r5, [r2, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
 8000cc4:	3301      	adds	r3, #1
 8000cc6:	2b10      	cmp	r3, #16
 8000cc8:	f47f af3f 	bne.w	8000b4a <HAL_GPIO_Init+0x16>
      }
    }
  }
}
 8000ccc:	b005      	add	sp, #20
 8000cce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000cd2:	2500      	movs	r5, #0
 8000cd4:	e7d4      	b.n	8000c80 <HAL_GPIO_Init+0x14c>
 8000cd6:	2501      	movs	r5, #1
 8000cd8:	e7d2      	b.n	8000c80 <HAL_GPIO_Init+0x14c>
 8000cda:	2502      	movs	r5, #2
 8000cdc:	e7d0      	b.n	8000c80 <HAL_GPIO_Init+0x14c>
 8000cde:	2503      	movs	r5, #3
 8000ce0:	e7ce      	b.n	8000c80 <HAL_GPIO_Init+0x14c>
 8000ce2:	2504      	movs	r5, #4
 8000ce4:	e7cc      	b.n	8000c80 <HAL_GPIO_Init+0x14c>
 8000ce6:	2505      	movs	r5, #5
 8000ce8:	e7ca      	b.n	8000c80 <HAL_GPIO_Init+0x14c>
 8000cea:	2506      	movs	r5, #6
 8000cec:	e7c8      	b.n	8000c80 <HAL_GPIO_Init+0x14c>
 8000cee:	2507      	movs	r5, #7
 8000cf0:	e7c6      	b.n	8000c80 <HAL_GPIO_Init+0x14c>
 8000cf2:	2508      	movs	r5, #8
 8000cf4:	e7c4      	b.n	8000c80 <HAL_GPIO_Init+0x14c>
 8000cf6:	bf00      	nop
 8000cf8:	40013c00 	.word	0x40013c00
 8000cfc:	40020000 	.word	0x40020000
 8000d00:	40023800 	.word	0x40023800
 8000d04:	40021400 	.word	0x40021400

08000d08 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8000d08:	b10a      	cbz	r2, 8000d0e <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 8000d0a:	6181      	str	r1, [r0, #24]
 8000d0c:	4770      	bx	lr
 8000d0e:	0409      	lsls	r1, r1, #16
 8000d10:	e7fb      	b.n	8000d0a <HAL_GPIO_WritePin+0x2>

08000d12 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and create the associated handle.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
 8000d12:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t i = 0;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 8000d14:	4605      	mov	r5, r0
{ 
 8000d16:	b08b      	sub	sp, #44	; 0x2c
  if(hpcd == NULL)
 8000d18:	2800      	cmp	r0, #0
 8000d1a:	d063      	beq.n	8000de4 <HAL_PCD_Init+0xd2>
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  hpcd->State = HAL_PCD_STATE_BUSY;
 8000d1c:	2303      	movs	r3, #3
  
  /* Init the low level hardware : GPIO, CLOCK, NVIC... */
  HAL_PCD_MspInit(hpcd);

  /* Disable the Interrupts */
 __HAL_PCD_DISABLE(hpcd);
 8000d1e:	462c      	mov	r4, r5
 
 /*Init the Core (common init.) */
 USB_CoreInit(hpcd->Instance, hpcd->Init);
 8000d20:	466e      	mov	r6, sp
 8000d22:	1d2f      	adds	r7, r5, #4
  hpcd->State = HAL_PCD_STATE_BUSY;
 8000d24:	f880 337d 	strb.w	r3, [r0, #893]	; 0x37d
  HAL_PCD_MspInit(hpcd);
 8000d28:	f008 fe1a 	bl	8009960 <HAL_PCD_MspInit>
 __HAL_PCD_DISABLE(hpcd);
 8000d2c:	f854 0b10 	ldr.w	r0, [r4], #16
 8000d30:	f001 facc 	bl	80022cc <USB_DisableGlobalInt>
 USB_CoreInit(hpcd->Instance, hpcd->Init);
 8000d34:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000d36:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8000d38:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000d3a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8000d3c:	6823      	ldr	r3, [r4, #0]
 8000d3e:	f105 0410 	add.w	r4, r5, #16
 8000d42:	6033      	str	r3, [r6, #0]
 
 /* Init endpoints structures */
 for (i = 0; i < 15 ; i++)
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1;
 8000d44:	2601      	movs	r6, #1
 USB_CoreInit(hpcd->Instance, hpcd->Init);
 8000d46:	6828      	ldr	r0, [r5, #0]
 8000d48:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 8000d4c:	f001 fa83 	bl	8002256 <USB_CoreInit>
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 8000d50:	2100      	movs	r1, #0
 8000d52:	6828      	ldr	r0, [r5, #0]
 8000d54:	f001 fac0 	bl	80022d8 <USB_SetCurrentMode>
 for (i = 0; i < 15 ; i++)
 8000d58:	2100      	movs	r1, #0
 8000d5a:	462b      	mov	r3, r5
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 8000d5c:	462a      	mov	r2, r5
   hpcd->IN_ep[i].num = i;
   hpcd->IN_ep[i].tx_fifo_num = i;
   /* Control until ep is activated */
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8000d5e:	4608      	mov	r0, r1
   hpcd->IN_ep[i].num = i;
 8000d60:	f882 1034 	strb.w	r1, [r2, #52]	; 0x34
 8000d64:	321c      	adds	r2, #28
   hpcd->IN_ep[i].tx_fifo_num = i;
 8000d66:	83d1      	strh	r1, [r2, #30]
 for (i = 0; i < 15 ; i++)
 8000d68:	3101      	adds	r1, #1
   hpcd->IN_ep[i].is_in = 1;
 8000d6a:	7656      	strb	r6, [r2, #25]
 for (i = 0; i < 15 ; i++)
 8000d6c:	290f      	cmp	r1, #15
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8000d6e:	76d0      	strb	r0, [r2, #27]
   hpcd->IN_ep[i].maxpacket =  0;
 8000d70:	6210      	str	r0, [r2, #32]
   hpcd->IN_ep[i].xfer_buff = 0;
 8000d72:	6250      	str	r0, [r2, #36]	; 0x24
   hpcd->IN_ep[i].xfer_len = 0;
 8000d74:	62d0      	str	r0, [r2, #44]	; 0x2c
 for (i = 0; i < 15 ; i++)
 8000d76:	d1f3      	bne.n	8000d60 <HAL_PCD_Init+0x4e>
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   hpcd->OUT_ep[i].maxpacket = 0;
   hpcd->OUT_ep[i].xfer_buff = 0;
   hpcd->OUT_ep[i].xfer_len = 0;
   
   hpcd->Instance->DIEPTXF[i] = 0;
 8000d78:	2200      	movs	r2, #0
 8000d7a:	f8d5 e000 	ldr.w	lr, [r5]
   hpcd->OUT_ep[i].is_in = 0;
 8000d7e:	4611      	mov	r1, r2
   hpcd->OUT_ep[i].num = i;
 8000d80:	f883 21d8 	strb.w	r2, [r3, #472]	; 0x1d8
   hpcd->Instance->DIEPTXF[i] = 0;
 8000d84:	f102 0040 	add.w	r0, r2, #64	; 0x40
   hpcd->IN_ep[i].tx_fifo_num = i;
 8000d88:	875a      	strh	r2, [r3, #58]	; 0x3a
 for (i = 0; i < 15 ; i++)
 8000d8a:	3201      	adds	r2, #1
   hpcd->Instance->DIEPTXF[i] = 0;
 8000d8c:	eb0e 0080 	add.w	r0, lr, r0, lsl #2
   hpcd->OUT_ep[i].is_in = 0;
 8000d90:	f883 11d9 	strb.w	r1, [r3, #473]	; 0x1d9
 for (i = 0; i < 15 ; i++)
 8000d94:	2a0f      	cmp	r2, #15
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8000d96:	f883 11db 	strb.w	r1, [r3, #475]	; 0x1db
   hpcd->OUT_ep[i].maxpacket = 0;
 8000d9a:	f8c3 11e0 	str.w	r1, [r3, #480]	; 0x1e0
 8000d9e:	f103 031c 	add.w	r3, r3, #28
   hpcd->OUT_ep[i].xfer_buff = 0;
 8000da2:	f8c3 11c8 	str.w	r1, [r3, #456]	; 0x1c8
   hpcd->OUT_ep[i].xfer_len = 0;
 8000da6:	f8c3 11d0 	str.w	r1, [r3, #464]	; 0x1d0
   hpcd->Instance->DIEPTXF[i] = 0;
 8000daa:	6041      	str	r1, [r0, #4]
 for (i = 0; i < 15 ; i++)
 8000dac:	d1e8      	bne.n	8000d80 <HAL_PCD_Init+0x6e>
 }
 
 /* Init Device */
 USB_DevInit(hpcd->Instance, hpcd->Init);
 8000dae:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000db0:	466e      	mov	r6, sp
 8000db2:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8000db4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000db6:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8000db8:	6823      	ldr	r3, [r4, #0]
 8000dba:	4670      	mov	r0, lr
 8000dbc:	6033      	str	r3, [r6, #0]
 8000dbe:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 8000dc2:	f001 faa1 	bl	8002308 <USB_DevInit>
 
 hpcd->State= HAL_PCD_STATE_READY;
 8000dc6:	2301      	movs	r3, #1
 8000dc8:	f885 337d 	strb.w	r3, [r5, #893]	; 0x37d
 
 /* Activate LPM */
 if (hpcd->Init.lpm_enable == 1)
 8000dcc:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8000dce:	2b01      	cmp	r3, #1
 8000dd0:	d102      	bne.n	8000dd8 <HAL_PCD_Init+0xc6>
 {
   HAL_PCDEx_ActivateLPM(hpcd);
 8000dd2:	4628      	mov	r0, r5
 8000dd4:	f000 f808 	bl	8000de8 <HAL_PCDEx_ActivateLPM>
 }
 
 USB_DevDisconnect (hpcd->Instance);  
 8000dd8:	6828      	ldr	r0, [r5, #0]
 8000dda:	f001 fb64 	bl	80024a6 <USB_DevDisconnect>
 return HAL_OK;
 8000dde:	2000      	movs	r0, #0
}
 8000de0:	b00b      	add	sp, #44	; 0x2c
 8000de2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_ERROR;
 8000de4:	2001      	movs	r0, #1
 8000de6:	e7fb      	b.n	8000de0 <HAL_PCD_Init+0xce>

08000de8 <HAL_PCDEx_ActivateLPM>:
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
  
  hpcd->lpm_active = ENABLE;
 8000de8:	2101      	movs	r1, #1
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 8000dea:	6802      	ldr	r2, [r0, #0]
{
 8000dec:	4603      	mov	r3, r0
  hpcd->lpm_active = ENABLE;
 8000dee:	f8c0 13b8 	str.w	r1, [r0, #952]	; 0x3b8
  hpcd->LPM_State = LPM_L0;
 8000df2:	2000      	movs	r0, #0
 8000df4:	f883 03b0 	strb.w	r0, [r3, #944]	; 0x3b0
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 8000df8:	6993      	ldr	r3, [r2, #24]
 8000dfa:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8000dfe:	6193      	str	r3, [r2, #24]
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 8000e00:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8000e02:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8000e06:	f043 0303 	orr.w	r3, r3, #3
 8000e0a:	6553      	str	r3, [r2, #84]	; 0x54
  
  return HAL_OK;  
}
 8000e0c:	4770      	bx	lr
	...

08000e10 <HAL_PWREx_EnableOverDrive>:
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 8000e10:	4b19      	ldr	r3, [pc, #100]	; (8000e78 <HAL_PWREx_EnableOverDrive+0x68>)
{
 8000e12:	b537      	push	{r0, r1, r2, r4, r5, lr}
  __HAL_RCC_PWR_CLK_ENABLE();
 8000e14:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 8000e16:	4c19      	ldr	r4, [pc, #100]	; (8000e7c <HAL_PWREx_EnableOverDrive+0x6c>)
  __HAL_RCC_PWR_CLK_ENABLE();
 8000e18:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000e1c:	641a      	str	r2, [r3, #64]	; 0x40
 8000e1e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000e20:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000e24:	9301      	str	r3, [sp, #4]
 8000e26:	9b01      	ldr	r3, [sp, #4]
  __HAL_PWR_OVERDRIVE_ENABLE();
 8000e28:	6823      	ldr	r3, [r4, #0]
 8000e2a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000e2e:	6023      	str	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8000e30:	f7ff fa4e 	bl	80002d0 <HAL_GetTick>
 8000e34:	4605      	mov	r5, r0

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8000e36:	6863      	ldr	r3, [r4, #4]
 8000e38:	03da      	lsls	r2, r3, #15
 8000e3a:	d50c      	bpl.n	8000e56 <HAL_PWREx_EnableOverDrive+0x46>
      return HAL_TIMEOUT;
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 8000e3c:	6823      	ldr	r3, [r4, #0]
 8000e3e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000e42:	6023      	str	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8000e44:	f7ff fa44 	bl	80002d0 <HAL_GetTick>

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8000e48:	4c0c      	ldr	r4, [pc, #48]	; (8000e7c <HAL_PWREx_EnableOverDrive+0x6c>)
  tickstart = HAL_GetTick();
 8000e4a:	4605      	mov	r5, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8000e4c:	6863      	ldr	r3, [r4, #4]
 8000e4e:	039b      	lsls	r3, r3, #14
 8000e50:	d50a      	bpl.n	8000e68 <HAL_PWREx_EnableOverDrive+0x58>
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
 8000e52:	2000      	movs	r0, #0
 8000e54:	e006      	b.n	8000e64 <HAL_PWREx_EnableOverDrive+0x54>
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8000e56:	f7ff fa3b 	bl	80002d0 <HAL_GetTick>
 8000e5a:	1b40      	subs	r0, r0, r5
 8000e5c:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8000e60:	d9e9      	bls.n	8000e36 <HAL_PWREx_EnableOverDrive+0x26>
      return HAL_TIMEOUT;
 8000e62:	2003      	movs	r0, #3
}
 8000e64:	b003      	add	sp, #12
 8000e66:	bd30      	pop	{r4, r5, pc}
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8000e68:	f7ff fa32 	bl	80002d0 <HAL_GetTick>
 8000e6c:	1b40      	subs	r0, r0, r5
 8000e6e:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8000e72:	d9eb      	bls.n	8000e4c <HAL_PWREx_EnableOverDrive+0x3c>
 8000e74:	e7f5      	b.n	8000e62 <HAL_PWREx_EnableOverDrive+0x52>
 8000e76:	bf00      	nop
 8000e78:	40023800 	.word	0x40023800
 8000e7c:	40007000 	.word	0x40007000

08000e80 <HAL_RCC_OscConfig>:
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000e80:	6803      	ldr	r3, [r0, #0]
{
 8000e82:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8000e84:	4604      	mov	r4, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000e86:	07d8      	lsls	r0, r3, #31
 8000e88:	d439      	bmi.n	8000efe <HAL_RCC_OscConfig+0x7e>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8000e8a:	6823      	ldr	r3, [r4, #0]
 8000e8c:	0799      	lsls	r1, r3, #30
 8000e8e:	f100 8089 	bmi.w	8000fa4 <HAL_RCC_OscConfig+0x124>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8000e92:	6823      	ldr	r3, [r4, #0]
 8000e94:	071e      	lsls	r6, r3, #28
 8000e96:	f100 80d7 	bmi.w	8001048 <HAL_RCC_OscConfig+0x1c8>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8000e9a:	6823      	ldr	r3, [r4, #0]
 8000e9c:	075d      	lsls	r5, r3, #29
 8000e9e:	d528      	bpl.n	8000ef2 <HAL_RCC_OscConfig+0x72>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8000ea0:	4b96      	ldr	r3, [pc, #600]	; (80010fc <HAL_RCC_OscConfig+0x27c>)
    
    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 8000ea2:	4d97      	ldr	r5, [pc, #604]	; (8001100 <HAL_RCC_OscConfig+0x280>)
    __HAL_RCC_PWR_CLK_ENABLE();
 8000ea4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000ea6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000eaa:	641a      	str	r2, [r3, #64]	; 0x40
 8000eac:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000eae:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000eb2:	9301      	str	r3, [sp, #4]
 8000eb4:	9b01      	ldr	r3, [sp, #4]
    PWR->CR1 |= PWR_CR1_DBP;
 8000eb6:	682b      	ldr	r3, [r5, #0]
 8000eb8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000ebc:	602b      	str	r3, [r5, #0]
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8000ebe:	f7ff fa07 	bl	80002d0 <HAL_GetTick>
 8000ec2:	4606      	mov	r6, r0
    
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8000ec4:	682b      	ldr	r3, [r5, #0]
 8000ec6:	05da      	lsls	r2, r3, #23
 8000ec8:	f140 80e3 	bpl.w	8001092 <HAL_RCC_OscConfig+0x212>
        return HAL_TIMEOUT;
      }      
    }
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000ecc:	68a3      	ldr	r3, [r4, #8]
 8000ece:	4d8b      	ldr	r5, [pc, #556]	; (80010fc <HAL_RCC_OscConfig+0x27c>)
 8000ed0:	2b01      	cmp	r3, #1
 8000ed2:	f040 80e5 	bne.w	80010a0 <HAL_RCC_OscConfig+0x220>
 8000ed6:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8000ed8:	f043 0301 	orr.w	r3, r3, #1
 8000edc:	672b      	str	r3, [r5, #112]	; 0x70
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000ede:	f241 3588 	movw	r5, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8000ee2:	f7ff f9f5 	bl	80002d0 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000ee6:	4e85      	ldr	r6, [pc, #532]	; (80010fc <HAL_RCC_OscConfig+0x27c>)
      tickstart = HAL_GetTick();
 8000ee8:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000eea:	6f33      	ldr	r3, [r6, #112]	; 0x70
 8000eec:	079b      	lsls	r3, r3, #30
 8000eee:	f140 80fd 	bpl.w	80010ec <HAL_RCC_OscConfig+0x26c>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8000ef2:	69a2      	ldr	r2, [r4, #24]
 8000ef4:	2a00      	cmp	r2, #0
 8000ef6:	f040 8105 	bne.w	8001104 <HAL_RCC_OscConfig+0x284>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8000efa:	2000      	movs	r0, #0
 8000efc:	e015      	b.n	8000f2a <HAL_RCC_OscConfig+0xaa>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 8000efe:	4b7f      	ldr	r3, [pc, #508]	; (80010fc <HAL_RCC_OscConfig+0x27c>)
 8000f00:	689a      	ldr	r2, [r3, #8]
 8000f02:	f002 020c 	and.w	r2, r2, #12
 8000f06:	2a04      	cmp	r2, #4
 8000f08:	d007      	beq.n	8000f1a <HAL_RCC_OscConfig+0x9a>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8000f0a:	689a      	ldr	r2, [r3, #8]
 8000f0c:	f002 020c 	and.w	r2, r2, #12
 8000f10:	2a08      	cmp	r2, #8
 8000f12:	d10c      	bne.n	8000f2e <HAL_RCC_OscConfig+0xae>
 8000f14:	685b      	ldr	r3, [r3, #4]
 8000f16:	025a      	lsls	r2, r3, #9
 8000f18:	d509      	bpl.n	8000f2e <HAL_RCC_OscConfig+0xae>
	  if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8000f1a:	4b78      	ldr	r3, [pc, #480]	; (80010fc <HAL_RCC_OscConfig+0x27c>)
 8000f1c:	681b      	ldr	r3, [r3, #0]
 8000f1e:	039b      	lsls	r3, r3, #14
 8000f20:	d5b3      	bpl.n	8000e8a <HAL_RCC_OscConfig+0xa>
 8000f22:	6863      	ldr	r3, [r4, #4]
 8000f24:	2b00      	cmp	r3, #0
 8000f26:	d1b0      	bne.n	8000e8a <HAL_RCC_OscConfig+0xa>
        return HAL_ERROR;
 8000f28:	2001      	movs	r0, #1
}
 8000f2a:	b003      	add	sp, #12
 8000f2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000f2e:	6863      	ldr	r3, [r4, #4]
 8000f30:	4d72      	ldr	r5, [pc, #456]	; (80010fc <HAL_RCC_OscConfig+0x27c>)
 8000f32:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8000f36:	d111      	bne.n	8000f5c <HAL_RCC_OscConfig+0xdc>
 8000f38:	682b      	ldr	r3, [r5, #0]
 8000f3a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000f3e:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000f40:	f7ff f9c6 	bl	80002d0 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000f44:	4d6d      	ldr	r5, [pc, #436]	; (80010fc <HAL_RCC_OscConfig+0x27c>)
        tickstart = HAL_GetTick();
 8000f46:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000f48:	682b      	ldr	r3, [r5, #0]
 8000f4a:	039f      	lsls	r7, r3, #14
 8000f4c:	d49d      	bmi.n	8000e8a <HAL_RCC_OscConfig+0xa>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000f4e:	f7ff f9bf 	bl	80002d0 <HAL_GetTick>
 8000f52:	1b80      	subs	r0, r0, r6
 8000f54:	2864      	cmp	r0, #100	; 0x64
 8000f56:	d9f7      	bls.n	8000f48 <HAL_RCC_OscConfig+0xc8>
            return HAL_TIMEOUT;
 8000f58:	2003      	movs	r0, #3
 8000f5a:	e7e6      	b.n	8000f2a <HAL_RCC_OscConfig+0xaa>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000f5c:	b99b      	cbnz	r3, 8000f86 <HAL_RCC_OscConfig+0x106>
 8000f5e:	682b      	ldr	r3, [r5, #0]
 8000f60:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000f64:	602b      	str	r3, [r5, #0]
 8000f66:	682b      	ldr	r3, [r5, #0]
 8000f68:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000f6c:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000f6e:	f7ff f9af 	bl	80002d0 <HAL_GetTick>
 8000f72:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000f74:	682b      	ldr	r3, [r5, #0]
 8000f76:	0398      	lsls	r0, r3, #14
 8000f78:	d587      	bpl.n	8000e8a <HAL_RCC_OscConfig+0xa>
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000f7a:	f7ff f9a9 	bl	80002d0 <HAL_GetTick>
 8000f7e:	1b80      	subs	r0, r0, r6
 8000f80:	2864      	cmp	r0, #100	; 0x64
 8000f82:	d9f7      	bls.n	8000f74 <HAL_RCC_OscConfig+0xf4>
 8000f84:	e7e8      	b.n	8000f58 <HAL_RCC_OscConfig+0xd8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000f86:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8000f8a:	682b      	ldr	r3, [r5, #0]
 8000f8c:	d103      	bne.n	8000f96 <HAL_RCC_OscConfig+0x116>
 8000f8e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000f92:	602b      	str	r3, [r5, #0]
 8000f94:	e7d0      	b.n	8000f38 <HAL_RCC_OscConfig+0xb8>
 8000f96:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000f9a:	602b      	str	r3, [r5, #0]
 8000f9c:	682b      	ldr	r3, [r5, #0]
 8000f9e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000fa2:	e7cc      	b.n	8000f3e <HAL_RCC_OscConfig+0xbe>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 8000fa4:	4b55      	ldr	r3, [pc, #340]	; (80010fc <HAL_RCC_OscConfig+0x27c>)
 8000fa6:	689a      	ldr	r2, [r3, #8]
 8000fa8:	f012 0f0c 	tst.w	r2, #12
 8000fac:	d007      	beq.n	8000fbe <HAL_RCC_OscConfig+0x13e>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8000fae:	689a      	ldr	r2, [r3, #8]
 8000fb0:	f002 020c 	and.w	r2, r2, #12
 8000fb4:	2a08      	cmp	r2, #8
 8000fb6:	d116      	bne.n	8000fe6 <HAL_RCC_OscConfig+0x166>
 8000fb8:	685b      	ldr	r3, [r3, #4]
 8000fba:	0259      	lsls	r1, r3, #9
 8000fbc:	d413      	bmi.n	8000fe6 <HAL_RCC_OscConfig+0x166>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8000fbe:	4b4f      	ldr	r3, [pc, #316]	; (80010fc <HAL_RCC_OscConfig+0x27c>)
 8000fc0:	681a      	ldr	r2, [r3, #0]
 8000fc2:	0792      	lsls	r2, r2, #30
 8000fc4:	d502      	bpl.n	8000fcc <HAL_RCC_OscConfig+0x14c>
 8000fc6:	68e2      	ldr	r2, [r4, #12]
 8000fc8:	2a01      	cmp	r2, #1
 8000fca:	d1ad      	bne.n	8000f28 <HAL_RCC_OscConfig+0xa8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000fcc:	6818      	ldr	r0, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8000fce:	22f8      	movs	r2, #248	; 0xf8
 8000fd0:	fa92 f2a2 	rbit	r2, r2
 8000fd4:	fab2 f182 	clz	r1, r2
 8000fd8:	6922      	ldr	r2, [r4, #16]
 8000fda:	408a      	lsls	r2, r1
 8000fdc:	f020 01f8 	bic.w	r1, r0, #248	; 0xf8
 8000fe0:	430a      	orrs	r2, r1
 8000fe2:	601a      	str	r2, [r3, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8000fe4:	e755      	b.n	8000e92 <HAL_RCC_OscConfig+0x12>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8000fe6:	68e3      	ldr	r3, [r4, #12]
 8000fe8:	4d44      	ldr	r5, [pc, #272]	; (80010fc <HAL_RCC_OscConfig+0x27c>)
 8000fea:	b1e3      	cbz	r3, 8001026 <HAL_RCC_OscConfig+0x1a6>
        __HAL_RCC_HSI_ENABLE();
 8000fec:	682b      	ldr	r3, [r5, #0]
 8000fee:	f043 0301 	orr.w	r3, r3, #1
 8000ff2:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000ff4:	f7ff f96c 	bl	80002d0 <HAL_GetTick>
 8000ff8:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000ffa:	682b      	ldr	r3, [r5, #0]
 8000ffc:	079b      	lsls	r3, r3, #30
 8000ffe:	d50c      	bpl.n	800101a <HAL_RCC_OscConfig+0x19a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001000:	6829      	ldr	r1, [r5, #0]
 8001002:	23f8      	movs	r3, #248	; 0xf8
 8001004:	fa93 f3a3 	rbit	r3, r3
 8001008:	fab3 f283 	clz	r2, r3
 800100c:	6923      	ldr	r3, [r4, #16]
 800100e:	4093      	lsls	r3, r2
 8001010:	f021 02f8 	bic.w	r2, r1, #248	; 0xf8
 8001014:	4313      	orrs	r3, r2
 8001016:	602b      	str	r3, [r5, #0]
 8001018:	e73b      	b.n	8000e92 <HAL_RCC_OscConfig+0x12>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800101a:	f7ff f959 	bl	80002d0 <HAL_GetTick>
 800101e:	1b80      	subs	r0, r0, r6
 8001020:	2802      	cmp	r0, #2
 8001022:	d9ea      	bls.n	8000ffa <HAL_RCC_OscConfig+0x17a>
 8001024:	e798      	b.n	8000f58 <HAL_RCC_OscConfig+0xd8>
        __HAL_RCC_HSI_DISABLE();
 8001026:	682b      	ldr	r3, [r5, #0]
 8001028:	f023 0301 	bic.w	r3, r3, #1
 800102c:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800102e:	f7ff f94f 	bl	80002d0 <HAL_GetTick>
 8001032:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001034:	682b      	ldr	r3, [r5, #0]
 8001036:	079f      	lsls	r7, r3, #30
 8001038:	f57f af2b 	bpl.w	8000e92 <HAL_RCC_OscConfig+0x12>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800103c:	f7ff f948 	bl	80002d0 <HAL_GetTick>
 8001040:	1b80      	subs	r0, r0, r6
 8001042:	2802      	cmp	r0, #2
 8001044:	d9f6      	bls.n	8001034 <HAL_RCC_OscConfig+0x1b4>
 8001046:	e787      	b.n	8000f58 <HAL_RCC_OscConfig+0xd8>
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8001048:	6963      	ldr	r3, [r4, #20]
 800104a:	4d2c      	ldr	r5, [pc, #176]	; (80010fc <HAL_RCC_OscConfig+0x27c>)
 800104c:	b183      	cbz	r3, 8001070 <HAL_RCC_OscConfig+0x1f0>
      __HAL_RCC_LSI_ENABLE();
 800104e:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8001050:	f043 0301 	orr.w	r3, r3, #1
 8001054:	676b      	str	r3, [r5, #116]	; 0x74
      tickstart = HAL_GetTick();
 8001056:	f7ff f93b 	bl	80002d0 <HAL_GetTick>
 800105a:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800105c:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800105e:	0798      	lsls	r0, r3, #30
 8001060:	f53f af1b 	bmi.w	8000e9a <HAL_RCC_OscConfig+0x1a>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001064:	f7ff f934 	bl	80002d0 <HAL_GetTick>
 8001068:	1b80      	subs	r0, r0, r6
 800106a:	2802      	cmp	r0, #2
 800106c:	d9f6      	bls.n	800105c <HAL_RCC_OscConfig+0x1dc>
 800106e:	e773      	b.n	8000f58 <HAL_RCC_OscConfig+0xd8>
      __HAL_RCC_LSI_DISABLE();
 8001070:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8001072:	f023 0301 	bic.w	r3, r3, #1
 8001076:	676b      	str	r3, [r5, #116]	; 0x74
      tickstart = HAL_GetTick();
 8001078:	f7ff f92a 	bl	80002d0 <HAL_GetTick>
 800107c:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800107e:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8001080:	0799      	lsls	r1, r3, #30
 8001082:	f57f af0a 	bpl.w	8000e9a <HAL_RCC_OscConfig+0x1a>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001086:	f7ff f923 	bl	80002d0 <HAL_GetTick>
 800108a:	1b80      	subs	r0, r0, r6
 800108c:	2802      	cmp	r0, #2
 800108e:	d9f6      	bls.n	800107e <HAL_RCC_OscConfig+0x1fe>
 8001090:	e762      	b.n	8000f58 <HAL_RCC_OscConfig+0xd8>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8001092:	f7ff f91d 	bl	80002d0 <HAL_GetTick>
 8001096:	1b80      	subs	r0, r0, r6
 8001098:	2864      	cmp	r0, #100	; 0x64
 800109a:	f67f af13 	bls.w	8000ec4 <HAL_RCC_OscConfig+0x44>
 800109e:	e75b      	b.n	8000f58 <HAL_RCC_OscConfig+0xd8>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80010a0:	b9b3      	cbnz	r3, 80010d0 <HAL_RCC_OscConfig+0x250>
 80010a2:	6f2b      	ldr	r3, [r5, #112]	; 0x70
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80010a4:	f241 3788 	movw	r7, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80010a8:	f023 0301 	bic.w	r3, r3, #1
 80010ac:	672b      	str	r3, [r5, #112]	; 0x70
 80010ae:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80010b0:	f023 0304 	bic.w	r3, r3, #4
 80010b4:	672b      	str	r3, [r5, #112]	; 0x70
      tickstart = HAL_GetTick();
 80010b6:	f7ff f90b 	bl	80002d0 <HAL_GetTick>
 80010ba:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80010bc:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80010be:	0798      	lsls	r0, r3, #30
 80010c0:	f57f af17 	bpl.w	8000ef2 <HAL_RCC_OscConfig+0x72>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80010c4:	f7ff f904 	bl	80002d0 <HAL_GetTick>
 80010c8:	1b80      	subs	r0, r0, r6
 80010ca:	42b8      	cmp	r0, r7
 80010cc:	d9f6      	bls.n	80010bc <HAL_RCC_OscConfig+0x23c>
 80010ce:	e743      	b.n	8000f58 <HAL_RCC_OscConfig+0xd8>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80010d0:	2b05      	cmp	r3, #5
 80010d2:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80010d4:	d103      	bne.n	80010de <HAL_RCC_OscConfig+0x25e>
 80010d6:	f043 0304 	orr.w	r3, r3, #4
 80010da:	672b      	str	r3, [r5, #112]	; 0x70
 80010dc:	e6fb      	b.n	8000ed6 <HAL_RCC_OscConfig+0x56>
 80010de:	f023 0301 	bic.w	r3, r3, #1
 80010e2:	672b      	str	r3, [r5, #112]	; 0x70
 80010e4:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80010e6:	f023 0304 	bic.w	r3, r3, #4
 80010ea:	e6f7      	b.n	8000edc <HAL_RCC_OscConfig+0x5c>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80010ec:	f7ff f8f0 	bl	80002d0 <HAL_GetTick>
 80010f0:	1bc0      	subs	r0, r0, r7
 80010f2:	42a8      	cmp	r0, r5
 80010f4:	f67f aef9 	bls.w	8000eea <HAL_RCC_OscConfig+0x6a>
 80010f8:	e72e      	b.n	8000f58 <HAL_RCC_OscConfig+0xd8>
 80010fa:	bf00      	nop
 80010fc:	40023800 	.word	0x40023800
 8001100:	40007000 	.word	0x40007000
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8001104:	4d2d      	ldr	r5, [pc, #180]	; (80011bc <HAL_RCC_OscConfig+0x33c>)
 8001106:	68ab      	ldr	r3, [r5, #8]
 8001108:	f003 030c 	and.w	r3, r3, #12
 800110c:	2b08      	cmp	r3, #8
 800110e:	f43f af0b 	beq.w	8000f28 <HAL_RCC_OscConfig+0xa8>
        __HAL_RCC_PLL_DISABLE();
 8001112:	682b      	ldr	r3, [r5, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001114:	2a02      	cmp	r2, #2
        __HAL_RCC_PLL_DISABLE();
 8001116:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800111a:	602b      	str	r3, [r5, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800111c:	d140      	bne.n	80011a0 <HAL_RCC_OscConfig+0x320>
        tickstart = HAL_GetTick();
 800111e:	f7ff f8d7 	bl	80002d0 <HAL_GetTick>
 8001122:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001124:	682b      	ldr	r3, [r5, #0]
 8001126:	0199      	lsls	r1, r3, #6
 8001128:	d434      	bmi.n	8001194 <HAL_RCC_OscConfig+0x314>
 800112a:	f647 76c0 	movw	r6, #32704	; 0x7fc0
 800112e:	fa96 f6a6 	rbit	r6, r6
 8001132:	f44f 3240 	mov.w	r2, #196608	; 0x30000
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8001136:	fab6 f686 	clz	r6, r6
 800113a:	fa92 f2a2 	rbit	r2, r2
 800113e:	f04f 6170 	mov.w	r1, #251658240	; 0xf000000
 8001142:	fab2 f082 	clz	r0, r2
 8001146:	fa91 f1a1 	rbit	r1, r1
 800114a:	6a22      	ldr	r2, [r4, #32]
 800114c:	fab1 f181 	clz	r1, r1
 8001150:	69e3      	ldr	r3, [r4, #28]
 8001152:	4313      	orrs	r3, r2
 8001154:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001156:	fa02 f606 	lsl.w	r6, r2, r6
 800115a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800115c:	0852      	lsrs	r2, r2, #1
 800115e:	4333      	orrs	r3, r6
 8001160:	3a01      	subs	r2, #1
 8001162:	4082      	lsls	r2, r0
 8001164:	4313      	orrs	r3, r2
 8001166:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001168:	4c14      	ldr	r4, [pc, #80]	; (80011bc <HAL_RCC_OscConfig+0x33c>)
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 800116a:	fa02 f101 	lsl.w	r1, r2, r1
 800116e:	430b      	orrs	r3, r1
 8001170:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8001172:	682b      	ldr	r3, [r5, #0]
 8001174:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001178:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800117a:	f7ff f8a9 	bl	80002d0 <HAL_GetTick>
 800117e:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001180:	6823      	ldr	r3, [r4, #0]
 8001182:	019a      	lsls	r2, r3, #6
 8001184:	f53f aeb9 	bmi.w	8000efa <HAL_RCC_OscConfig+0x7a>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001188:	f7ff f8a2 	bl	80002d0 <HAL_GetTick>
 800118c:	1b40      	subs	r0, r0, r5
 800118e:	2802      	cmp	r0, #2
 8001190:	d9f6      	bls.n	8001180 <HAL_RCC_OscConfig+0x300>
 8001192:	e6e1      	b.n	8000f58 <HAL_RCC_OscConfig+0xd8>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001194:	f7ff f89c 	bl	80002d0 <HAL_GetTick>
 8001198:	1b80      	subs	r0, r0, r6
 800119a:	2802      	cmp	r0, #2
 800119c:	d9c2      	bls.n	8001124 <HAL_RCC_OscConfig+0x2a4>
 800119e:	e6db      	b.n	8000f58 <HAL_RCC_OscConfig+0xd8>
        tickstart = HAL_GetTick();
 80011a0:	f7ff f896 	bl	80002d0 <HAL_GetTick>
 80011a4:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80011a6:	682b      	ldr	r3, [r5, #0]
 80011a8:	019b      	lsls	r3, r3, #6
 80011aa:	f57f aea6 	bpl.w	8000efa <HAL_RCC_OscConfig+0x7a>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80011ae:	f7ff f88f 	bl	80002d0 <HAL_GetTick>
 80011b2:	1b00      	subs	r0, r0, r4
 80011b4:	2802      	cmp	r0, #2
 80011b6:	d9f6      	bls.n	80011a6 <HAL_RCC_OscConfig+0x326>
 80011b8:	e6ce      	b.n	8000f58 <HAL_RCC_OscConfig+0xd8>
 80011ba:	bf00      	nop
 80011bc:	40023800 	.word	0x40023800

080011c0 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80011c0:	4a19      	ldr	r2, [pc, #100]	; (8001228 <HAL_RCC_GetSysClockFreq+0x68>)
 80011c2:	6893      	ldr	r3, [r2, #8]
 80011c4:	f003 030c 	and.w	r3, r3, #12
 80011c8:	2b04      	cmp	r3, #4
{
 80011ca:	b510      	push	{r4, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80011cc:	d003      	beq.n	80011d6 <HAL_RCC_GetSysClockFreq+0x16>
 80011ce:	2b08      	cmp	r3, #8
 80011d0:	d003      	beq.n	80011da <HAL_RCC_GetSysClockFreq+0x1a>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 80011d2:	4816      	ldr	r0, [pc, #88]	; (800122c <HAL_RCC_GetSysClockFreq+0x6c>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 80011d4:	bd10      	pop	{r4, pc}
      sysclockfreq = HSE_VALUE;
 80011d6:	4816      	ldr	r0, [pc, #88]	; (8001230 <HAL_RCC_GetSysClockFreq+0x70>)
 80011d8:	bd10      	pop	{r4, pc}
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80011da:	6851      	ldr	r1, [r2, #4]
 80011dc:	f647 74c0 	movw	r4, #32704	; 0x7fc0
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 80011e0:	6853      	ldr	r3, [r2, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80011e2:	f001 013f 	and.w	r1, r1, #63	; 0x3f
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 80011e6:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 80011ea:	6853      	ldr	r3, [r2, #4]
 80011ec:	fa94 f0a4 	rbit	r0, r4
 80011f0:	fab0 f080 	clz	r0, r0
 80011f4:	ea03 0304 	and.w	r3, r3, r4
 80011f8:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 80011fc:	fa23 f300 	lsr.w	r3, r3, r0
 8001200:	bf14      	ite	ne
 8001202:	480b      	ldrne	r0, [pc, #44]	; (8001230 <HAL_RCC_GetSysClockFreq+0x70>)
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8001204:	4809      	ldreq	r0, [pc, #36]	; (800122c <HAL_RCC_GetSysClockFreq+0x6c>)
 8001206:	fbb0 f0f1 	udiv	r0, r0, r1
 800120a:	4358      	muls	r0, r3
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
 800120c:	4b06      	ldr	r3, [pc, #24]	; (8001228 <HAL_RCC_GetSysClockFreq+0x68>)
 800120e:	685b      	ldr	r3, [r3, #4]
 8001210:	fa92 f2a2 	rbit	r2, r2
 8001214:	fab2 f282 	clz	r2, r2
 8001218:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 800121c:	40d3      	lsrs	r3, r2
 800121e:	3301      	adds	r3, #1
 8001220:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco/pllp;
 8001222:	fbb0 f0f3 	udiv	r0, r0, r3
 8001226:	bd10      	pop	{r4, pc}
 8001228:	40023800 	.word	0x40023800
 800122c:	00f42400 	.word	0x00f42400
 8001230:	007a1200 	.word	0x007a1200

08001234 <HAL_RCC_ClockConfig>:
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001234:	4a51      	ldr	r2, [pc, #324]	; (800137c <HAL_RCC_ClockConfig+0x148>)
 8001236:	6813      	ldr	r3, [r2, #0]
 8001238:	f003 030f 	and.w	r3, r3, #15
 800123c:	428b      	cmp	r3, r1
{
 800123e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001242:	4604      	mov	r4, r0
 8001244:	460d      	mov	r5, r1
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001246:	d32f      	bcc.n	80012a8 <HAL_RCC_ClockConfig+0x74>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001248:	6822      	ldr	r2, [r4, #0]
 800124a:	0796      	lsls	r6, r2, #30
 800124c:	d439      	bmi.n	80012c2 <HAL_RCC_ClockConfig+0x8e>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800124e:	07d0      	lsls	r0, r2, #31
 8001250:	d43f      	bmi.n	80012d2 <HAL_RCC_ClockConfig+0x9e>
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 8001252:	4a4a      	ldr	r2, [pc, #296]	; (800137c <HAL_RCC_ClockConfig+0x148>)
 8001254:	6813      	ldr	r3, [r2, #0]
 8001256:	f003 030f 	and.w	r3, r3, #15
 800125a:	429d      	cmp	r5, r3
 800125c:	d37b      	bcc.n	8001356 <HAL_RCC_ClockConfig+0x122>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800125e:	6822      	ldr	r2, [r4, #0]
 8001260:	0751      	lsls	r1, r2, #29
 8001262:	f100 8083 	bmi.w	800136c <HAL_RCC_ClockConfig+0x138>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001266:	0713      	lsls	r3, r2, #28
 8001268:	d507      	bpl.n	800127a <HAL_RCC_ClockConfig+0x46>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 800126a:	4a45      	ldr	r2, [pc, #276]	; (8001380 <HAL_RCC_ClockConfig+0x14c>)
 800126c:	6921      	ldr	r1, [r4, #16]
 800126e:	6893      	ldr	r3, [r2, #8]
 8001270:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8001274:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001278:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 800127a:	f7ff ffa1 	bl	80011c0 <HAL_RCC_GetSysClockFreq>
 800127e:	4b40      	ldr	r3, [pc, #256]	; (8001380 <HAL_RCC_ClockConfig+0x14c>)
 8001280:	22f0      	movs	r2, #240	; 0xf0
 8001282:	689b      	ldr	r3, [r3, #8]
 8001284:	fa92 f2a2 	rbit	r2, r2
 8001288:	fab2 f282 	clz	r2, r2
 800128c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8001290:	40d3      	lsrs	r3, r2
 8001292:	4a3c      	ldr	r2, [pc, #240]	; (8001384 <HAL_RCC_ClockConfig+0x150>)
 8001294:	5cd3      	ldrb	r3, [r2, r3]
 8001296:	40d8      	lsrs	r0, r3
 8001298:	4b3b      	ldr	r3, [pc, #236]	; (8001388 <HAL_RCC_ClockConfig+0x154>)
 800129a:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 800129c:	2000      	movs	r0, #0
 800129e:	f008 fb8f 	bl	80099c0 <HAL_InitTick>
  return HAL_OK;
 80012a2:	2000      	movs	r0, #0
}
 80012a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_FLASH_SET_LATENCY(FLatency);
 80012a8:	6813      	ldr	r3, [r2, #0]
 80012aa:	f023 030f 	bic.w	r3, r3, #15
 80012ae:	430b      	orrs	r3, r1
 80012b0:	6013      	str	r3, [r2, #0]
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80012b2:	6813      	ldr	r3, [r2, #0]
 80012b4:	f003 030f 	and.w	r3, r3, #15
 80012b8:	4299      	cmp	r1, r3
 80012ba:	d0c5      	beq.n	8001248 <HAL_RCC_ClockConfig+0x14>
      return HAL_ERROR;
 80012bc:	2001      	movs	r0, #1
 80012be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80012c2:	492f      	ldr	r1, [pc, #188]	; (8001380 <HAL_RCC_ClockConfig+0x14c>)
 80012c4:	68a0      	ldr	r0, [r4, #8]
 80012c6:	688b      	ldr	r3, [r1, #8]
 80012c8:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80012cc:	4303      	orrs	r3, r0
 80012ce:	608b      	str	r3, [r1, #8]
 80012d0:	e7bd      	b.n	800124e <HAL_RCC_ClockConfig+0x1a>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80012d2:	6861      	ldr	r1, [r4, #4]
 80012d4:	4b2a      	ldr	r3, [pc, #168]	; (8001380 <HAL_RCC_ClockConfig+0x14c>)
 80012d6:	2901      	cmp	r1, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80012d8:	681a      	ldr	r2, [r3, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80012da:	d11d      	bne.n	8001318 <HAL_RCC_ClockConfig+0xe4>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80012dc:	f412 3f00 	tst.w	r2, #131072	; 0x20000
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80012e0:	d0ec      	beq.n	80012bc <HAL_RCC_ClockConfig+0x88>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80012e2:	689a      	ldr	r2, [r3, #8]
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80012e4:	f241 3888 	movw	r8, #5000	; 0x1388
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 80012e8:	4f25      	ldr	r7, [pc, #148]	; (8001380 <HAL_RCC_ClockConfig+0x14c>)
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80012ea:	f022 0203 	bic.w	r2, r2, #3
 80012ee:	430a      	orrs	r2, r1
 80012f0:	609a      	str	r2, [r3, #8]
    tickstart = HAL_GetTick();
 80012f2:	f7fe ffed 	bl	80002d0 <HAL_GetTick>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80012f6:	6863      	ldr	r3, [r4, #4]
    tickstart = HAL_GetTick();
 80012f8:	4606      	mov	r6, r0
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80012fa:	2b01      	cmp	r3, #1
 80012fc:	d114      	bne.n	8001328 <HAL_RCC_ClockConfig+0xf4>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 80012fe:	68bb      	ldr	r3, [r7, #8]
 8001300:	f003 030c 	and.w	r3, r3, #12
 8001304:	2b04      	cmp	r3, #4
 8001306:	d0a4      	beq.n	8001252 <HAL_RCC_ClockConfig+0x1e>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001308:	f7fe ffe2 	bl	80002d0 <HAL_GetTick>
 800130c:	1b80      	subs	r0, r0, r6
 800130e:	4540      	cmp	r0, r8
 8001310:	d9f5      	bls.n	80012fe <HAL_RCC_ClockConfig+0xca>
          return HAL_TIMEOUT;
 8001312:	2003      	movs	r0, #3
 8001314:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001318:	2902      	cmp	r1, #2
 800131a:	d102      	bne.n	8001322 <HAL_RCC_ClockConfig+0xee>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800131c:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8001320:	e7de      	b.n	80012e0 <HAL_RCC_ClockConfig+0xac>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001322:	f012 0f02 	tst.w	r2, #2
 8001326:	e7db      	b.n	80012e0 <HAL_RCC_ClockConfig+0xac>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001328:	2b02      	cmp	r3, #2
 800132a:	d10f      	bne.n	800134c <HAL_RCC_ClockConfig+0x118>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800132c:	68bb      	ldr	r3, [r7, #8]
 800132e:	f003 030c 	and.w	r3, r3, #12
 8001332:	2b08      	cmp	r3, #8
 8001334:	d08d      	beq.n	8001252 <HAL_RCC_ClockConfig+0x1e>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001336:	f7fe ffcb 	bl	80002d0 <HAL_GetTick>
 800133a:	1b80      	subs	r0, r0, r6
 800133c:	4540      	cmp	r0, r8
 800133e:	d9f5      	bls.n	800132c <HAL_RCC_ClockConfig+0xf8>
 8001340:	e7e7      	b.n	8001312 <HAL_RCC_ClockConfig+0xde>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001342:	f7fe ffc5 	bl	80002d0 <HAL_GetTick>
 8001346:	1b80      	subs	r0, r0, r6
 8001348:	4540      	cmp	r0, r8
 800134a:	d8e2      	bhi.n	8001312 <HAL_RCC_ClockConfig+0xde>
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800134c:	68bb      	ldr	r3, [r7, #8]
 800134e:	f013 0f0c 	tst.w	r3, #12
 8001352:	d1f6      	bne.n	8001342 <HAL_RCC_ClockConfig+0x10e>
 8001354:	e77d      	b.n	8001252 <HAL_RCC_ClockConfig+0x1e>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001356:	6813      	ldr	r3, [r2, #0]
 8001358:	f023 030f 	bic.w	r3, r3, #15
 800135c:	432b      	orrs	r3, r5
 800135e:	6013      	str	r3, [r2, #0]
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001360:	6813      	ldr	r3, [r2, #0]
 8001362:	f003 030f 	and.w	r3, r3, #15
 8001366:	429d      	cmp	r5, r3
 8001368:	d1a8      	bne.n	80012bc <HAL_RCC_ClockConfig+0x88>
 800136a:	e778      	b.n	800125e <HAL_RCC_ClockConfig+0x2a>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800136c:	4904      	ldr	r1, [pc, #16]	; (8001380 <HAL_RCC_ClockConfig+0x14c>)
 800136e:	68e0      	ldr	r0, [r4, #12]
 8001370:	688b      	ldr	r3, [r1, #8]
 8001372:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 8001376:	4303      	orrs	r3, r0
 8001378:	608b      	str	r3, [r1, #8]
 800137a:	e774      	b.n	8001266 <HAL_RCC_ClockConfig+0x32>
 800137c:	40023c00 	.word	0x40023c00
 8001380:	40023800 	.word	0x40023800
 8001384:	08009c40 	.word	0x08009c40
 8001388:	20000000 	.word	0x20000000

0800138c <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 800138c:	4b01      	ldr	r3, [pc, #4]	; (8001394 <HAL_RCC_GetHCLKFreq+0x8>)
 800138e:	6818      	ldr	r0, [r3, #0]
 8001390:	4770      	bx	lr
 8001392:	bf00      	nop
 8001394:	20000000 	.word	0x20000000

08001398 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{  
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 8001398:	4b08      	ldr	r3, [pc, #32]	; (80013bc <HAL_RCC_GetPCLK1Freq+0x24>)
 800139a:	f44f 52e0 	mov.w	r2, #7168	; 0x1c00
 800139e:	689b      	ldr	r3, [r3, #8]
 80013a0:	fa92 f2a2 	rbit	r2, r2
 80013a4:	fab2 f282 	clz	r2, r2
 80013a8:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 80013ac:	40d3      	lsrs	r3, r2
 80013ae:	4a04      	ldr	r2, [pc, #16]	; (80013c0 <HAL_RCC_GetPCLK1Freq+0x28>)
 80013b0:	5cd3      	ldrb	r3, [r2, r3]
 80013b2:	4a04      	ldr	r2, [pc, #16]	; (80013c4 <HAL_RCC_GetPCLK1Freq+0x2c>)
 80013b4:	6810      	ldr	r0, [r2, #0]
}
 80013b6:	40d8      	lsrs	r0, r3
 80013b8:	4770      	bx	lr
 80013ba:	bf00      	nop
 80013bc:	40023800 	.word	0x40023800
 80013c0:	08009c50 	.word	0x08009c50
 80013c4:	20000000 	.word	0x20000000

080013c8 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 80013c8:	4b08      	ldr	r3, [pc, #32]	; (80013ec <HAL_RCC_GetPCLK2Freq+0x24>)
 80013ca:	f44f 4260 	mov.w	r2, #57344	; 0xe000
 80013ce:	689b      	ldr	r3, [r3, #8]
 80013d0:	fa92 f2a2 	rbit	r2, r2
 80013d4:	fab2 f282 	clz	r2, r2
 80013d8:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 80013dc:	40d3      	lsrs	r3, r2
 80013de:	4a04      	ldr	r2, [pc, #16]	; (80013f0 <HAL_RCC_GetPCLK2Freq+0x28>)
 80013e0:	5cd3      	ldrb	r3, [r2, r3]
 80013e2:	4a04      	ldr	r2, [pc, #16]	; (80013f4 <HAL_RCC_GetPCLK2Freq+0x2c>)
 80013e4:	6810      	ldr	r0, [r2, #0]
} 
 80013e6:	40d8      	lsrs	r0, r3
 80013e8:	4770      	bx	lr
 80013ea:	bf00      	nop
 80013ec:	40023800 	.word	0x40023800
 80013f0:	08009c50 	.word	0x08009c50
 80013f4:	20000000 	.word	0x20000000

080013f8 <HAL_RCC_GetClockConfig>:
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 80013f8:	230f      	movs	r3, #15
 80013fa:	6003      	str	r3, [r0, #0]
   
  /* Get the SYSCLK configuration --------------------------------------------*/ 
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 80013fc:	4b0b      	ldr	r3, [pc, #44]	; (800142c <HAL_RCC_GetClockConfig+0x34>)
 80013fe:	689a      	ldr	r2, [r3, #8]
 8001400:	f002 0203 	and.w	r2, r2, #3
 8001404:	6042      	str	r2, [r0, #4]
  
  /* Get the HCLK configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
 8001406:	689a      	ldr	r2, [r3, #8]
 8001408:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 800140c:	6082      	str	r2, [r0, #8]
  
  /* Get the APB1 configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);   
 800140e:	689a      	ldr	r2, [r3, #8]
 8001410:	f402 52e0 	and.w	r2, r2, #7168	; 0x1c00
 8001414:	60c2      	str	r2, [r0, #12]
  
  /* Get the APB2 configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 8001416:	689b      	ldr	r3, [r3, #8]
 8001418:	08db      	lsrs	r3, r3, #3
 800141a:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 800141e:	6103      	str	r3, [r0, #16]
  
  /* Get the Flash Wait State (Latency) configuration ------------------------*/   
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
 8001420:	4b03      	ldr	r3, [pc, #12]	; (8001430 <HAL_RCC_GetClockConfig+0x38>)
 8001422:	681b      	ldr	r3, [r3, #0]
 8001424:	f003 030f 	and.w	r3, r3, #15
 8001428:	600b      	str	r3, [r1, #0]
 800142a:	4770      	bx	lr
 800142c:	40023800 	.word	0x40023800
 8001430:	40023c00 	.word	0x40023c00

08001434 <HAL_RCCEx_PeriphCLKConfig>:
    
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8001434:	6803      	ldr	r3, [r0, #0]
{
 8001436:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 800143a:	f013 0601 	ands.w	r6, r3, #1
{
 800143e:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8001440:	d00b      	beq.n	800145a <HAL_RCCEx_PeriphCLKConfig+0x26>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));
    
    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8001442:	4abd      	ldr	r2, [pc, #756]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8001444:	6891      	ldr	r1, [r2, #8]
 8001446:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
 800144a:	6091      	str	r1, [r2, #8]
 800144c:	6b46      	ldr	r6, [r0, #52]	; 0x34
 800144e:	6891      	ldr	r1, [r2, #8]
 8001450:	4331      	orrs	r1, r6
    
    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
 8001452:	fab6 f686 	clz	r6, r6
 8001456:	0976      	lsrs	r6, r6, #5
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8001458:	6091      	str	r1, [r2, #8]
      plli2sused = 1; 
    }
  }
  
  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
 800145a:	f413 2500 	ands.w	r5, r3, #524288	; 0x80000
 800145e:	d012      	beq.n	8001486 <HAL_RCCEx_PeriphCLKConfig+0x52>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));
    
    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8001460:	49b5      	ldr	r1, [pc, #724]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8001462:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 8001464:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 8001468:	f5b5 1f80 	cmp.w	r5, #1048576	; 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 800146c:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
    {
      plli2sused = 1; 
 8001470:	bf08      	it	eq
 8001472:	2601      	moveq	r6, #1
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8001474:	ea42 0205 	orr.w	r2, r2, r5
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 8001478:	bf16      	itet	ne
 800147a:	fab5 f585 	clzne	r5, r5
  uint32_t pllsaiused = 0;
 800147e:	2500      	moveq	r5, #0
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 8001480:	096d      	lsrne	r5, r5, #5
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8001482:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
      pllsaiused = 1; 
    }
  }
  
  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
 8001486:	02d9      	lsls	r1, r3, #11
 8001488:	d510      	bpl.n	80014ac <HAL_RCCEx_PeriphCLKConfig+0x78>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));
    
    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 800148a:	48ab      	ldr	r0, [pc, #684]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 800148c:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800148e:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
    
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8001492:	f5b1 0f80 	cmp.w	r1, #4194304	; 0x400000
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8001496:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 800149a:	ea42 0201 	orr.w	r2, r2, r1
 800149e:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 80014a2:	f000 8200 	beq.w	80018a6 <HAL_RCCEx_PeriphCLKConfig+0x472>
      plli2sused = 1; 
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
    {
      pllsaiused = 1; 
 80014a6:	2900      	cmp	r1, #0
 80014a8:	bf08      	it	eq
 80014aa:	2501      	moveq	r5, #1
  }
  
  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
  {    
      plli2sused = 1; 
 80014ac:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 80014b0:	bf18      	it	ne
 80014b2:	2601      	movne	r6, #1
  }  
  
  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 80014b4:	069a      	lsls	r2, r3, #26
 80014b6:	d531      	bpl.n	800151c <HAL_RCCEx_PeriphCLKConfig+0xe8>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 80014b8:	4b9f      	ldr	r3, [pc, #636]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
    
    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 80014ba:	4fa0      	ldr	r7, [pc, #640]	; (800173c <HAL_RCCEx_PeriphCLKConfig+0x308>)
    __HAL_RCC_PWR_CLK_ENABLE();
 80014bc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80014be:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80014c2:	641a      	str	r2, [r3, #64]	; 0x40
 80014c4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80014c6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80014ca:	9301      	str	r3, [sp, #4]
 80014cc:	9b01      	ldr	r3, [sp, #4]
    PWR->CR1 |= PWR_CR1_DBP;
 80014ce:	683b      	ldr	r3, [r7, #0]
 80014d0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80014d4:	603b      	str	r3, [r7, #0]
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80014d6:	f7fe fefb 	bl	80002d0 <HAL_GetTick>
 80014da:	4680      	mov	r8, r0
    
    /* Wait for Backup domain Write protection disable */
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 80014dc:	683b      	ldr	r3, [r7, #0]
 80014de:	05db      	lsls	r3, r3, #23
 80014e0:	f140 81e3 	bpl.w	80018aa <HAL_RCCEx_PeriphCLKConfig+0x476>
        return HAL_TIMEOUT;
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified */
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 80014e4:	4f94      	ldr	r7, [pc, #592]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80014e6:	6f3b      	ldr	r3, [r7, #112]	; 0x70

    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 80014e8:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 80014ec:	f040 81e8 	bne.w	80018c0 <HAL_RCCEx_PeriphCLKConfig+0x48c>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80014f0:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80014f2:	f403 7240 	and.w	r2, r3, #768	; 0x300
 80014f6:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 80014fa:	4a8f      	ldr	r2, [pc, #572]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80014fc:	f040 8206 	bne.w	800190c <HAL_RCCEx_PeriphCLKConfig+0x4d8>
 8001500:	6891      	ldr	r1, [r2, #8]
 8001502:	f023 4070 	bic.w	r0, r3, #4026531840	; 0xf0000000
 8001506:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
 800150a:	f420 7040 	bic.w	r0, r0, #768	; 0x300
 800150e:	4301      	orrs	r1, r0
 8001510:	6091      	str	r1, [r2, #8]
 8001512:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8001516:	6f11      	ldr	r1, [r2, #112]	; 0x70
 8001518:	430b      	orrs	r3, r1
 800151a:	6713      	str	r3, [r2, #112]	; 0x70
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 800151c:	6823      	ldr	r3, [r4, #0]
 800151e:	06da      	lsls	r2, r3, #27
 8001520:	d50c      	bpl.n	800153c <HAL_RCCEx_PeriphCLKConfig+0x108>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
    
    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8001522:	4a85      	ldr	r2, [pc, #532]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8001524:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 8001528:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 800152c:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
 8001530:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 8001534:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8001536:	4301      	orrs	r1, r0
 8001538:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
  }
  
  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800153c:	045f      	lsls	r7, r3, #17
 800153e:	d508      	bpl.n	8001552 <HAL_RCCEx_PeriphCLKConfig+0x11e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
    
    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8001540:	497d      	ldr	r1, [pc, #500]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8001542:	6e60      	ldr	r0, [r4, #100]	; 0x64
 8001544:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001548:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 800154c:	4302      	orrs	r2, r0
 800154e:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }
  
  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8001552:	0418      	lsls	r0, r3, #16
 8001554:	d508      	bpl.n	8001568 <HAL_RCCEx_PeriphCLKConfig+0x134>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));
    
    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8001556:	4978      	ldr	r1, [pc, #480]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8001558:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 800155a:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800155e:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 8001562:	4302      	orrs	r2, r0
 8001564:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }
  
  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8001568:	03d9      	lsls	r1, r3, #15
 800156a:	d508      	bpl.n	800157e <HAL_RCCEx_PeriphCLKConfig+0x14a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
    
    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 800156c:	4972      	ldr	r1, [pc, #456]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 800156e:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8001570:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001574:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8001578:	4302      	orrs	r2, r0
 800157a:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }
    
  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 800157e:	039a      	lsls	r2, r3, #14
 8001580:	d508      	bpl.n	8001594 <HAL_RCCEx_PeriphCLKConfig+0x160>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
    
    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8001582:	496d      	ldr	r1, [pc, #436]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8001584:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8001586:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800158a:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 800158e:	4302      	orrs	r2, r0
 8001590:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8001594:	065f      	lsls	r7, r3, #25
 8001596:	d508      	bpl.n	80015aa <HAL_RCCEx_PeriphCLKConfig+0x176>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
    
    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8001598:	4967      	ldr	r1, [pc, #412]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 800159a:	6c60      	ldr	r0, [r4, #68]	; 0x44
 800159c:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80015a0:	f022 0203 	bic.w	r2, r2, #3
 80015a4:	4302      	orrs	r2, r0
 80015a6:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 80015aa:	0618      	lsls	r0, r3, #24
 80015ac:	d508      	bpl.n	80015c0 <HAL_RCCEx_PeriphCLKConfig+0x18c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
    
    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 80015ae:	4962      	ldr	r1, [pc, #392]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80015b0:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 80015b2:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80015b6:	f022 020c 	bic.w	r2, r2, #12
 80015ba:	4302      	orrs	r2, r0
 80015bc:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 80015c0:	05d9      	lsls	r1, r3, #23
 80015c2:	d508      	bpl.n	80015d6 <HAL_RCCEx_PeriphCLKConfig+0x1a2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
    
    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 80015c4:	495c      	ldr	r1, [pc, #368]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80015c6:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 80015c8:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80015cc:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 80015d0:	4302      	orrs	r2, r0
 80015d2:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 80015d6:	059a      	lsls	r2, r3, #22
 80015d8:	d508      	bpl.n	80015ec <HAL_RCCEx_PeriphCLKConfig+0x1b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));
    
    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 80015da:	4957      	ldr	r1, [pc, #348]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80015dc:	6d20      	ldr	r0, [r4, #80]	; 0x50
 80015de:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80015e2:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 80015e6:	4302      	orrs	r2, r0
 80015e8:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 80015ec:	055f      	lsls	r7, r3, #21
 80015ee:	d508      	bpl.n	8001602 <HAL_RCCEx_PeriphCLKConfig+0x1ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));
    
    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 80015f0:	4951      	ldr	r1, [pc, #324]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80015f2:	6d60      	ldr	r0, [r4, #84]	; 0x54
 80015f4:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80015f8:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 80015fc:	4302      	orrs	r2, r0
 80015fe:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
 8001602:	0518      	lsls	r0, r3, #20
 8001604:	d508      	bpl.n	8001618 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));
    
    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
 8001606:	494c      	ldr	r1, [pc, #304]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8001608:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800160a:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800160e:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8001612:	4302      	orrs	r2, r0
 8001614:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
 8001618:	04d9      	lsls	r1, r3, #19
 800161a:	d508      	bpl.n	800162e <HAL_RCCEx_PeriphCLKConfig+0x1fa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));
    
    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
 800161c:	4946      	ldr	r1, [pc, #280]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 800161e:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 8001620:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001624:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8001628:	4302      	orrs	r2, r0
 800162a:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
 800162e:	049a      	lsls	r2, r3, #18
 8001630:	d508      	bpl.n	8001644 <HAL_RCCEx_PeriphCLKConfig+0x210>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));
    
    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
 8001632:	4941      	ldr	r1, [pc, #260]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8001634:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8001636:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800163a:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 800163e:	4302      	orrs	r2, r0
 8001640:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }
  
  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8001644:	025f      	lsls	r7, r3, #9
 8001646:	d508      	bpl.n	800165a <HAL_RCCEx_PeriphCLKConfig+0x226>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));
    
    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8001648:	493b      	ldr	r1, [pc, #236]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 800164a:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 800164c:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001650:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8001654:	4302      	orrs	r2, r0
 8001656:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }
  
  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
 800165a:	0298      	lsls	r0, r3, #10
 800165c:	d50c      	bpl.n	8001678 <HAL_RCCEx_PeriphCLKConfig+0x244>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));
    
    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 800165e:	4836      	ldr	r0, [pc, #216]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8001660:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 8001662:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
    {
      pllsaiused = 1; 
 8001666:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 800166a:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
      pllsaiused = 1; 
 800166e:	bf08      	it	eq
 8001670:	2501      	moveq	r5, #1
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8001672:	430a      	orrs	r2, r1
 8001674:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
  {
    pllsaiused = 1; 
 8001678:	f013 0f08 	tst.w	r3, #8
 800167c:	bf18      	it	ne
 800167e:	2501      	movne	r5, #1
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
  
  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 8001680:	0359      	lsls	r1, r3, #13
 8001682:	d508      	bpl.n	8001696 <HAL_RCCEx_PeriphCLKConfig+0x262>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
    
    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8001684:	492c      	ldr	r1, [pc, #176]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8001686:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8001688:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800168c:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 8001690:	4302      	orrs	r2, r0
 8001692:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
   }
  
  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
 8001696:	021a      	lsls	r2, r3, #8
 8001698:	d509      	bpl.n	80016ae <HAL_RCCEx_PeriphCLKConfig+0x27a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
    
    /* Configure the SDMMC1 clock source */
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 800169a:	4927      	ldr	r1, [pc, #156]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 800169c:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 80016a0:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80016a4:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 80016a8:	4302      	orrs	r2, r0
 80016aa:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }  
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
  
  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
 80016ae:	2e01      	cmp	r6, #1
 80016b0:	f000 8132 	beq.w	8001918 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
 80016b4:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 80016b8:	f000 812e 	beq.w	8001918 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
    }
  } 
  
  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
 80016bc:	2d01      	cmp	r5, #1
 80016be:	f040 80f0 	bne.w	80018a2 <HAL_RCCEx_PeriphCLKConfig+0x46e>
  {
    /* Disable PLLSAI Clock */
    __HAL_RCC_PLLSAI_DISABLE(); 
 80016c2:	4d1d      	ldr	r5, [pc, #116]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80016c4:	682b      	ldr	r3, [r5, #0]
 80016c6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80016ca:	602b      	str	r3, [r5, #0]
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80016cc:	f7fe fe00 	bl	80002d0 <HAL_GetTick>
 80016d0:	4606      	mov	r6, r0

    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 80016d2:	682b      	ldr	r3, [r5, #0]
 80016d4:	009f      	lsls	r7, r3, #2
 80016d6:	f100 823e 	bmi.w	8001b56 <HAL_RCCEx_PeriphCLKConfig+0x722>
    
    /* Check the PLLSAI division factors */
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));
    
    /*----------------- In Case of PLLSAI is selected as source clock for SAI -------------------*/  
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 80016da:	6821      	ldr	r1, [r4, #0]
 80016dc:	030e      	lsls	r6, r1, #12
 80016de:	d501      	bpl.n	80016e4 <HAL_RCCEx_PeriphCLKConfig+0x2b0>
 80016e0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80016e2:	b123      	cbz	r3, 80016ee <HAL_RCCEx_PeriphCLKConfig+0x2ba>
 80016e4:	02cd      	lsls	r5, r1, #11
 80016e6:	d54c      	bpl.n	8001782 <HAL_RCCEx_PeriphCLKConfig+0x34e>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 80016e8:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80016ea:	2b00      	cmp	r3, #0
 80016ec:	d149      	bne.n	8001782 <HAL_RCCEx_PeriphCLKConfig+0x34e>
      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
      /* check for PLLSAI/DIVQ Parameter */
      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));
    
      /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIP));
 80016ee:	4d12      	ldr	r5, [pc, #72]	; (8001738 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80016f0:	f44f 3e40 	mov.w	lr, #196608	; 0x30000
 80016f4:	f8d5 0088 	ldr.w	r0, [r5, #136]	; 0x88
 80016f8:	fa9e fcae 	rbit	ip, lr
 80016fc:	f04f 46e0 	mov.w	r6, #1879048192	; 0x70000000
 8001700:	fabc fc8c 	clz	ip, ip
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIR));
 8001704:	f8d5 2088 	ldr.w	r2, [r5, #136]	; 0x88
 8001708:	fa96 f7a6 	rbit	r7, r6
 800170c:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8001710:	fab7 f787 	clz	r7, r7
 8001714:	fa93 f3a3 	rbit	r3, r3
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 8001718:	fab3 f983 	clz	r9, r3
 800171c:	fa9e feae 	rbit	lr, lr
 8001720:	f04f 6870 	mov.w	r8, #251658240	; 0xf000000
 8001724:	fabe fe8e 	clz	lr, lr
 8001728:	fa98 f8a8 	rbit	r8, r8
 800172c:	fab8 f888 	clz	r8, r8
 8001730:	fa96 f6a6 	rbit	r6, r6
 8001734:	6963      	ldr	r3, [r4, #20]
 8001736:	e003      	b.n	8001740 <HAL_RCCEx_PeriphCLKConfig+0x30c>
 8001738:	40023800 	.word	0x40023800
 800173c:	40007000 	.word	0x40007000
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIP));
 8001740:	f400 3040 	and.w	r0, r0, #196608	; 0x30000
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIR));
 8001744:	f002 42e0 	and.w	r2, r2, #1879048192	; 0x70000000
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 8001748:	fab6 f686 	clz	r6, r6
 800174c:	fa03 f909 	lsl.w	r9, r3, r9
 8001750:	69a3      	ldr	r3, [r4, #24]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIP));
 8001752:	fa20 f00c 	lsr.w	r0, r0, ip
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIR));
 8001756:	40fa      	lsrs	r2, r7
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 8001758:	fa03 f808 	lsl.w	r8, r3, r8
 800175c:	fa00 f00e 	lsl.w	r0, r0, lr
 8001760:	40b2      	lsls	r2, r6
 8001762:	ea49 0308 	orr.w	r3, r9, r8
 8001766:	4303      	orrs	r3, r0
 8001768:	4313      	orrs	r3, r2
 800176a:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
      
      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */ 
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 800176e:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
 8001772:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8001774:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 8001778:	3a01      	subs	r2, #1
 800177a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800177e:	f8c5 308c 	str.w	r3, [r5, #140]	; 0x8c
    }           

    /*----------------- In Case of PLLSAI is selected as source clock for CLK48 -------------------*/   
    /* In Case of PLLI2S is selected as source clock for CK48 */ 
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
 8001782:	0288      	lsls	r0, r1, #10
 8001784:	d53e      	bpl.n	8001804 <HAL_RCCEx_PeriphCLKConfig+0x3d0>
 8001786:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 8001788:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800178c:	d13a      	bne.n	8001804 <HAL_RCCEx_PeriphCLKConfig+0x3d0>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));
      /* Read PLLSAIQ and PLLSAIR value from PLLSAICFGR register (this value is not needed for CK48 configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIQ));
 800178e:	4d61      	ldr	r5, [pc, #388]	; (8001914 <HAL_RCCEx_PeriphCLKConfig+0x4e0>)
 8001790:	f04f 6e70 	mov.w	lr, #251658240	; 0xf000000
 8001794:	f8d5 0088 	ldr.w	r0, [r5, #136]	; 0x88
 8001798:	fa9e fcae 	rbit	ip, lr
 800179c:	f04f 46e0 	mov.w	r6, #1879048192	; 0x70000000
 80017a0:	fabc fc8c 	clz	ip, ip
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIR));
 80017a4:	f8d5 2088 	ldr.w	r2, [r5, #136]	; 0x88
 80017a8:	fa96 f7a6 	rbit	r7, r6
 80017ac:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 80017b0:	fab7 f787 	clz	r7, r7
 80017b4:	fa93 f3a3 	rbit	r3, r3
 80017b8:	f44f 3840 	mov.w	r8, #196608	; 0x30000
      
      /* Configure the PLLSAI division factors */
      /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x (PLLI2SN/PLLM) */
      /* 48CLK = f(PLLSAI clock output) = f(VCO clock) / PLLSAIP */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 80017bc:	fab3 f983 	clz	r9, r3
 80017c0:	fa98 f8a8 	rbit	r8, r8
 80017c4:	fab8 f888 	clz	r8, r8
 80017c8:	fa9e feae 	rbit	lr, lr
 80017cc:	fabe fe8e 	clz	lr, lr
 80017d0:	fa96 f6a6 	rbit	r6, r6
 80017d4:	6963      	ldr	r3, [r4, #20]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIQ));
 80017d6:	f000 6070 	and.w	r0, r0, #251658240	; 0xf000000
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIR));
 80017da:	f002 42e0 	and.w	r2, r2, #1879048192	; 0x70000000
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 80017de:	fab6 f686 	clz	r6, r6
 80017e2:	fa03 f909 	lsl.w	r9, r3, r9
 80017e6:	6a23      	ldr	r3, [r4, #32]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIQ));
 80017e8:	fa20 f00c 	lsr.w	r0, r0, ip
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIR));
 80017ec:	40fa      	lsrs	r2, r7
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 80017ee:	fa03 f808 	lsl.w	r8, r3, r8
 80017f2:	fa00 f00e 	lsl.w	r0, r0, lr
 80017f6:	40b2      	lsls	r2, r6
 80017f8:	ea49 0308 	orr.w	r3, r9, r8
 80017fc:	4303      	orrs	r3, r0
 80017fe:	4313      	orrs	r3, r2
 8001800:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
    }        

#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) 
    /*---------------------------- LTDC configuration -------------------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 8001804:	070a      	lsls	r2, r1, #28
 8001806:	d540      	bpl.n	800188a <HAL_RCCEx_PeriphCLKConfig+0x456>
    {
      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));
      
      /* Read PLLSAIP and PLLSAIQ value from PLLSAICFGR register (these value are not needed for LTDC configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIQ));
 8001808:	4842      	ldr	r0, [pc, #264]	; (8001914 <HAL_RCCEx_PeriphCLKConfig+0x4e0>)
 800180a:	f04f 6570 	mov.w	r5, #251658240	; 0xf000000
 800180e:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001812:	fa95 f6a5 	rbit	r6, r5
 8001816:	f44f 3e40 	mov.w	lr, #196608	; 0x30000
 800181a:	fab6 f686 	clz	r6, r6
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIP));
 800181e:	f8d0 1088 	ldr.w	r1, [r0, #136]	; 0x88
 8001822:	fa9e f8ae 	rbit	r8, lr
 8001826:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800182a:	fab8 f888 	clz	r8, r8
 800182e:	fa93 f3a3 	rbit	r3, r3
      
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 8001832:	fab3 f783 	clz	r7, r3
 8001836:	fa9e feae 	rbit	lr, lr
 800183a:	fabe fe8e 	clz	lr, lr
 800183e:	fa95 f5a5 	rbit	r5, r5
 8001842:	f04f 4ce0 	mov.w	ip, #1879048192	; 0x70000000
 8001846:	fab5 f585 	clz	r5, r5
 800184a:	fa9c fcac 	rbit	ip, ip
 800184e:	6963      	ldr	r3, [r4, #20]
 8001850:	fabc fc8c 	clz	ip, ip
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIP));
 8001854:	f401 3140 	and.w	r1, r1, #196608	; 0x30000
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIQ));
 8001858:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 800185c:	40bb      	lsls	r3, r7
 800185e:	69e7      	ldr	r7, [r4, #28]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIP));
 8001860:	fa21 f108 	lsr.w	r1, r1, r8
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIQ));
 8001864:	40f2      	lsrs	r2, r6
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 8001866:	fa07 f70c 	lsl.w	r7, r7, ip
 800186a:	fa01 f10e 	lsl.w	r1, r1, lr
 800186e:	40aa      	lsls	r2, r5
 8001870:	433b      	orrs	r3, r7
 8001872:	430b      	orrs	r3, r1
 8001874:	4313      	orrs	r3, r2
 8001876:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
      
      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */ 
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 800187a:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
 800187e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001880:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8001884:	4313      	orrs	r3, r2
 8001886:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
    }    
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */  

    /* Enable PLLSAI Clock */
    __HAL_RCC_PLLSAI_ENABLE();
 800188a:	4c22      	ldr	r4, [pc, #136]	; (8001914 <HAL_RCCEx_PeriphCLKConfig+0x4e0>)
 800188c:	6823      	ldr	r3, [r4, #0]
 800188e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001892:	6023      	str	r3, [r4, #0]
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001894:	f7fe fd1c 	bl	80002d0 <HAL_GetTick>
 8001898:	4605      	mov	r5, r0

    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 800189a:	6823      	ldr	r3, [r4, #0]
 800189c:	009b      	lsls	r3, r3, #2
 800189e:	f140 8161 	bpl.w	8001b64 <HAL_RCCEx_PeriphCLKConfig+0x730>
        /* return in case of Timeout detected */        
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 80018a2:	2000      	movs	r0, #0
 80018a4:	e009      	b.n	80018ba <HAL_RCCEx_PeriphCLKConfig+0x486>
      plli2sused = 1; 
 80018a6:	2601      	movs	r6, #1
 80018a8:	e600      	b.n	80014ac <HAL_RCCEx_PeriphCLKConfig+0x78>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80018aa:	f7fe fd11 	bl	80002d0 <HAL_GetTick>
 80018ae:	eba0 0008 	sub.w	r0, r0, r8
 80018b2:	2864      	cmp	r0, #100	; 0x64
 80018b4:	f67f ae12 	bls.w	80014dc <HAL_RCCEx_PeriphCLKConfig+0xa8>
        return HAL_TIMEOUT;
 80018b8:	2003      	movs	r0, #3
}
 80018ba:	b002      	add	sp, #8
 80018bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 80018c0:	6b22      	ldr	r2, [r4, #48]	; 0x30
 80018c2:	f402 7240 	and.w	r2, r2, #768	; 0x300
 80018c6:	4293      	cmp	r3, r2
 80018c8:	f43f ae12 	beq.w	80014f0 <HAL_RCCEx_PeriphCLKConfig+0xbc>
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 80018cc:	6f3b      	ldr	r3, [r7, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_FORCE();
 80018ce:	6f3a      	ldr	r2, [r7, #112]	; 0x70
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 80018d0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 80018d4:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80018d8:	673a      	str	r2, [r7, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
 80018da:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 80018dc:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80018e0:	673a      	str	r2, [r7, #112]	; 0x70
      RCC->BDCR = tmpreg0;
 80018e2:	673b      	str	r3, [r7, #112]	; 0x70
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 80018e4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80018e6:	07d8      	lsls	r0, r3, #31
 80018e8:	f57f ae02 	bpl.w	80014f0 <HAL_RCCEx_PeriphCLKConfig+0xbc>
        tickstart = HAL_GetTick();
 80018ec:	f7fe fcf0 	bl	80002d0 <HAL_GetTick>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80018f0:	f241 3988 	movw	r9, #5000	; 0x1388
        tickstart = HAL_GetTick();
 80018f4:	4680      	mov	r8, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80018f6:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80018f8:	0799      	lsls	r1, r3, #30
 80018fa:	f53f adf9 	bmi.w	80014f0 <HAL_RCCEx_PeriphCLKConfig+0xbc>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80018fe:	f7fe fce7 	bl	80002d0 <HAL_GetTick>
 8001902:	eba0 0008 	sub.w	r0, r0, r8
 8001906:	4548      	cmp	r0, r9
 8001908:	d9f5      	bls.n	80018f6 <HAL_RCCEx_PeriphCLKConfig+0x4c2>
 800190a:	e7d5      	b.n	80018b8 <HAL_RCCEx_PeriphCLKConfig+0x484>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800190c:	6891      	ldr	r1, [r2, #8]
 800190e:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
 8001912:	e5fd      	b.n	8001510 <HAL_RCCEx_PeriphCLKConfig+0xdc>
 8001914:	40023800 	.word	0x40023800
    __HAL_RCC_PLLI2S_DISABLE();  
 8001918:	4e96      	ldr	r6, [pc, #600]	; (8001b74 <HAL_RCCEx_PeriphCLKConfig+0x740>)
 800191a:	6833      	ldr	r3, [r6, #0]
 800191c:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8001920:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 8001922:	f7fe fcd5 	bl	80002d0 <HAL_GetTick>
 8001926:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8001928:	6833      	ldr	r3, [r6, #0]
 800192a:	011b      	lsls	r3, r3, #4
 800192c:	f100 810c 	bmi.w	8001b48 <HAL_RCCEx_PeriphCLKConfig+0x714>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
 8001930:	6822      	ldr	r2, [r4, #0]
 8001932:	07d7      	lsls	r7, r2, #31
 8001934:	d53c      	bpl.n	80019b0 <HAL_RCCEx_PeriphCLKConfig+0x57c>
 8001936:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001938:	bbd3      	cbnz	r3, 80019b0 <HAL_RCCEx_PeriphCLKConfig+0x57c>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SP));
 800193a:	f8d6 0084 	ldr.w	r0, [r6, #132]	; 0x84
 800193e:	f44f 3c40 	mov.w	ip, #196608	; 0x30000
 8001942:	fa9c f8ac 	rbit	r8, ip
 8001946:	f04f 6770 	mov.w	r7, #251658240	; 0xf000000
 800194a:	fab8 f888 	clz	r8, r8
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SQ));
 800194e:	f8d6 1084 	ldr.w	r1, [r6, #132]	; 0x84
 8001952:	fa97 fea7 	rbit	lr, r7
 8001956:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800195a:	fabe fe8e 	clz	lr, lr
 800195e:	fa93 f3a3 	rbit	r3, r3
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 8001962:	fab3 fa83 	clz	sl, r3
 8001966:	fa9c fcac 	rbit	ip, ip
 800196a:	fabc fc8c 	clz	ip, ip
 800196e:	fa97 f7a7 	rbit	r7, r7
 8001972:	f04f 49e0 	mov.w	r9, #1879048192	; 0x70000000
 8001976:	fab7 f787 	clz	r7, r7
 800197a:	fa99 f9a9 	rbit	r9, r9
 800197e:	6863      	ldr	r3, [r4, #4]
 8001980:	fab9 f989 	clz	r9, r9
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SP));
 8001984:	f400 3040 	and.w	r0, r0, #196608	; 0x30000
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SQ));
 8001988:	f001 6170 	and.w	r1, r1, #251658240	; 0xf000000
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 800198c:	fa03 fa0a 	lsl.w	sl, r3, sl
 8001990:	68a3      	ldr	r3, [r4, #8]
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SP));
 8001992:	fa20 f008 	lsr.w	r0, r0, r8
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SQ));
 8001996:	fa21 f10e 	lsr.w	r1, r1, lr
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 800199a:	fa03 f909 	lsl.w	r9, r3, r9
 800199e:	fa00 f00c 	lsl.w	r0, r0, ip
 80019a2:	40b9      	lsls	r1, r7
 80019a4:	ea4a 0309 	orr.w	r3, sl, r9
 80019a8:	4303      	orrs	r3, r0
 80019aa:	430b      	orrs	r3, r1
 80019ac:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 80019b0:	0316      	lsls	r6, r2, #12
 80019b2:	d503      	bpl.n	80019bc <HAL_RCCEx_PeriphCLKConfig+0x588>
 80019b4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80019b6:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 80019ba:	d005      	beq.n	80019c8 <HAL_RCCEx_PeriphCLKConfig+0x594>
 80019bc:	02d0      	lsls	r0, r2, #11
 80019be:	d548      	bpl.n	8001a52 <HAL_RCCEx_PeriphCLKConfig+0x61e>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S))) 
 80019c0:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80019c2:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 80019c6:	d144      	bne.n	8001a52 <HAL_RCCEx_PeriphCLKConfig+0x61e>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SP));
 80019c8:	4e6a      	ldr	r6, [pc, #424]	; (8001b74 <HAL_RCCEx_PeriphCLKConfig+0x740>)
 80019ca:	f44f 3c40 	mov.w	ip, #196608	; 0x30000
 80019ce:	f8d6 0084 	ldr.w	r0, [r6, #132]	; 0x84
 80019d2:	fa9c f8ac 	rbit	r8, ip
 80019d6:	f04f 47e0 	mov.w	r7, #1879048192	; 0x70000000
 80019da:	fab8 f888 	clz	r8, r8
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SR));
 80019de:	f8d6 1084 	ldr.w	r1, [r6, #132]	; 0x84
 80019e2:	fa97 fea7 	rbit	lr, r7
 80019e6:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 80019ea:	fabe fe8e 	clz	lr, lr
 80019ee:	fa93 f3a3 	rbit	r3, r3
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 80019f2:	fab3 fa83 	clz	sl, r3
 80019f6:	fa9c fcac 	rbit	ip, ip
 80019fa:	f04f 6970 	mov.w	r9, #251658240	; 0xf000000
 80019fe:	fabc fc8c 	clz	ip, ip
 8001a02:	fa99 f9a9 	rbit	r9, r9
 8001a06:	fab9 f989 	clz	r9, r9
 8001a0a:	fa97 f7a7 	rbit	r7, r7
 8001a0e:	6863      	ldr	r3, [r4, #4]
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SP));
 8001a10:	f400 3040 	and.w	r0, r0, #196608	; 0x30000
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SR));
 8001a14:	f001 41e0 	and.w	r1, r1, #1879048192	; 0x70000000
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 8001a18:	fab7 f787 	clz	r7, r7
 8001a1c:	fa03 fa0a 	lsl.w	sl, r3, sl
 8001a20:	68e3      	ldr	r3, [r4, #12]
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SP));
 8001a22:	fa20 f008 	lsr.w	r0, r0, r8
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SR));
 8001a26:	fa21 f10e 	lsr.w	r1, r1, lr
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 8001a2a:	fa03 f909 	lsl.w	r9, r3, r9
 8001a2e:	fa00 f00c 	lsl.w	r0, r0, ip
 8001a32:	40b9      	lsls	r1, r7
 8001a34:	ea4a 0309 	orr.w	r3, sl, r9
 8001a38:	4303      	orrs	r3, r0
 8001a3a:	430b      	orrs	r3, r1
 8001a3c:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);   
 8001a40:	f8d6 108c 	ldr.w	r1, [r6, #140]	; 0x8c
 8001a44:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001a46:	f021 011f 	bic.w	r1, r1, #31
 8001a4a:	3b01      	subs	r3, #1
 8001a4c:	430b      	orrs	r3, r1
 8001a4e:	f8c6 308c 	str.w	r3, [r6, #140]	; 0x8c
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8001a52:	01d1      	lsls	r1, r2, #7
 8001a54:	d53b      	bpl.n	8001ace <HAL_RCCEx_PeriphCLKConfig+0x69a>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SQ));
 8001a56:	4e47      	ldr	r6, [pc, #284]	; (8001b74 <HAL_RCCEx_PeriphCLKConfig+0x740>)
 8001a58:	f04f 6c70 	mov.w	ip, #251658240	; 0xf000000
 8001a5c:	f8d6 0084 	ldr.w	r0, [r6, #132]	; 0x84
 8001a60:	fa9c f8ac 	rbit	r8, ip
 8001a64:	f04f 47e0 	mov.w	r7, #1879048192	; 0x70000000
 8001a68:	fab8 f888 	clz	r8, r8
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SR));
 8001a6c:	f8d6 1084 	ldr.w	r1, [r6, #132]	; 0x84
 8001a70:	fa97 fea7 	rbit	lr, r7
 8001a74:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8001a78:	fabe fe8e 	clz	lr, lr
 8001a7c:	fa93 f3a3 	rbit	r3, r3
 8001a80:	f44f 3940 	mov.w	r9, #196608	; 0x30000
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 8001a84:	fab3 fa83 	clz	sl, r3
 8001a88:	fa99 f9a9 	rbit	r9, r9
 8001a8c:	fab9 f989 	clz	r9, r9
 8001a90:	fa9c fcac 	rbit	ip, ip
 8001a94:	fabc fc8c 	clz	ip, ip
 8001a98:	fa97 f7a7 	rbit	r7, r7
 8001a9c:	6863      	ldr	r3, [r4, #4]
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SQ));
 8001a9e:	f000 6070 	and.w	r0, r0, #251658240	; 0xf000000
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SR));
 8001aa2:	f001 41e0 	and.w	r1, r1, #1879048192	; 0x70000000
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 8001aa6:	fab7 f787 	clz	r7, r7
 8001aaa:	fa03 fa0a 	lsl.w	sl, r3, sl
 8001aae:	6923      	ldr	r3, [r4, #16]
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SQ));
 8001ab0:	fa20 f008 	lsr.w	r0, r0, r8
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SR));
 8001ab4:	fa21 f10e 	lsr.w	r1, r1, lr
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 8001ab8:	fa03 f909 	lsl.w	r9, r3, r9
 8001abc:	fa00 f00c 	lsl.w	r0, r0, ip
 8001ac0:	40b9      	lsls	r1, r7
 8001ac2:	ea4a 0309 	orr.w	r3, sl, r9
 8001ac6:	4303      	orrs	r3, r0
 8001ac8:	430b      	orrs	r3, r1
 8001aca:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 8001ace:	0192      	lsls	r2, r2, #6
 8001ad0:	d528      	bpl.n	8001b24 <HAL_RCCEx_PeriphCLKConfig+0x6f0>
 8001ad2:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8001ad6:	fa93 f3a3 	rbit	r3, r3
 8001ada:	f44f 3040 	mov.w	r0, #196608	; 0x30000
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 8001ade:	fab3 f683 	clz	r6, r3
 8001ae2:	fa90 f0a0 	rbit	r0, r0
 8001ae6:	f04f 6170 	mov.w	r1, #251658240	; 0xf000000
 8001aea:	fab0 f080 	clz	r0, r0
 8001aee:	fa91 f1a1 	rbit	r1, r1
 8001af2:	f04f 42e0 	mov.w	r2, #1879048192	; 0x70000000
 8001af6:	fab1 f181 	clz	r1, r1
 8001afa:	fa92 f2a2 	rbit	r2, r2
 8001afe:	6863      	ldr	r3, [r4, #4]
 8001b00:	fab2 f282 	clz	r2, r2
 8001b04:	40b3      	lsls	r3, r6
 8001b06:	6926      	ldr	r6, [r4, #16]
 8001b08:	fa06 f000 	lsl.w	r0, r6, r0
 8001b0c:	4303      	orrs	r3, r0
 8001b0e:	68e0      	ldr	r0, [r4, #12]
 8001b10:	fa00 f101 	lsl.w	r1, r0, r1
 8001b14:	430b      	orrs	r3, r1
 8001b16:	68a1      	ldr	r1, [r4, #8]
 8001b18:	fa01 f202 	lsl.w	r2, r1, r2
 8001b1c:	4313      	orrs	r3, r2
 8001b1e:	4a15      	ldr	r2, [pc, #84]	; (8001b74 <HAL_RCCEx_PeriphCLKConfig+0x740>)
 8001b20:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    __HAL_RCC_PLLI2S_ENABLE();
 8001b24:	4e13      	ldr	r6, [pc, #76]	; (8001b74 <HAL_RCCEx_PeriphCLKConfig+0x740>)
 8001b26:	6833      	ldr	r3, [r6, #0]
 8001b28:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8001b2c:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 8001b2e:	f7fe fbcf 	bl	80002d0 <HAL_GetTick>
 8001b32:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8001b34:	6833      	ldr	r3, [r6, #0]
 8001b36:	011b      	lsls	r3, r3, #4
 8001b38:	f53f adc0 	bmi.w	80016bc <HAL_RCCEx_PeriphCLKConfig+0x288>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8001b3c:	f7fe fbc8 	bl	80002d0 <HAL_GetTick>
 8001b40:	1bc0      	subs	r0, r0, r7
 8001b42:	2864      	cmp	r0, #100	; 0x64
 8001b44:	d9f6      	bls.n	8001b34 <HAL_RCCEx_PeriphCLKConfig+0x700>
 8001b46:	e6b7      	b.n	80018b8 <HAL_RCCEx_PeriphCLKConfig+0x484>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8001b48:	f7fe fbc2 	bl	80002d0 <HAL_GetTick>
 8001b4c:	1bc0      	subs	r0, r0, r7
 8001b4e:	2864      	cmp	r0, #100	; 0x64
 8001b50:	f67f aeea 	bls.w	8001928 <HAL_RCCEx_PeriphCLKConfig+0x4f4>
 8001b54:	e6b0      	b.n	80018b8 <HAL_RCCEx_PeriphCLKConfig+0x484>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8001b56:	f7fe fbbb 	bl	80002d0 <HAL_GetTick>
 8001b5a:	1b80      	subs	r0, r0, r6
 8001b5c:	2864      	cmp	r0, #100	; 0x64
 8001b5e:	f67f adb8 	bls.w	80016d2 <HAL_RCCEx_PeriphCLKConfig+0x29e>
 8001b62:	e6a9      	b.n	80018b8 <HAL_RCCEx_PeriphCLKConfig+0x484>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8001b64:	f7fe fbb4 	bl	80002d0 <HAL_GetTick>
 8001b68:	1b40      	subs	r0, r0, r5
 8001b6a:	2864      	cmp	r0, #100	; 0x64
 8001b6c:	f67f ae95 	bls.w	800189a <HAL_RCCEx_PeriphCLKConfig+0x466>
 8001b70:	e6a2      	b.n	80018b8 <HAL_RCCEx_PeriphCLKConfig+0x484>
 8001b72:	bf00      	nop
 8001b74:	40023800 	.word	0x40023800

08001b78 <HAL_TIM_Base_MspInit>:
 8001b78:	4770      	bx	lr

08001b7a <HAL_TIM_Base_Start_IT>:
{
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  
  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8001b7a:	6803      	ldr	r3, [r0, #0]
  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
      
  /* Return function status */
  return HAL_OK;
}
 8001b7c:	2000      	movs	r0, #0
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8001b7e:	68da      	ldr	r2, [r3, #12]
 8001b80:	f042 0201 	orr.w	r2, r2, #1
 8001b84:	60da      	str	r2, [r3, #12]
  __HAL_TIM_ENABLE(htim);
 8001b86:	681a      	ldr	r2, [r3, #0]
 8001b88:	f042 0201 	orr.w	r2, r2, #1
 8001b8c:	601a      	str	r2, [r3, #0]
}
 8001b8e:	4770      	bx	lr

08001b90 <HAL_TIM_OC_DelayElapsedCallback>:
 8001b90:	4770      	bx	lr

08001b92 <HAL_TIM_IC_CaptureCallback>:
 8001b92:	4770      	bx	lr

08001b94 <HAL_TIM_PWM_PulseFinishedCallback>:
 8001b94:	4770      	bx	lr

08001b96 <HAL_TIM_TriggerCallback>:
 8001b96:	4770      	bx	lr

08001b98 <HAL_TIM_IRQHandler>:
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
  /* Capture compare 1 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8001b98:	6803      	ldr	r3, [r0, #0]
 8001b9a:	691a      	ldr	r2, [r3, #16]
 8001b9c:	0791      	lsls	r1, r2, #30
{
 8001b9e:	b510      	push	{r4, lr}
 8001ba0:	4604      	mov	r4, r0
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8001ba2:	d50f      	bpl.n	8001bc4 <HAL_TIM_IRQHandler+0x2c>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
 8001ba4:	68da      	ldr	r2, [r3, #12]
 8001ba6:	0792      	lsls	r2, r2, #30
 8001ba8:	d50c      	bpl.n	8001bc4 <HAL_TIM_IRQHandler+0x2c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8001baa:	f06f 0202 	mvn.w	r2, #2
 8001bae:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8001bb0:	2201      	movs	r2, #1
        
        /* Input capture event */
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
 8001bb2:	699b      	ldr	r3, [r3, #24]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8001bb4:	7602      	strb	r2, [r0, #24]
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
 8001bb6:	0799      	lsls	r1, r3, #30
 8001bb8:	f000 8085 	beq.w	8001cc6 <HAL_TIM_IRQHandler+0x12e>
        {
          HAL_TIM_IC_CaptureCallback(htim);
 8001bbc:	f7ff ffe9 	bl	8001b92 <HAL_TIM_IC_CaptureCallback>
        else
        {
          HAL_TIM_OC_DelayElapsedCallback(htim);
          HAL_TIM_PWM_PulseFinishedCallback(htim);
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001bc0:	2300      	movs	r3, #0
 8001bc2:	7623      	strb	r3, [r4, #24]
      }
    }
  }
  /* Capture compare 2 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8001bc4:	6823      	ldr	r3, [r4, #0]
 8001bc6:	691a      	ldr	r2, [r3, #16]
 8001bc8:	0752      	lsls	r2, r2, #29
 8001bca:	d510      	bpl.n	8001bee <HAL_TIM_IRQHandler+0x56>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
 8001bcc:	68da      	ldr	r2, [r3, #12]
 8001bce:	0750      	lsls	r0, r2, #29
 8001bd0:	d50d      	bpl.n	8001bee <HAL_TIM_IRQHandler+0x56>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8001bd2:	f06f 0204 	mvn.w	r2, #4
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
      /* Input capture event */
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 8001bd6:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8001bd8:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8001bda:	2202      	movs	r2, #2
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
 8001bdc:	699b      	ldr	r3, [r3, #24]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8001bde:	7622      	strb	r2, [r4, #24]
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
 8001be0:	f413 7f40 	tst.w	r3, #768	; 0x300
 8001be4:	d075      	beq.n	8001cd2 <HAL_TIM_IRQHandler+0x13a>
        HAL_TIM_IC_CaptureCallback(htim);
 8001be6:	f7ff ffd4 	bl	8001b92 <HAL_TIM_IC_CaptureCallback>
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001bea:	2300      	movs	r3, #0
 8001bec:	7623      	strb	r3, [r4, #24]
    }
  }
  /* Capture compare 3 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8001bee:	6823      	ldr	r3, [r4, #0]
 8001bf0:	691a      	ldr	r2, [r3, #16]
 8001bf2:	0711      	lsls	r1, r2, #28
 8001bf4:	d50f      	bpl.n	8001c16 <HAL_TIM_IRQHandler+0x7e>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
 8001bf6:	68da      	ldr	r2, [r3, #12]
 8001bf8:	0712      	lsls	r2, r2, #28
 8001bfa:	d50c      	bpl.n	8001c16 <HAL_TIM_IRQHandler+0x7e>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8001bfc:	f06f 0208 	mvn.w	r2, #8
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 8001c00:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8001c02:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8001c04:	2204      	movs	r2, #4
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
 8001c06:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8001c08:	7622      	strb	r2, [r4, #24]
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
 8001c0a:	079b      	lsls	r3, r3, #30
 8001c0c:	d067      	beq.n	8001cde <HAL_TIM_IRQHandler+0x146>
        HAL_TIM_IC_CaptureCallback(htim);
 8001c0e:	f7ff ffc0 	bl	8001b92 <HAL_TIM_IC_CaptureCallback>
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim); 
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001c12:	2300      	movs	r3, #0
 8001c14:	7623      	strb	r3, [r4, #24]
    }
  }
  /* Capture compare 4 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8001c16:	6823      	ldr	r3, [r4, #0]
 8001c18:	691a      	ldr	r2, [r3, #16]
 8001c1a:	06d0      	lsls	r0, r2, #27
 8001c1c:	d510      	bpl.n	8001c40 <HAL_TIM_IRQHandler+0xa8>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
 8001c1e:	68da      	ldr	r2, [r3, #12]
 8001c20:	06d1      	lsls	r1, r2, #27
 8001c22:	d50d      	bpl.n	8001c40 <HAL_TIM_IRQHandler+0xa8>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8001c24:	f06f 0210 	mvn.w	r2, #16
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 8001c28:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8001c2a:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8001c2c:	2208      	movs	r2, #8
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
 8001c2e:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8001c30:	7622      	strb	r2, [r4, #24]
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
 8001c32:	f413 7f40 	tst.w	r3, #768	; 0x300
 8001c36:	d058      	beq.n	8001cea <HAL_TIM_IRQHandler+0x152>
        HAL_TIM_IC_CaptureCallback(htim);
 8001c38:	f7ff ffab 	bl	8001b92 <HAL_TIM_IC_CaptureCallback>
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001c3c:	2300      	movs	r3, #0
 8001c3e:	7623      	strb	r3, [r4, #24]
    }
  }
  /* TIM Update event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8001c40:	6823      	ldr	r3, [r4, #0]
 8001c42:	691a      	ldr	r2, [r3, #16]
 8001c44:	07d2      	lsls	r2, r2, #31
 8001c46:	d508      	bpl.n	8001c5a <HAL_TIM_IRQHandler+0xc2>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
 8001c48:	68da      	ldr	r2, [r3, #12]
 8001c4a:	07d0      	lsls	r0, r2, #31
 8001c4c:	d505      	bpl.n	8001c5a <HAL_TIM_IRQHandler+0xc2>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8001c4e:	f06f 0201 	mvn.w	r2, #1
      HAL_TIM_PeriodElapsedCallback(htim);
 8001c52:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8001c54:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8001c56:	f007 fe23 	bl	80098a0 <HAL_TIM_PeriodElapsedCallback>
    }
  }
  /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8001c5a:	6823      	ldr	r3, [r4, #0]
 8001c5c:	691a      	ldr	r2, [r3, #16]
 8001c5e:	0611      	lsls	r1, r2, #24
 8001c60:	d508      	bpl.n	8001c74 <HAL_TIM_IRQHandler+0xdc>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 8001c62:	68da      	ldr	r2, [r3, #12]
 8001c64:	0612      	lsls	r2, r2, #24
 8001c66:	d505      	bpl.n	8001c74 <HAL_TIM_IRQHandler+0xdc>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8001c68:	f06f 0280 	mvn.w	r2, #128	; 0x80
      HAL_TIMEx_BreakCallback(htim);
 8001c6c:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8001c6e:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8001c70:	f000 f8bd 	bl	8001dee <HAL_TIMEx_BreakCallback>
    }
  }
  
    /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8001c74:	6823      	ldr	r3, [r4, #0]
 8001c76:	691a      	ldr	r2, [r3, #16]
 8001c78:	05d0      	lsls	r0, r2, #23
 8001c7a:	d508      	bpl.n	8001c8e <HAL_TIM_IRQHandler+0xf6>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 8001c7c:	68da      	ldr	r2, [r3, #12]
 8001c7e:	0611      	lsls	r1, r2, #24
 8001c80:	d505      	bpl.n	8001c8e <HAL_TIM_IRQHandler+0xf6>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8001c82:	f06f 0280 	mvn.w	r2, #128	; 0x80
      HAL_TIMEx_BreakCallback(htim);
 8001c86:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8001c88:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8001c8a:	f000 f8b0 	bl	8001dee <HAL_TIMEx_BreakCallback>
    }
  }

  /* TIM Trigger detection event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8001c8e:	6823      	ldr	r3, [r4, #0]
 8001c90:	691a      	ldr	r2, [r3, #16]
 8001c92:	0652      	lsls	r2, r2, #25
 8001c94:	d508      	bpl.n	8001ca8 <HAL_TIM_IRQHandler+0x110>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
 8001c96:	68da      	ldr	r2, [r3, #12]
 8001c98:	0650      	lsls	r0, r2, #25
 8001c9a:	d505      	bpl.n	8001ca8 <HAL_TIM_IRQHandler+0x110>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8001c9c:	f06f 0240 	mvn.w	r2, #64	; 0x40
      HAL_TIM_TriggerCallback(htim);
 8001ca0:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8001ca2:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8001ca4:	f7ff ff77 	bl	8001b96 <HAL_TIM_TriggerCallback>
    }
  }
  /* TIM commutation event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8001ca8:	6823      	ldr	r3, [r4, #0]
 8001caa:	691a      	ldr	r2, [r3, #16]
 8001cac:	0691      	lsls	r1, r2, #26
 8001cae:	d522      	bpl.n	8001cf6 <HAL_TIM_IRQHandler+0x15e>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
 8001cb0:	68da      	ldr	r2, [r3, #12]
 8001cb2:	0692      	lsls	r2, r2, #26
 8001cb4:	d51f      	bpl.n	8001cf6 <HAL_TIM_IRQHandler+0x15e>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8001cb6:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutationCallback(htim);
 8001cba:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8001cbc:	611a      	str	r2, [r3, #16]
    }
  }
}
 8001cbe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_CommutationCallback(htim);
 8001cc2:	f000 b893 	b.w	8001dec <HAL_TIMEx_CommutationCallback>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8001cc6:	f7ff ff63 	bl	8001b90 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001cca:	4620      	mov	r0, r4
 8001ccc:	f7ff ff62 	bl	8001b94 <HAL_TIM_PWM_PulseFinishedCallback>
 8001cd0:	e776      	b.n	8001bc0 <HAL_TIM_IRQHandler+0x28>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001cd2:	f7ff ff5d 	bl	8001b90 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001cd6:	4620      	mov	r0, r4
 8001cd8:	f7ff ff5c 	bl	8001b94 <HAL_TIM_PWM_PulseFinishedCallback>
 8001cdc:	e785      	b.n	8001bea <HAL_TIM_IRQHandler+0x52>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001cde:	f7ff ff57 	bl	8001b90 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim); 
 8001ce2:	4620      	mov	r0, r4
 8001ce4:	f7ff ff56 	bl	8001b94 <HAL_TIM_PWM_PulseFinishedCallback>
 8001ce8:	e793      	b.n	8001c12 <HAL_TIM_IRQHandler+0x7a>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001cea:	f7ff ff51 	bl	8001b90 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001cee:	4620      	mov	r0, r4
 8001cf0:	f7ff ff50 	bl	8001b94 <HAL_TIM_PWM_PulseFinishedCallback>
 8001cf4:	e7a2      	b.n	8001c3c <HAL_TIM_IRQHandler+0xa4>
 8001cf6:	bd10      	pop	{r4, pc}

08001cf8 <TIM_Base_SetConfig>:
{
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;
  
  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
 8001cf8:	4a2e      	ldr	r2, [pc, #184]	; (8001db4 <TIM_Base_SetConfig+0xbc>)
  tmpcr1 = TIMx->CR1;
 8001cfa:	6803      	ldr	r3, [r0, #0]
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
 8001cfc:	4290      	cmp	r0, r2
 8001cfe:	d012      	beq.n	8001d26 <TIM_Base_SetConfig+0x2e>
 8001d00:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8001d04:	d00f      	beq.n	8001d26 <TIM_Base_SetConfig+0x2e>
 8001d06:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8001d0a:	4290      	cmp	r0, r2
 8001d0c:	d00b      	beq.n	8001d26 <TIM_Base_SetConfig+0x2e>
 8001d0e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001d12:	4290      	cmp	r0, r2
 8001d14:	d007      	beq.n	8001d26 <TIM_Base_SetConfig+0x2e>
 8001d16:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001d1a:	4290      	cmp	r0, r2
 8001d1c:	d003      	beq.n	8001d26 <TIM_Base_SetConfig+0x2e>
 8001d1e:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8001d22:	4290      	cmp	r0, r2
 8001d24:	d11d      	bne.n	8001d62 <TIM_Base_SetConfig+0x6a>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
 8001d26:	684a      	ldr	r2, [r1, #4]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8001d28:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8001d2c:	4313      	orrs	r3, r2
  }
 
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
 8001d2e:	4a21      	ldr	r2, [pc, #132]	; (8001db4 <TIM_Base_SetConfig+0xbc>)
 8001d30:	4290      	cmp	r0, r2
 8001d32:	d104      	bne.n	8001d3e <TIM_Base_SetConfig+0x46>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8001d34:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8001d38:	68ca      	ldr	r2, [r1, #12]
 8001d3a:	4313      	orrs	r3, r2
 8001d3c:	e028      	b.n	8001d90 <TIM_Base_SetConfig+0x98>
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
 8001d3e:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8001d42:	d0f7      	beq.n	8001d34 <TIM_Base_SetConfig+0x3c>
 8001d44:	4a1c      	ldr	r2, [pc, #112]	; (8001db8 <TIM_Base_SetConfig+0xc0>)
 8001d46:	4290      	cmp	r0, r2
 8001d48:	d0f4      	beq.n	8001d34 <TIM_Base_SetConfig+0x3c>
 8001d4a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001d4e:	4290      	cmp	r0, r2
 8001d50:	d0f0      	beq.n	8001d34 <TIM_Base_SetConfig+0x3c>
 8001d52:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001d56:	4290      	cmp	r0, r2
 8001d58:	d0ec      	beq.n	8001d34 <TIM_Base_SetConfig+0x3c>
 8001d5a:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8001d5e:	4290      	cmp	r0, r2
 8001d60:	d0e8      	beq.n	8001d34 <TIM_Base_SetConfig+0x3c>
 8001d62:	4a16      	ldr	r2, [pc, #88]	; (8001dbc <TIM_Base_SetConfig+0xc4>)
 8001d64:	4290      	cmp	r0, r2
 8001d66:	d0e5      	beq.n	8001d34 <TIM_Base_SetConfig+0x3c>
 8001d68:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001d6c:	4290      	cmp	r0, r2
 8001d6e:	d0e1      	beq.n	8001d34 <TIM_Base_SetConfig+0x3c>
 8001d70:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001d74:	4290      	cmp	r0, r2
 8001d76:	d0dd      	beq.n	8001d34 <TIM_Base_SetConfig+0x3c>
 8001d78:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8001d7c:	4290      	cmp	r0, r2
 8001d7e:	d0d9      	beq.n	8001d34 <TIM_Base_SetConfig+0x3c>
 8001d80:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001d84:	4290      	cmp	r0, r2
 8001d86:	d0d5      	beq.n	8001d34 <TIM_Base_SetConfig+0x3c>
 8001d88:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001d8c:	4290      	cmp	r0, r2
 8001d8e:	d0d1      	beq.n	8001d34 <TIM_Base_SetConfig+0x3c>
  }

  TIMx->CR1 = tmpcr1;
 8001d90:	6003      	str	r3, [r0, #0]

  /* Set the Auto-reload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8001d92:	688b      	ldr	r3, [r1, #8]
 8001d94:	62c3      	str	r3, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8001d96:	680b      	ldr	r3, [r1, #0]
 8001d98:	6283      	str	r3, [r0, #40]	; 0x28
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
 8001d9a:	4b06      	ldr	r3, [pc, #24]	; (8001db4 <TIM_Base_SetConfig+0xbc>)
 8001d9c:	4298      	cmp	r0, r3
 8001d9e:	d006      	beq.n	8001dae <TIM_Base_SetConfig+0xb6>
 8001da0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001da4:	4298      	cmp	r0, r3
 8001da6:	d002      	beq.n	8001dae <TIM_Base_SetConfig+0xb6>
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8001da8:	2301      	movs	r3, #1
 8001daa:	6143      	str	r3, [r0, #20]
}
 8001dac:	4770      	bx	lr
    TIMx->RCR = Structure->RepetitionCounter;
 8001dae:	690b      	ldr	r3, [r1, #16]
 8001db0:	6303      	str	r3, [r0, #48]	; 0x30
 8001db2:	e7f9      	b.n	8001da8 <TIM_Base_SetConfig+0xb0>
 8001db4:	40010000 	.word	0x40010000
 8001db8:	40000400 	.word	0x40000400
 8001dbc:	40014000 	.word	0x40014000

08001dc0 <HAL_TIM_Base_Init>:
{ 
 8001dc0:	b510      	push	{r4, lr}
  if(htim == NULL)
 8001dc2:	4604      	mov	r4, r0
 8001dc4:	b180      	cbz	r0, 8001de8 <HAL_TIM_Base_Init+0x28>
  if(htim->State == HAL_TIM_STATE_RESET)
 8001dc6:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8001dca:	b90b      	cbnz	r3, 8001dd0 <HAL_TIM_Base_Init+0x10>
    HAL_TIM_Base_MspInit(htim);
 8001dcc:	f7ff fed4 	bl	8001b78 <HAL_TIM_Base_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;
 8001dd0:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 8001dd2:	6820      	ldr	r0, [r4, #0]
 8001dd4:	1d21      	adds	r1, r4, #4
  htim->State= HAL_TIM_STATE_BUSY;
 8001dd6:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 8001dda:	f7ff ff8d 	bl	8001cf8 <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8001dde:	2301      	movs	r3, #1
  return HAL_OK;
 8001de0:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
 8001de2:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  return HAL_OK;
 8001de6:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8001de8:	2001      	movs	r0, #1
}
 8001dea:	bd10      	pop	{r4, pc}

08001dec <HAL_TIMEx_CommutationCallback>:
 8001dec:	4770      	bx	lr

08001dee <HAL_TIMEx_BreakCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 8001dee:	4770      	bx	lr

08001df0 <UART_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
 8001df0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001df4:	9d06      	ldr	r5, [sp, #24]
 8001df6:	4604      	mov	r4, r0
 8001df8:	460f      	mov	r7, r1
 8001dfa:	4616      	mov	r6, r2
 8001dfc:	4698      	mov	r8, r3
  /* Wait until flag is set */
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8001dfe:	6821      	ldr	r1, [r4, #0]
 8001e00:	69ca      	ldr	r2, [r1, #28]
 8001e02:	ea37 0302 	bics.w	r3, r7, r2
 8001e06:	bf0c      	ite	eq
 8001e08:	2201      	moveq	r2, #1
 8001e0a:	2200      	movne	r2, #0
 8001e0c:	42b2      	cmp	r2, r6
 8001e0e:	d002      	beq.n	8001e16 <UART_WaitOnFlagUntilTimeout+0x26>
        __HAL_UNLOCK(huart);
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 8001e10:	2000      	movs	r0, #0
}
 8001e12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(Timeout != HAL_MAX_DELAY)
 8001e16:	1c6b      	adds	r3, r5, #1
 8001e18:	d0f2      	beq.n	8001e00 <UART_WaitOnFlagUntilTimeout+0x10>
      if((Timeout == 0U)||((HAL_GetTick()-Tickstart) >=  Timeout))
 8001e1a:	b99d      	cbnz	r5, 8001e44 <UART_WaitOnFlagUntilTimeout+0x54>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8001e1c:	6823      	ldr	r3, [r4, #0]
        __HAL_UNLOCK(huart);
 8001e1e:	2003      	movs	r0, #3
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8001e20:	681a      	ldr	r2, [r3, #0]
 8001e22:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 8001e26:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8001e28:	689a      	ldr	r2, [r3, #8]
 8001e2a:	f022 0201 	bic.w	r2, r2, #1
 8001e2e:	609a      	str	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
 8001e30:	2320      	movs	r3, #32
 8001e32:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
        huart->RxState = HAL_UART_STATE_READY;
 8001e36:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a
        __HAL_UNLOCK(huart);
 8001e3a:	2300      	movs	r3, #0
 8001e3c:	f884 3068 	strb.w	r3, [r4, #104]	; 0x68
 8001e40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if((Timeout == 0U)||((HAL_GetTick()-Tickstart) >=  Timeout))
 8001e44:	f7fe fa44 	bl	80002d0 <HAL_GetTick>
 8001e48:	eba0 0008 	sub.w	r0, r0, r8
 8001e4c:	4285      	cmp	r5, r0
 8001e4e:	d8d6      	bhi.n	8001dfe <UART_WaitOnFlagUntilTimeout+0xe>
 8001e50:	e7e4      	b.n	8001e1c <UART_WaitOnFlagUntilTimeout+0x2c>
	...

08001e54 <UART_SetConfig>:
  * @brief Configure the UART peripheral
  * @param huart: uart handle
  * @retval None
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8001e54:	b538      	push	{r3, r4, r5, lr}
 8001e56:	4604      	mov	r4, r0
   *  set the M bits according to huart->Init.WordLength value
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 8001e58:	6805      	ldr	r5, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8001e5a:	69c3      	ldr	r3, [r0, #28]
 8001e5c:	6921      	ldr	r1, [r4, #16]
 8001e5e:	68a2      	ldr	r2, [r4, #8]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 8001e60:	6828      	ldr	r0, [r5, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8001e62:	430a      	orrs	r2, r1
 8001e64:	6961      	ldr	r1, [r4, #20]
 8001e66:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 8001e68:	4994      	ldr	r1, [pc, #592]	; (80020bc <UART_SetConfig+0x268>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8001e6a:	431a      	orrs	r2, r3
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 8001e6c:	4001      	ands	r1, r0
  /* Configure
   * - UART HardWare Flow Control: set CTSE and RTSE bits according
   *   to huart->Init.HwFlowCtl value
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 8001e6e:	6a20      	ldr	r0, [r4, #32]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 8001e70:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8001e72:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 8001e74:	602a      	str	r2, [r5, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8001e76:	686a      	ldr	r2, [r5, #4]
 8001e78:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8001e7c:	430a      	orrs	r2, r1
 8001e7e:	606a      	str	r2, [r5, #4]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 8001e80:	69a2      	ldr	r2, [r4, #24]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 8001e82:	68a9      	ldr	r1, [r5, #8]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 8001e84:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 8001e86:	f421 6130 	bic.w	r1, r1, #2816	; 0xb00
 8001e8a:	430a      	orrs	r2, r1
 8001e8c:	60aa      	str	r2, [r5, #8]

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8001e8e:	4a8c      	ldr	r2, [pc, #560]	; (80020c0 <UART_SetConfig+0x26c>)
 8001e90:	4295      	cmp	r5, r2
 8001e92:	d119      	bne.n	8001ec8 <UART_SetConfig+0x74>
 8001e94:	f502 3294 	add.w	r2, r2, #75776	; 0x12800
 8001e98:	498a      	ldr	r1, [pc, #552]	; (80020c4 <UART_SetConfig+0x270>)
 8001e9a:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 8001e9e:	f002 0203 	and.w	r2, r2, #3
 8001ea2:	5c8a      	ldrb	r2, [r1, r2]

  /* Check UART Over Sampling to set Baud Rate Register */
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8001ea4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8001ea8:	f040 80b5 	bne.w	8002016 <UART_SetConfig+0x1c2>
  {
    switch (clocksource)
 8001eac:	2a08      	cmp	r2, #8
 8001eae:	f200 80af 	bhi.w	8002010 <UART_SetConfig+0x1bc>
 8001eb2:	e8df f012 	tbh	[pc, r2, lsl #1]
 8001eb6:	0028      	.short	0x0028
 8001eb8:	00eb007d 	.word	0x00eb007d
 8001ebc:	00f700ad 	.word	0x00f700ad
 8001ec0:	00ad00ad 	.word	0x00ad00ad
 8001ec4:	00fd00ad 	.word	0x00fd00ad
  UART_GETCLOCKSOURCE(huart, clocksource);
 8001ec8:	4a7f      	ldr	r2, [pc, #508]	; (80020c8 <UART_SetConfig+0x274>)
 8001eca:	4295      	cmp	r5, r2
 8001ecc:	d109      	bne.n	8001ee2 <UART_SetConfig+0x8e>
 8001ece:	f502 32fa 	add.w	r2, r2, #128000	; 0x1f400
 8001ed2:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
 8001ed6:	4a7b      	ldr	r2, [pc, #492]	; (80020c4 <UART_SetConfig+0x270>)
 8001ed8:	f001 010c 	and.w	r1, r1, #12
 8001edc:	440a      	add	r2, r1
 8001ede:	7912      	ldrb	r2, [r2, #4]
 8001ee0:	e7e0      	b.n	8001ea4 <UART_SetConfig+0x50>
 8001ee2:	4a7a      	ldr	r2, [pc, #488]	; (80020cc <UART_SetConfig+0x278>)
 8001ee4:	4295      	cmp	r5, r2
 8001ee6:	d12b      	bne.n	8001f40 <UART_SetConfig+0xec>
 8001ee8:	f502 32f8 	add.w	r2, r2, #126976	; 0x1f000
 8001eec:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 8001ef0:	f002 0230 	and.w	r2, r2, #48	; 0x30
 8001ef4:	2a10      	cmp	r2, #16
 8001ef6:	f000 80d2 	beq.w	800209e <UART_SetConfig+0x24a>
 8001efa:	d816      	bhi.n	8001f2a <UART_SetConfig+0xd6>
 8001efc:	b9da      	cbnz	r2, 8001f36 <UART_SetConfig+0xe2>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8001efe:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8001f02:	f040 809f 	bne.w	8002044 <UART_SetConfig+0x1f0>
    {
    case UART_CLOCKSOURCE_PCLK1:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8001f06:	f7ff fa47 	bl	8001398 <HAL_RCC_GetPCLK1Freq>
      break;
    case UART_CLOCKSOURCE_PCLK2:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8001f0a:	6861      	ldr	r1, [r4, #4]
 8001f0c:	084a      	lsrs	r2, r1, #1
 8001f0e:	eb02 0340 	add.w	r3, r2, r0, lsl #1
 8001f12:	fbb3 f3f1 	udiv	r3, r3, r1
 8001f16:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 8001f18:	2000      	movs	r0, #0
    default:
        ret = HAL_ERROR;
      break;
    }

    brrtemp = usartdiv & 0xFFF0U;
 8001f1a:	f023 020f 	bic.w	r2, r3, #15
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8001f1e:	f3c3 0342 	ubfx	r3, r3, #1, #3
    huart->Instance->BRR = brrtemp;
 8001f22:	6821      	ldr	r1, [r4, #0]
 8001f24:	4313      	orrs	r3, r2
 8001f26:	60cb      	str	r3, [r1, #12]
 8001f28:	bd38      	pop	{r3, r4, r5, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 8001f2a:	2a20      	cmp	r2, #32
 8001f2c:	f000 80ab 	beq.w	8002086 <UART_SetConfig+0x232>
 8001f30:	2a30      	cmp	r2, #48	; 0x30
 8001f32:	f000 80ba 	beq.w	80020aa <UART_SetConfig+0x256>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8001f36:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8001f3a:	d069      	beq.n	8002010 <UART_SetConfig+0x1bc>
    case UART_CLOCKSOURCE_LSE:
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
      break;
      case UART_CLOCKSOURCE_UNDEFINED:
    default:
        ret = HAL_ERROR;
 8001f3c:	2001      	movs	r0, #1
    }
  }

  return ret;

}
 8001f3e:	bd38      	pop	{r3, r4, r5, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 8001f40:	4a63      	ldr	r2, [pc, #396]	; (80020d0 <UART_SetConfig+0x27c>)
 8001f42:	4295      	cmp	r5, r2
 8001f44:	d10e      	bne.n	8001f64 <UART_SetConfig+0x110>
 8001f46:	f502 32f6 	add.w	r2, r2, #125952	; 0x1ec00
 8001f4a:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 8001f4e:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 8001f52:	2a40      	cmp	r2, #64	; 0x40
 8001f54:	f000 80a3 	beq.w	800209e <UART_SetConfig+0x24a>
 8001f58:	d9d0      	bls.n	8001efc <UART_SetConfig+0xa8>
 8001f5a:	2a80      	cmp	r2, #128	; 0x80
 8001f5c:	f000 8093 	beq.w	8002086 <UART_SetConfig+0x232>
 8001f60:	2ac0      	cmp	r2, #192	; 0xc0
 8001f62:	e7e6      	b.n	8001f32 <UART_SetConfig+0xde>
 8001f64:	4a5b      	ldr	r2, [pc, #364]	; (80020d4 <UART_SetConfig+0x280>)
 8001f66:	4295      	cmp	r5, r2
 8001f68:	d110      	bne.n	8001f8c <UART_SetConfig+0x138>
 8001f6a:	f502 32f4 	add.w	r2, r2, #124928	; 0x1e800
 8001f6e:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 8001f72:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8001f76:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8001f7a:	f000 8090 	beq.w	800209e <UART_SetConfig+0x24a>
 8001f7e:	d9bd      	bls.n	8001efc <UART_SetConfig+0xa8>
 8001f80:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8001f84:	d07f      	beq.n	8002086 <UART_SetConfig+0x232>
 8001f86:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 8001f8a:	e7d2      	b.n	8001f32 <UART_SetConfig+0xde>
 8001f8c:	4a52      	ldr	r2, [pc, #328]	; (80020d8 <UART_SetConfig+0x284>)
 8001f8e:	4295      	cmp	r5, r2
 8001f90:	d117      	bne.n	8001fc2 <UART_SetConfig+0x16e>
 8001f92:	f502 3292 	add.w	r2, r2, #74752	; 0x12400
 8001f96:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 8001f9a:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 8001f9e:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8001fa2:	d07c      	beq.n	800209e <UART_SetConfig+0x24a>
 8001fa4:	d807      	bhi.n	8001fb6 <UART_SetConfig+0x162>
 8001fa6:	2a00      	cmp	r2, #0
 8001fa8:	d1c5      	bne.n	8001f36 <UART_SetConfig+0xe2>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8001faa:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8001fae:	d154      	bne.n	800205a <UART_SetConfig+0x206>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8001fb0:	f7ff fa0a 	bl	80013c8 <HAL_RCC_GetPCLK2Freq>
 8001fb4:	e7a9      	b.n	8001f0a <UART_SetConfig+0xb6>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8001fb6:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 8001fba:	d064      	beq.n	8002086 <UART_SetConfig+0x232>
 8001fbc:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 8001fc0:	e7b7      	b.n	8001f32 <UART_SetConfig+0xde>
 8001fc2:	4a46      	ldr	r2, [pc, #280]	; (80020dc <UART_SetConfig+0x288>)
 8001fc4:	4295      	cmp	r5, r2
 8001fc6:	d10f      	bne.n	8001fe8 <UART_SetConfig+0x194>
 8001fc8:	f502 32e0 	add.w	r2, r2, #114688	; 0x1c000
 8001fcc:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 8001fd0:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
 8001fd4:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 8001fd8:	d061      	beq.n	800209e <UART_SetConfig+0x24a>
 8001fda:	d98f      	bls.n	8001efc <UART_SetConfig+0xa8>
 8001fdc:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8001fe0:	d051      	beq.n	8002086 <UART_SetConfig+0x232>
 8001fe2:	f5b2 5f40 	cmp.w	r2, #12288	; 0x3000
 8001fe6:	e7a4      	b.n	8001f32 <UART_SetConfig+0xde>
 8001fe8:	4a3d      	ldr	r2, [pc, #244]	; (80020e0 <UART_SetConfig+0x28c>)
 8001fea:	4295      	cmp	r5, r2
 8001fec:	d1a3      	bne.n	8001f36 <UART_SetConfig+0xe2>
 8001fee:	f502 32de 	add.w	r2, r2, #113664	; 0x1bc00
 8001ff2:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 8001ff6:	f402 4240 	and.w	r2, r2, #49152	; 0xc000
 8001ffa:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
 8001ffe:	d04e      	beq.n	800209e <UART_SetConfig+0x24a>
 8002000:	f67f af7c 	bls.w	8001efc <UART_SetConfig+0xa8>
 8002004:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8002008:	d03d      	beq.n	8002086 <UART_SetConfig+0x232>
 800200a:	f5b2 4f40 	cmp.w	r2, #49152	; 0xc000
 800200e:	e790      	b.n	8001f32 <UART_SetConfig+0xde>
        ret = HAL_ERROR;
 8002010:	2001      	movs	r0, #1
  uint16_t usartdiv                   = 0x0000U;
 8002012:	2300      	movs	r3, #0
 8002014:	e781      	b.n	8001f1a <UART_SetConfig+0xc6>
    switch (clocksource)
 8002016:	2a08      	cmp	r2, #8
 8002018:	d890      	bhi.n	8001f3c <UART_SetConfig+0xe8>
 800201a:	a301      	add	r3, pc, #4	; (adr r3, 8002020 <UART_SetConfig+0x1cc>)
 800201c:	f853 f022 	ldr.w	pc, [r3, r2, lsl #2]
 8002020:	08002045 	.word	0x08002045
 8002024:	0800205b 	.word	0x0800205b
 8002028:	08002061 	.word	0x08002061
 800202c:	08001f3d 	.word	0x08001f3d
 8002030:	08002077 	.word	0x08002077
 8002034:	08001f3d 	.word	0x08001f3d
 8002038:	08001f3d 	.word	0x08001f3d
 800203c:	08001f3d 	.word	0x08001f3d
 8002040:	0800207d 	.word	0x0800207d
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8002044:	f7ff f9a8 	bl	8001398 <HAL_RCC_GetPCLK1Freq>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8002048:	6863      	ldr	r3, [r4, #4]
 800204a:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 800204e:	fbb0 f0f3 	udiv	r0, r0, r3
 8002052:	b280      	uxth	r0, r0
 8002054:	60e8      	str	r0, [r5, #12]
  HAL_StatusTypeDef ret               = HAL_OK;
 8002056:	2000      	movs	r0, #0
      break;
 8002058:	bd38      	pop	{r3, r4, r5, pc}
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 800205a:	f7ff f9b5 	bl	80013c8 <HAL_RCC_GetPCLK2Freq>
 800205e:	e7f3      	b.n	8002048 <UART_SetConfig+0x1f4>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 8002060:	6862      	ldr	r2, [r4, #4]
 8002062:	0853      	lsrs	r3, r2, #1
 8002064:	f503 0374 	add.w	r3, r3, #15990784	; 0xf40000
 8002068:	f503 5310 	add.w	r3, r3, #9216	; 0x2400
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 800206c:	fbb3 f3f2 	udiv	r3, r3, r2
 8002070:	b29b      	uxth	r3, r3
 8002072:	60eb      	str	r3, [r5, #12]
 8002074:	e7ef      	b.n	8002056 <UART_SetConfig+0x202>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8002076:	f7ff f8a3 	bl	80011c0 <HAL_RCC_GetSysClockFreq>
 800207a:	e7e5      	b.n	8002048 <UART_SetConfig+0x1f4>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 800207c:	6862      	ldr	r2, [r4, #4]
 800207e:	0853      	lsrs	r3, r2, #1
 8002080:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
 8002084:	e7f2      	b.n	800206c <UART_SetConfig+0x218>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8002086:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800208a:	d1e9      	bne.n	8002060 <UART_SetConfig+0x20c>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 800208c:	6860      	ldr	r0, [r4, #4]
 800208e:	0843      	lsrs	r3, r0, #1
 8002090:	f103 73f4 	add.w	r3, r3, #31981568	; 0x1e80000
 8002094:	f503 4390 	add.w	r3, r3, #18432	; 0x4800
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 8002098:	fbb3 f3f0 	udiv	r3, r3, r0
 800209c:	e73b      	b.n	8001f16 <UART_SetConfig+0xc2>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800209e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80020a2:	d1e8      	bne.n	8002076 <UART_SetConfig+0x222>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 80020a4:	f7ff f88c 	bl	80011c0 <HAL_RCC_GetSysClockFreq>
 80020a8:	e72f      	b.n	8001f0a <UART_SetConfig+0xb6>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80020aa:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80020ae:	d1e5      	bne.n	800207c <UART_SetConfig+0x228>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 80020b0:	6860      	ldr	r0, [r4, #4]
 80020b2:	0843      	lsrs	r3, r0, #1
 80020b4:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 80020b8:	e7ee      	b.n	8002098 <UART_SetConfig+0x244>
 80020ba:	bf00      	nop
 80020bc:	efff69f3 	.word	0xefff69f3
 80020c0:	40011000 	.word	0x40011000
 80020c4:	08009c58 	.word	0x08009c58
 80020c8:	40004400 	.word	0x40004400
 80020cc:	40004800 	.word	0x40004800
 80020d0:	40004c00 	.word	0x40004c00
 80020d4:	40005000 	.word	0x40005000
 80020d8:	40011400 	.word	0x40011400
 80020dc:	40007800 	.word	0x40007800
 80020e0:	40007c00 	.word	0x40007c00

080020e4 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80020e4:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80020e6:	07da      	lsls	r2, r3, #31
{
 80020e8:	b510      	push	{r4, lr}
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80020ea:	d506      	bpl.n	80020fa <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 80020ec:	6801      	ldr	r1, [r0, #0]
 80020ee:	6a84      	ldr	r4, [r0, #40]	; 0x28
 80020f0:	684a      	ldr	r2, [r1, #4]
 80020f2:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 80020f6:	4322      	orrs	r2, r4
 80020f8:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 80020fa:	079c      	lsls	r4, r3, #30
 80020fc:	d506      	bpl.n	800210c <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 80020fe:	6801      	ldr	r1, [r0, #0]
 8002100:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 8002102:	684a      	ldr	r2, [r1, #4]
 8002104:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002108:	4322      	orrs	r2, r4
 800210a:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800210c:	0759      	lsls	r1, r3, #29
 800210e:	d506      	bpl.n	800211e <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8002110:	6801      	ldr	r1, [r0, #0]
 8002112:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8002114:	684a      	ldr	r2, [r1, #4]
 8002116:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800211a:	4322      	orrs	r2, r4
 800211c:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800211e:	071a      	lsls	r2, r3, #28
 8002120:	d506      	bpl.n	8002130 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8002122:	6801      	ldr	r1, [r0, #0]
 8002124:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8002126:	684a      	ldr	r2, [r1, #4]
 8002128:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800212c:	4322      	orrs	r2, r4
 800212e:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8002130:	06dc      	lsls	r4, r3, #27
 8002132:	d506      	bpl.n	8002142 <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8002134:	6801      	ldr	r1, [r0, #0]
 8002136:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8002138:	688a      	ldr	r2, [r1, #8]
 800213a:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800213e:	4322      	orrs	r2, r4
 8002140:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8002142:	0699      	lsls	r1, r3, #26
 8002144:	d506      	bpl.n	8002154 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8002146:	6801      	ldr	r1, [r0, #0]
 8002148:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 800214a:	688a      	ldr	r2, [r1, #8]
 800214c:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8002150:	4322      	orrs	r2, r4
 8002152:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8002154:	065a      	lsls	r2, r3, #25
 8002156:	d510      	bpl.n	800217a <UART_AdvFeatureConfig+0x96>
  {
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8002158:	6801      	ldr	r1, [r0, #0]
 800215a:	6c04      	ldr	r4, [r0, #64]	; 0x40
 800215c:	684a      	ldr	r2, [r1, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800215e:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8002162:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 8002166:	ea42 0204 	orr.w	r2, r2, r4
 800216a:	604a      	str	r2, [r1, #4]
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800216c:	d105      	bne.n	800217a <UART_AdvFeatureConfig+0x96>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800216e:	684a      	ldr	r2, [r1, #4]
 8002170:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8002172:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 8002176:	4322      	orrs	r2, r4
 8002178:	604a      	str	r2, [r1, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800217a:	061b      	lsls	r3, r3, #24
 800217c:	d506      	bpl.n	800218c <UART_AdvFeatureConfig+0xa8>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800217e:	6802      	ldr	r2, [r0, #0]
 8002180:	6c81      	ldr	r1, [r0, #72]	; 0x48
 8002182:	6853      	ldr	r3, [r2, #4]
 8002184:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8002188:	430b      	orrs	r3, r1
 800218a:	6053      	str	r3, [r2, #4]
 800218c:	bd10      	pop	{r4, pc}

0800218e <UART_CheckIdleState>:
  * @brief Check the UART Idle State
  * @param huart: uart handle
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 800218e:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint32_t tickstart = 0U;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002190:	2600      	movs	r6, #0
{
 8002192:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002194:	66c6      	str	r6, [r0, #108]	; 0x6c

  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
 8002196:	f7fe f89b 	bl	80002d0 <HAL_GetTick>

  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800219a:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 800219c:	4605      	mov	r5, r0
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800219e:	681b      	ldr	r3, [r3, #0]
 80021a0:	071a      	lsls	r2, r3, #28
 80021a2:	d417      	bmi.n	80021d4 <UART_CheckIdleState+0x46>
      /* Timeout Occurred */
      return HAL_TIMEOUT;
    }
  }
  /* Check if the Receiver is enabled */
  if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 80021a4:	6823      	ldr	r3, [r4, #0]
 80021a6:	681b      	ldr	r3, [r3, #0]
 80021a8:	075b      	lsls	r3, r3, #29
 80021aa:	d50a      	bpl.n	80021c2 <UART_CheckIdleState+0x34>
  {
    /* Wait until REACK flag is set */
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80021ac:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 80021b0:	2200      	movs	r2, #0
 80021b2:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 80021b6:	4620      	mov	r0, r4
 80021b8:	9300      	str	r3, [sp, #0]
 80021ba:	462b      	mov	r3, r5
 80021bc:	f7ff fe18 	bl	8001df0 <UART_WaitOnFlagUntilTimeout>
 80021c0:	b9a0      	cbnz	r0, 80021ec <UART_CheckIdleState+0x5e>
      return HAL_TIMEOUT;
    }
  }

  /* Initialize the UART State */
  huart->gState= HAL_UART_STATE_READY;
 80021c2:	2320      	movs	r3, #32
  huart->RxState= HAL_UART_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 80021c4:	2000      	movs	r0, #0
  huart->gState= HAL_UART_STATE_READY;
 80021c6:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
  __HAL_UNLOCK(huart);
 80021ca:	f884 0068 	strb.w	r0, [r4, #104]	; 0x68
  huart->RxState= HAL_UART_STATE_READY;
 80021ce:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a

  return HAL_OK;
 80021d2:	e00c      	b.n	80021ee <UART_CheckIdleState+0x60>
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80021d4:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 80021d8:	4632      	mov	r2, r6
 80021da:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 80021de:	9300      	str	r3, [sp, #0]
 80021e0:	4603      	mov	r3, r0
 80021e2:	4620      	mov	r0, r4
 80021e4:	f7ff fe04 	bl	8001df0 <UART_WaitOnFlagUntilTimeout>
 80021e8:	2800      	cmp	r0, #0
 80021ea:	d0db      	beq.n	80021a4 <UART_CheckIdleState+0x16>
      return HAL_TIMEOUT;
 80021ec:	2003      	movs	r0, #3
}
 80021ee:	b002      	add	sp, #8
 80021f0:	bd70      	pop	{r4, r5, r6, pc}

080021f2 <HAL_UART_Init>:
{
 80021f2:	b510      	push	{r4, lr}
  if(huart == NULL)
 80021f4:	4604      	mov	r4, r0
 80021f6:	b360      	cbz	r0, 8002252 <HAL_UART_Init+0x60>
  if(huart->gState == HAL_UART_STATE_RESET)
 80021f8:	f890 3069 	ldrb.w	r3, [r0, #105]	; 0x69
 80021fc:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002200:	b91b      	cbnz	r3, 800220a <HAL_UART_Init+0x18>
    huart->Lock = HAL_UNLOCKED;
 8002202:	f880 2068 	strb.w	r2, [r0, #104]	; 0x68
    HAL_UART_MspInit(huart);
 8002206:	f007 fb85 	bl	8009914 <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
 800220a:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 800220c:	2324      	movs	r3, #36	; 0x24
  if (UART_SetConfig(huart) == HAL_ERROR)
 800220e:	4620      	mov	r0, r4
  huart->gState = HAL_UART_STATE_BUSY;
 8002210:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
  __HAL_UART_DISABLE(huart);
 8002214:	6813      	ldr	r3, [r2, #0]
 8002216:	f023 0301 	bic.w	r3, r3, #1
 800221a:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 800221c:	f7ff fe1a 	bl	8001e54 <UART_SetConfig>
 8002220:	2801      	cmp	r0, #1
 8002222:	d016      	beq.n	8002252 <HAL_UART_Init+0x60>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8002224:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002226:	b113      	cbz	r3, 800222e <HAL_UART_Init+0x3c>
    UART_AdvFeatureConfig(huart);
 8002228:	4620      	mov	r0, r4
 800222a:	f7ff ff5b 	bl	80020e4 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800222e:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
 8002230:	4620      	mov	r0, r4
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8002232:	685a      	ldr	r2, [r3, #4]
 8002234:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8002238:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800223a:	689a      	ldr	r2, [r3, #8]
 800223c:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8002240:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 8002242:	681a      	ldr	r2, [r3, #0]
 8002244:	f042 0201 	orr.w	r2, r2, #1
}
 8002248:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  __HAL_UART_ENABLE(huart);
 800224c:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 800224e:	f7ff bf9e 	b.w	800218e <UART_CheckIdleState>
}
 8002252:	2001      	movs	r0, #1
 8002254:	bd10      	pop	{r4, pc}

08002256 <USB_CoreInit>:
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8002256:	b084      	sub	sp, #16
 8002258:	b538      	push	{r3, r4, r5, lr}
 800225a:	ad05      	add	r5, sp, #20
 800225c:	4604      	mov	r4, r0
 800225e:	e885 000e 	stmia.w	r5, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8002262:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002264:	2b01      	cmp	r3, #1
 8002266:	d127      	bne.n	80022b8 <USB_CoreInit+0x62>
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8002268:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800226a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800226e:	6383      	str	r3, [r0, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 8002270:	68c3      	ldr	r3, [r0, #12]
 8002272:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 8002276:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800227a:	60c3      	str	r3, [r0, #12]
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 800227c:	68c3      	ldr	r3, [r0, #12]
 800227e:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8002282:	60c3      	str	r3, [r0, #12]
    if(cfg.use_external_vbus == 1)
 8002284:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8002286:	2b01      	cmp	r3, #1
 8002288:	d103      	bne.n	8002292 <USB_CoreInit+0x3c>
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 800228a:	68c3      	ldr	r3, [r0, #12]
 800228c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8002290:	60c3      	str	r3, [r0, #12]
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
 8002292:	4620      	mov	r0, r4
 8002294:	f000 f914 	bl	80024c0 <USB_CoreReset>
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  }
 
  if(cfg.dma_enable == ENABLE)
 8002298:	9b08      	ldr	r3, [sp, #32]
 800229a:	2b01      	cmp	r3, #1
 800229c:	d107      	bne.n	80022ae <USB_CoreInit+0x58>
  {
    USBx->GAHBCFG |= (USB_OTG_GAHBCFG_HBSTLEN_1 | USB_OTG_GAHBCFG_HBSTLEN_2);
 800229e:	68a3      	ldr	r3, [r4, #8]
 80022a0:	f043 030c 	orr.w	r3, r3, #12
 80022a4:	60a3      	str	r3, [r4, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 80022a6:	68a3      	ldr	r3, [r4, #8]
 80022a8:	f043 0320 	orr.w	r3, r3, #32
 80022ac:	60a3      	str	r3, [r4, #8]
  }  

  return HAL_OK;
}
 80022ae:	2000      	movs	r0, #0
 80022b0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80022b4:	b004      	add	sp, #16
 80022b6:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 80022b8:	68c3      	ldr	r3, [r0, #12]
 80022ba:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80022be:	60c3      	str	r3, [r0, #12]
    USB_CoreReset(USBx);
 80022c0:	f000 f8fe 	bl	80024c0 <USB_CoreReset>
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
 80022c4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80022c8:	63a3      	str	r3, [r4, #56]	; 0x38
 80022ca:	e7e5      	b.n	8002298 <USB_CoreInit+0x42>

080022cc <USB_DisableGlobalInt>:
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 80022cc:	6883      	ldr	r3, [r0, #8]
 80022ce:	f023 0301 	bic.w	r3, r3, #1
 80022d2:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 80022d4:	2000      	movs	r0, #0
 80022d6:	4770      	bx	lr

080022d8 <USB_SetCurrentMode>:
  *            @arg USB_OTG_HOST_MODE: Host mode
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
 80022d8:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 80022da:	68c3      	ldr	r3, [r0, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
 80022dc:	2901      	cmp	r1, #1
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 80022de:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 80022e2:	60c3      	str	r3, [r0, #12]
  if ( mode == USB_OTG_HOST_MODE)
 80022e4:	d108      	bne.n	80022f8 <USB_SetCurrentMode+0x20>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
 80022e6:	68c3      	ldr	r3, [r0, #12]
 80022e8:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80022ec:	60c3      	str	r3, [r0, #12]
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
  }
  HAL_Delay(50);
 80022ee:	2032      	movs	r0, #50	; 0x32
 80022f0:	f7fd fff4 	bl	80002dc <HAL_Delay>
  
  return HAL_OK;
}
 80022f4:	2000      	movs	r0, #0
 80022f6:	bd08      	pop	{r3, pc}
  else if ( mode == USB_OTG_DEVICE_MODE)
 80022f8:	2900      	cmp	r1, #0
 80022fa:	d1f8      	bne.n	80022ee <USB_SetCurrentMode+0x16>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
 80022fc:	68c3      	ldr	r3, [r0, #12]
 80022fe:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8002302:	60c3      	str	r3, [r0, #12]
 8002304:	e7f3      	b.n	80022ee <USB_SetCurrentMode+0x16>
	...

08002308 <USB_DevInit>:
  * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8002308:	b084      	sub	sp, #16
 800230a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800230e:	4604      	mov	r4, r0
 8002310:	a807      	add	r0, sp, #28
 8002312:	4688      	mov	r8, r1
 8002314:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  uint32_t i = 0;

  /*Activate VBUS Sensing B */
  USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
 8002318:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800231a:	9e10      	ldr	r6, [sp, #64]	; 0x40
 800231c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8002320:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8002322:	63a3      	str	r3, [r4, #56]	; 0x38
  
  if (cfg.vbus_sensing_enable == 0)
 8002324:	b95e      	cbnz	r6, 800233e <USB_DevInit+0x36>
  {
    /* Deactivate VBUS Sensing B */
    USBx->GCCFG &= ~ USB_OTG_GCCFG_VBDEN;
 8002326:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002328:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800232c:	63a3      	str	r3, [r4, #56]	; 0x38
    
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
 800232e:	6823      	ldr	r3, [r4, #0]
 8002330:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002334:	6023      	str	r3, [r4, #0]
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
 8002336:	6823      	ldr	r3, [r4, #0]
 8002338:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800233c:	6023      	str	r3, [r4, #0]
  }
   
  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0;
 800233e:	2300      	movs	r3, #0

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8002340:	f504 6500 	add.w	r5, r4, #2048	; 0x800
  USBx_PCGCCTL = 0;
 8002344:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8002348:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
 800234c:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
 8002350:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8002352:	2b01      	cmp	r3, #1
 8002354:	d15a      	bne.n	800240c <USB_DevInit+0x104>
  {
    if(cfg.speed == USB_OTG_SPEED_HIGH)
 8002356:	9909      	ldr	r1, [sp, #36]	; 0x24
 8002358:	b919      	cbnz	r1, 8002362 <USB_DevInit+0x5a>
    }
  }
  else
  {
    /* Set Full speed phy */
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 800235a:	4620      	mov	r0, r4
 800235c:	f000 f89c 	bl	8002498 <USB_SetDevSpeed>
 8002360:	e003      	b.n	800236a <USB_DevInit+0x62>
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
 8002362:	4619      	mov	r1, r3
 8002364:	4620      	mov	r0, r4
 8002366:	f000 f897 	bl	8002498 <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10); /* all Tx FIFOs */
 800236a:	2110      	movs	r1, #16
 800236c:	4620      	mov	r0, r4
 800236e:	f000 f871 	bl	8002454 <USB_FlushTxFifo>
  USB_FlushRxFifo(USBx);
 8002372:	4620      	mov	r0, r4
 8002374:	f000 f880 	bl	8002478 <USB_FlushRxFifo>
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0;
 8002378:	2300      	movs	r3, #0
  USBx_DEVICE->DOEPMSK = 0;
  USBx_DEVICE->DAINT = 0xFFFFFFFF;
 800237a:	f04f 32ff 	mov.w	r2, #4294967295
  
  for (i = 0; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 800237e:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  USBx_DEVICE->DIEPMSK = 0;
 8002382:	612b      	str	r3, [r5, #16]
 8002384:	4619      	mov	r1, r3
  USBx_DEVICE->DOEPMSK = 0;
 8002386:	616b      	str	r3, [r5, #20]
    {
      USBx_INEP(i)->DIEPCTL = 0;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0;
    USBx_INEP(i)->DIEPINT  = 0xFF;
 8002388:	f04f 0eff 	mov.w	lr, #255	; 0xff
  USBx_DEVICE->DAINT = 0xFFFFFFFF;
 800238c:	61aa      	str	r2, [r5, #24]
 800238e:	f504 6210 	add.w	r2, r4, #2304	; 0x900
  USBx_DEVICE->DAINTMSK = 0;
 8002392:	61eb      	str	r3, [r5, #28]
  for (i = 0; i < cfg.dev_endpoints; i++)
 8002394:	4543      	cmp	r3, r8
 8002396:	d13b      	bne.n	8002410 <USB_DevInit+0x108>
 8002398:	2100      	movs	r1, #0
 800239a:	f504 6230 	add.w	r2, r4, #2816	; 0xb00
  
  for (i = 0; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 800239e:	f04f 4e90 	mov.w	lr, #1207959552	; 0x48000000
    {
      USBx_OUTEP(i)->DOEPCTL = 0;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0;
    USBx_OUTEP(i)->DOEPINT  = 0xFF;
 80023a2:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80023a6:	4608      	mov	r0, r1
  for (i = 0; i < cfg.dev_endpoints; i++)
 80023a8:	428b      	cmp	r3, r1
 80023aa:	d13f      	bne.n	800242c <USB_DevInit+0x124>
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 80023ac:	692b      	ldr	r3, [r5, #16]
  
  if (cfg.dma_enable == 1)
 80023ae:	2f01      	cmp	r7, #1
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 80023b0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80023b4:	612b      	str	r3, [r5, #16]
  if (cfg.dma_enable == 1)
 80023b6:	d108      	bne.n	80023ca <USB_DevInit+0xc2>
  {
    /*Set threshold parameters */
    USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
 80023b8:	4b24      	ldr	r3, [pc, #144]	; (800244c <USB_DevInit+0x144>)
 80023ba:	632b      	str	r3, [r5, #48]	; 0x30
    USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
 80023bc:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80023be:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80023c2:	f043 0303 	orr.w	r3, r3, #3
 80023c6:	632b      	str	r3, [r5, #48]	; 0x30
    
    i= USBx_DEVICE->DTHRCTL;
 80023c8:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0;
 80023ca:	2300      	movs	r3, #0
 80023cc:	61a3      	str	r3, [r4, #24]
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFF;
 80023ce:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 80023d2:	6163      	str	r3, [r4, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == DISABLE)
 80023d4:	b91f      	cbnz	r7, 80023de <USB_DevInit+0xd6>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
 80023d6:	69a3      	ldr	r3, [r4, #24]
 80023d8:	f043 0310 	orr.w	r3, r3, #16
 80023dc:	61a3      	str	r3, [r4, #24]
  }
  
  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
 80023de:	69a2      	ldr	r2, [r4, #24]
 80023e0:	4b1b      	ldr	r3, [pc, #108]	; (8002450 <USB_DevInit+0x148>)
 80023e2:	4313      	orrs	r3, r2
 80023e4:	61a3      	str	r3, [r4, #24]
                    USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
                    USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
  
  if(cfg.Sof_enable)
 80023e6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80023e8:	b11b      	cbz	r3, 80023f2 <USB_DevInit+0xea>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 80023ea:	69a3      	ldr	r3, [r4, #24]
 80023ec:	f043 0308 	orr.w	r3, r3, #8
 80023f0:	61a3      	str	r3, [r4, #24]
  }

  if (cfg.vbus_sensing_enable == ENABLE)
 80023f2:	2e01      	cmp	r6, #1
 80023f4:	d105      	bne.n	8002402 <USB_DevInit+0xfa>
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
 80023f6:	69a3      	ldr	r3, [r4, #24]
 80023f8:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80023fc:	f043 0304 	orr.w	r3, r3, #4
 8002400:	61a3      	str	r3, [r4, #24]
  }
  
  return HAL_OK;
}
 8002402:	2000      	movs	r0, #0
 8002404:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8002408:	b004      	add	sp, #16
 800240a:	4770      	bx	lr
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 800240c:	2103      	movs	r1, #3
 800240e:	e7a4      	b.n	800235a <USB_DevInit+0x52>
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8002410:	f8d2 c000 	ldr.w	ip, [r2]
 8002414:	f1bc 0f00 	cmp.w	ip, #0
 8002418:	da06      	bge.n	8002428 <USB_DevInit+0x120>
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 800241a:	6010      	str	r0, [r2, #0]
    USBx_INEP(i)->DIEPTSIZ = 0;
 800241c:	6111      	str	r1, [r2, #16]
  for (i = 0; i < cfg.dev_endpoints; i++)
 800241e:	3301      	adds	r3, #1
    USBx_INEP(i)->DIEPINT  = 0xFF;
 8002420:	f8c2 e008 	str.w	lr, [r2, #8]
 8002424:	3220      	adds	r2, #32
 8002426:	e7b5      	b.n	8002394 <USB_DevInit+0x8c>
      USBx_INEP(i)->DIEPCTL = 0;
 8002428:	6011      	str	r1, [r2, #0]
 800242a:	e7f7      	b.n	800241c <USB_DevInit+0x114>
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 800242c:	f8d2 8000 	ldr.w	r8, [r2]
 8002430:	f1b8 0f00 	cmp.w	r8, #0
 8002434:	da07      	bge.n	8002446 <USB_DevInit+0x13e>
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 8002436:	f8c2 e000 	str.w	lr, [r2]
    USBx_OUTEP(i)->DOEPTSIZ = 0;
 800243a:	6110      	str	r0, [r2, #16]
  for (i = 0; i < cfg.dev_endpoints; i++)
 800243c:	3101      	adds	r1, #1
    USBx_OUTEP(i)->DOEPINT  = 0xFF;
 800243e:	f8c2 c008 	str.w	ip, [r2, #8]
 8002442:	3220      	adds	r2, #32
 8002444:	e7b0      	b.n	80023a8 <USB_DevInit+0xa0>
      USBx_OUTEP(i)->DOEPCTL = 0;
 8002446:	6010      	str	r0, [r2, #0]
 8002448:	e7f7      	b.n	800243a <USB_DevInit+0x132>
 800244a:	bf00      	nop
 800244c:	00800100 	.word	0x00800100
 8002450:	803c3800 	.word	0x803c3800

08002454 <USB_FlushTxFifo>:
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0;
 
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 8002454:	0189      	lsls	r1, r1, #6
 8002456:	4a07      	ldr	r2, [pc, #28]	; (8002474 <USB_FlushTxFifo+0x20>)
 8002458:	f041 0120 	orr.w	r1, r1, #32
 800245c:	6101      	str	r1, [r0, #16]
 
  do
  {
    if (++count > 200000)
 800245e:	3a01      	subs	r2, #1
 8002460:	d005      	beq.n	800246e <USB_FlushTxFifo+0x1a>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8002462:	6903      	ldr	r3, [r0, #16]
 8002464:	f013 0320 	ands.w	r3, r3, #32
 8002468:	d1f9      	bne.n	800245e <USB_FlushTxFifo+0xa>
  
  return HAL_OK;
 800246a:	4618      	mov	r0, r3
 800246c:	4770      	bx	lr
      return HAL_TIMEOUT;
 800246e:	2003      	movs	r0, #3
}
 8002470:	4770      	bx	lr
 8002472:	bf00      	nop
 8002474:	00030d41 	.word	0x00030d41

08002478 <USB_FlushRxFifo>:
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8002478:	2310      	movs	r3, #16
 800247a:	4a06      	ldr	r2, [pc, #24]	; (8002494 <USB_FlushRxFifo+0x1c>)
 800247c:	6103      	str	r3, [r0, #16]
  
  do
  {
    if (++count > 200000)
 800247e:	3a01      	subs	r2, #1
 8002480:	d005      	beq.n	800248e <USB_FlushRxFifo+0x16>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8002482:	6903      	ldr	r3, [r0, #16]
 8002484:	f013 0310 	ands.w	r3, r3, #16
 8002488:	d1f9      	bne.n	800247e <USB_FlushRxFifo+0x6>
  
  return HAL_OK;
 800248a:	4618      	mov	r0, r3
 800248c:	4770      	bx	lr
      return HAL_TIMEOUT;
 800248e:	2003      	movs	r0, #3
}
 8002490:	4770      	bx	lr
 8002492:	bf00      	nop
 8002494:	00030d41 	.word	0x00030d41

08002498 <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
  USBx_DEVICE->DCFG |= speed;
 8002498:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 800249c:	4319      	orrs	r1, r3
 800249e:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
  return HAL_OK;
}
 80024a2:	2000      	movs	r0, #0
 80024a4:	4770      	bx	lr

080024a6 <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling the pull-up/pull-down
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)
{
 80024a6:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ;
 80024a8:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 80024ac:	f043 0302 	orr.w	r3, r3, #2
 80024b0:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3);
 80024b4:	2003      	movs	r0, #3
 80024b6:	f7fd ff11 	bl	80002dc <HAL_Delay>
  
  return HAL_OK;  
}
 80024ba:	2000      	movs	r0, #0
 80024bc:	bd08      	pop	{r3, pc}
	...

080024c0 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx : Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 80024c0:	4b0a      	ldr	r3, [pc, #40]	; (80024ec <USB_CoreReset+0x2c>)
  uint32_t count = 0;

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000)
 80024c2:	3b01      	subs	r3, #1
 80024c4:	d101      	bne.n	80024ca <USB_CoreReset+0xa>
    {
      return HAL_TIMEOUT;
 80024c6:	2003      	movs	r0, #3
 80024c8:	4770      	bx	lr
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0);
 80024ca:	6902      	ldr	r2, [r0, #16]
 80024cc:	2a00      	cmp	r2, #0
 80024ce:	daf8      	bge.n	80024c2 <USB_CoreReset+0x2>
  
  /* Core Soft Reset */
  count = 0;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 80024d0:	6903      	ldr	r3, [r0, #16]
 80024d2:	4a06      	ldr	r2, [pc, #24]	; (80024ec <USB_CoreReset+0x2c>)
 80024d4:	f043 0301 	orr.w	r3, r3, #1
 80024d8:	6103      	str	r3, [r0, #16]

  do
  {
    if (++count > 200000)
 80024da:	3a01      	subs	r2, #1
 80024dc:	d0f3      	beq.n	80024c6 <USB_CoreReset+0x6>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 80024de:	6903      	ldr	r3, [r0, #16]
 80024e0:	f013 0301 	ands.w	r3, r3, #1
 80024e4:	d1f9      	bne.n	80024da <USB_CoreReset+0x1a>
  
  return HAL_OK;
 80024e6:	4618      	mov	r0, r3
}
 80024e8:	4770      	bx	lr
 80024ea:	bf00      	nop
 80024ec:	00030d41 	.word	0x00030d41

080024f0 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 80024f0:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 80024f2:	f000 ffdb 	bl	80034ac <vTaskStartScheduler>
  
  return osOK;
}
 80024f6:	2000      	movs	r0, #0
 80024f8:	bd08      	pop	{r3, pc}

080024fa <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 80024fa:	b570      	push	{r4, r5, r6, lr}
  TaskHandle_t handle;
  
  
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 80024fc:	f9b0 4008 	ldrsh.w	r4, [r0, #8]
{
 8002500:	b086      	sub	sp, #24
 8002502:	2500      	movs	r5, #0
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8002504:	8a02      	ldrh	r2, [r0, #16]
  if (priority != osPriorityError) {
 8002506:	2c84      	cmp	r4, #132	; 0x84
{
 8002508:	460b      	mov	r3, r1
    fpriority += (priority - osPriorityIdle);
 800250a:	bf14      	ite	ne
 800250c:	3403      	addne	r4, #3
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 800250e:	462c      	moveq	r4, r5
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8002510:	e890 0042 	ldmia.w	r0, {r1, r6}
 8002514:	a805      	add	r0, sp, #20
 8002516:	9503      	str	r5, [sp, #12]
 8002518:	9502      	str	r5, [sp, #8]
 800251a:	9001      	str	r0, [sp, #4]
 800251c:	4630      	mov	r0, r6
 800251e:	9400      	str	r4, [sp, #0]
 8002520:	f000 ffa1 	bl	8003466 <xTaskGenericCreate>
 8002524:	2801      	cmp	r0, #1
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              &handle) != pdPASS)  {
    return NULL;
  }
  
  return handle;
 8002526:	bf0c      	ite	eq
 8002528:	9805      	ldreq	r0, [sp, #20]
    return NULL;
 800252a:	2000      	movne	r0, #0
}
 800252c:	b006      	add	sp, #24
 800252e:	bd70      	pop	{r4, r5, r6, pc}

08002530 <osDelay>:
osStatus osDelay (uint32_t millisec)
{
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 8002530:	2800      	cmp	r0, #0
 8002532:	bf08      	it	eq
 8002534:	2001      	moveq	r0, #1
{
 8002536:	b508      	push	{r3, lr}
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 8002538:	f001 f8ec 	bl	8003714 <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 800253c:	2000      	movs	r0, #0
 800253e:	bd08      	pop	{r3, pc}

08002540 <osSemaphoreCreate>:
osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)
{
  (void) semaphore_def;
  osSemaphoreId sema;
  
  if (count == 1) {
 8002540:	2901      	cmp	r1, #1
{
 8002542:	4608      	mov	r0, r1
 8002544:	b510      	push	{r4, lr}
  if (count == 1) {
 8002546:	d10c      	bne.n	8002562 <osSemaphoreCreate+0x22>
    vSemaphoreCreateBinary(sema);
 8002548:	2203      	movs	r2, #3
 800254a:	2100      	movs	r1, #0
 800254c:	f000 fbc6 	bl	8002cdc <xQueueGenericCreate>
 8002550:	4604      	mov	r4, r0
 8002552:	b120      	cbz	r0, 800255e <osSemaphoreCreate+0x1e>
 8002554:	2300      	movs	r3, #0
 8002556:	461a      	mov	r2, r3
 8002558:	4619      	mov	r1, r3
 800255a:	f000 fbf5 	bl	8002d48 <xQueueGenericSend>
#if (configUSE_COUNTING_SEMAPHORES == 1 )	
  return xSemaphoreCreateCounting(count, 0);
#else
  return NULL;
#endif
}
 800255e:	4620      	mov	r0, r4
 8002560:	bd10      	pop	{r4, pc}
  return NULL;
 8002562:	2400      	movs	r4, #0
 8002564:	e7fb      	b.n	800255e <osSemaphoreCreate+0x1e>
	...

08002568 <osSemaphoreWait>:
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval  number of available tokens, or -1 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
*/
int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
{
 8002568:	b513      	push	{r0, r1, r4, lr}
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 800256a:	2400      	movs	r4, #0
{
 800256c:	460a      	mov	r2, r1
  portBASE_TYPE taskWoken = pdFALSE;  
 800256e:	9401      	str	r4, [sp, #4]
  
  
  if (semaphore_id == NULL) {
 8002570:	b1e8      	cbz	r0, 80025ae <osSemaphoreWait+0x46>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8002572:	f3ef 8305 	mrs	r3, IPSR
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 8002576:	b1a3      	cbz	r3, 80025a2 <osSemaphoreWait+0x3a>
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 8002578:	aa01      	add	r2, sp, #4
 800257a:	4621      	mov	r1, r4
 800257c:	f000 fdf0 	bl	8003160 <xQueueReceiveFromISR>
 8002580:	2801      	cmp	r0, #1
 8002582:	d002      	beq.n	800258a <osSemaphoreWait+0x22>
      return osErrorOS;
 8002584:	20ff      	movs	r0, #255	; 0xff
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
    return osErrorOS;
  }
  
  return osOK;
}
 8002586:	b002      	add	sp, #8
 8002588:	bd10      	pop	{r4, pc}
	portEND_SWITCHING_ISR(taskWoken);
 800258a:	9b01      	ldr	r3, [sp, #4]
 800258c:	b13b      	cbz	r3, 800259e <osSemaphoreWait+0x36>
 800258e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002592:	4b08      	ldr	r3, [pc, #32]	; (80025b4 <osSemaphoreWait+0x4c>)
 8002594:	601a      	str	r2, [r3, #0]
 8002596:	f3bf 8f4f 	dsb	sy
 800259a:	f3bf 8f6f 	isb	sy
  return osOK;
 800259e:	2000      	movs	r0, #0
 80025a0:	e7f1      	b.n	8002586 <osSemaphoreWait+0x1e>
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
 80025a2:	4619      	mov	r1, r3
 80025a4:	f000 fd16 	bl	8002fd4 <xQueueGenericReceive>
 80025a8:	2801      	cmp	r0, #1
 80025aa:	d1eb      	bne.n	8002584 <osSemaphoreWait+0x1c>
 80025ac:	e7f7      	b.n	800259e <osSemaphoreWait+0x36>
    return osErrorParameter;
 80025ae:	2080      	movs	r0, #128	; 0x80
 80025b0:	e7e9      	b.n	8002586 <osSemaphoreWait+0x1e>
 80025b2:	bf00      	nop
 80025b4:	e000ed04 	.word	0xe000ed04

080025b8 <osSemaphoreRelease>:
* @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreRelease shall be consistent in every CMSIS-RTOS.
*/
osStatus osSemaphoreRelease (osSemaphoreId semaphore_id)
{
 80025b8:	b513      	push	{r0, r1, r4, lr}
  osStatus result = osOK;
  portBASE_TYPE taskWoken = pdFALSE;
 80025ba:	2400      	movs	r4, #0
 80025bc:	9401      	str	r4, [sp, #4]
 80025be:	f3ef 8305 	mrs	r3, IPSR
  
  
  if (inHandlerMode()) {
 80025c2:	b193      	cbz	r3, 80025ea <osSemaphoreRelease+0x32>
    if (xSemaphoreGiveFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 80025c4:	a901      	add	r1, sp, #4
 80025c6:	f000 fcaa 	bl	8002f1e <xQueueGiveFromISR>
 80025ca:	2801      	cmp	r0, #1
 80025cc:	d113      	bne.n	80025f6 <osSemaphoreRelease+0x3e>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 80025ce:	9b01      	ldr	r3, [sp, #4]
 80025d0:	b913      	cbnz	r3, 80025d8 <osSemaphoreRelease+0x20>
  osStatus result = osOK;
 80025d2:	2000      	movs	r0, #0
      result = osErrorOS;
    }
  }
  
  return result;
}
 80025d4:	b002      	add	sp, #8
 80025d6:	bd10      	pop	{r4, pc}
    portEND_SWITCHING_ISR(taskWoken);
 80025d8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80025dc:	4b07      	ldr	r3, [pc, #28]	; (80025fc <osSemaphoreRelease+0x44>)
 80025de:	601a      	str	r2, [r3, #0]
 80025e0:	f3bf 8f4f 	dsb	sy
 80025e4:	f3bf 8f6f 	isb	sy
 80025e8:	e7f3      	b.n	80025d2 <osSemaphoreRelease+0x1a>
    if (xSemaphoreGive(semaphore_id) != pdTRUE) {
 80025ea:	461a      	mov	r2, r3
 80025ec:	4619      	mov	r1, r3
 80025ee:	f000 fbab 	bl	8002d48 <xQueueGenericSend>
 80025f2:	2801      	cmp	r0, #1
 80025f4:	d0ed      	beq.n	80025d2 <osSemaphoreRelease+0x1a>
      result = osErrorOS;
 80025f6:	20ff      	movs	r0, #255	; 0xff
 80025f8:	e7ec      	b.n	80025d4 <osSemaphoreRelease+0x1c>
 80025fa:	bf00      	nop
 80025fc:	e000ed04 	.word	0xe000ed04

08002600 <osSystickHandler>:
* @brief  Handles the tick increment
* @param  none.
* @retval none.
*/
void osSystickHandler(void)
{
 8002600:	b508      	push	{r3, lr}

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
 8002602:	f001 f9f3 	bl	80039ec <xTaskGetSchedulerState>
 8002606:	2801      	cmp	r0, #1
 8002608:	d003      	beq.n	8002612 <osSystickHandler+0x12>
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  }
#endif  /* INCLUDE_xTaskGetSchedulerState */  
}
 800260a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    xPortSysTickHandler();
 800260e:	f000 b907 	b.w	8002820 <xPortSysTickHandler>
 8002612:	bd08      	pop	{r3, pc}

08002614 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8002614:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8002618:	f04f 32ff 	mov.w	r2, #4294967295
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800261c:	6043      	str	r3, [r0, #4]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800261e:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8002620:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8002622:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8002624:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8002626:	6003      	str	r3, [r0, #0]
 8002628:	4770      	bx	lr

0800262a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 800262a:	2300      	movs	r3, #0
 800262c:	6103      	str	r3, [r0, #16]
 800262e:	4770      	bx	lr

08002630 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8002630:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8002632:	689a      	ldr	r2, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
 8002634:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8002636:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8002638:	689a      	ldr	r2, [r3, #8]
 800263a:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800263c:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800263e:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8002640:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8002642:	3301      	adds	r3, #1
 8002644:	6003      	str	r3, [r0, #0]
 8002646:	4770      	bx	lr

08002648 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8002648:	680a      	ldr	r2, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 800264a:	1c53      	adds	r3, r2, #1
{
 800264c:	b530      	push	{r4, r5, lr}
	if( xValueOfInsertion == portMAX_DELAY )
 800264e:	d10a      	bne.n	8002666 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8002650:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8002652:	685a      	ldr	r2, [r3, #4]
 8002654:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8002656:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8002658:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 800265a:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800265c:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 800265e:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8002660:	3301      	adds	r3, #1
 8002662:	6003      	str	r3, [r0, #0]
 8002664:	bd30      	pop	{r4, r5, pc}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8002666:	f100 0308 	add.w	r3, r0, #8
 800266a:	685c      	ldr	r4, [r3, #4]
 800266c:	6825      	ldr	r5, [r4, #0]
 800266e:	42aa      	cmp	r2, r5
 8002670:	d3ef      	bcc.n	8002652 <vListInsert+0xa>
 8002672:	4623      	mov	r3, r4
 8002674:	e7f9      	b.n	800266a <vListInsert+0x22>

08002676 <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8002676:	6841      	ldr	r1, [r0, #4]
 8002678:	6882      	ldr	r2, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 800267a:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800267c:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800267e:	6882      	ldr	r2, [r0, #8]
 8002680:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8002682:	6859      	ldr	r1, [r3, #4]
 8002684:	4288      	cmp	r0, r1
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8002686:	bf08      	it	eq
 8002688:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 800268a:	2200      	movs	r2, #0
 800268c:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 800268e:	6818      	ldr	r0, [r3, #0]
 8002690:	3801      	subs	r0, #1
 8002692:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 8002694:	4770      	bx	lr
	...

08002698 <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8002698:	4b0c      	ldr	r3, [pc, #48]	; (80026cc <prvTaskExitError+0x34>)
 800269a:	681b      	ldr	r3, [r3, #0]
 800269c:	3301      	adds	r3, #1
 800269e:	d00a      	beq.n	80026b6 <prvTaskExitError+0x1e>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 80026a0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80026a4:	b672      	cpsid	i
 80026a6:	f383 8811 	msr	BASEPRI, r3
 80026aa:	f3bf 8f6f 	isb	sy
 80026ae:	f3bf 8f4f 	dsb	sy
 80026b2:	b662      	cpsie	i
 80026b4:	e7fe      	b.n	80026b4 <prvTaskExitError+0x1c>
 80026b6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80026ba:	b672      	cpsid	i
 80026bc:	f383 8811 	msr	BASEPRI, r3
 80026c0:	f3bf 8f6f 	isb	sy
 80026c4:	f3bf 8f4f 	dsb	sy
 80026c8:	b662      	cpsie	i
 80026ca:	e7fe      	b.n	80026ca <prvTaskExitError+0x32>
 80026cc:	20000004 	.word	0x20000004

080026d0 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 80026d0:	4806      	ldr	r0, [pc, #24]	; (80026ec <prvPortStartFirstTask+0x1c>)
 80026d2:	6800      	ldr	r0, [r0, #0]
 80026d4:	6800      	ldr	r0, [r0, #0]
 80026d6:	f380 8808 	msr	MSP, r0
 80026da:	b662      	cpsie	i
 80026dc:	b661      	cpsie	f
 80026de:	f3bf 8f4f 	dsb	sy
 80026e2:	f3bf 8f6f 	isb	sy
 80026e6:	df00      	svc	0
 80026e8:	bf00      	nop
 80026ea:	0000      	.short	0x0000
 80026ec:	e000ed08 	.word	0xe000ed08

080026f0 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 80026f0:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8002700 <vPortEnableVFP+0x10>
 80026f4:	6801      	ldr	r1, [r0, #0]
 80026f6:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80026fa:	6001      	str	r1, [r0, #0]
 80026fc:	4770      	bx	lr
 80026fe:	0000      	.short	0x0000
 8002700:	e000ed88 	.word	0xe000ed88

08002704 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8002704:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8002708:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
 800270c:	e900 000a 	stmdb	r0, {r1, r3}
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8002710:	4b03      	ldr	r3, [pc, #12]	; (8002720 <pxPortInitialiseStack+0x1c>)
}
 8002712:	3844      	subs	r0, #68	; 0x44
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8002714:	6383      	str	r3, [r0, #56]	; 0x38
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 8002716:	f06f 0302 	mvn.w	r3, #2
 800271a:	6203      	str	r3, [r0, #32]
}
 800271c:	4770      	bx	lr
 800271e:	bf00      	nop
 8002720:	08002699 	.word	0x08002699

08002724 <SVC_Handler>:
	__asm volatile (
 8002724:	4b06      	ldr	r3, [pc, #24]	; (8002740 <pxCurrentTCBConst2>)
 8002726:	6819      	ldr	r1, [r3, #0]
 8002728:	6808      	ldr	r0, [r1, #0]
 800272a:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800272e:	f380 8809 	msr	PSP, r0
 8002732:	f3bf 8f6f 	isb	sy
 8002736:	f04f 0000 	mov.w	r0, #0
 800273a:	f380 8811 	msr	BASEPRI, r0
 800273e:	4770      	bx	lr

08002740 <pxCurrentTCBConst2>:
 8002740:	20003c8c 	.word	0x20003c8c

08002744 <vPortEnterCritical>:
 8002744:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002748:	b672      	cpsid	i
 800274a:	f383 8811 	msr	BASEPRI, r3
 800274e:	f3bf 8f6f 	isb	sy
 8002752:	f3bf 8f4f 	dsb	sy
 8002756:	b662      	cpsie	i
	uxCriticalNesting++;
 8002758:	4a0b      	ldr	r2, [pc, #44]	; (8002788 <vPortEnterCritical+0x44>)
 800275a:	6813      	ldr	r3, [r2, #0]
 800275c:	3301      	adds	r3, #1
	if( uxCriticalNesting == 1 )
 800275e:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 8002760:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 8002762:	d10f      	bne.n	8002784 <vPortEnterCritical+0x40>
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8002764:	4b09      	ldr	r3, [pc, #36]	; (800278c <vPortEnterCritical+0x48>)
 8002766:	681b      	ldr	r3, [r3, #0]
 8002768:	f013 0fff 	tst.w	r3, #255	; 0xff
 800276c:	d00a      	beq.n	8002784 <vPortEnterCritical+0x40>
 800276e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002772:	b672      	cpsid	i
 8002774:	f383 8811 	msr	BASEPRI, r3
 8002778:	f3bf 8f6f 	isb	sy
 800277c:	f3bf 8f4f 	dsb	sy
 8002780:	b662      	cpsie	i
 8002782:	e7fe      	b.n	8002782 <vPortEnterCritical+0x3e>
 8002784:	4770      	bx	lr
 8002786:	bf00      	nop
 8002788:	20000004 	.word	0x20000004
 800278c:	e000ed04 	.word	0xe000ed04

08002790 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8002790:	4a09      	ldr	r2, [pc, #36]	; (80027b8 <vPortExitCritical+0x28>)
 8002792:	6813      	ldr	r3, [r2, #0]
 8002794:	b953      	cbnz	r3, 80027ac <vPortExitCritical+0x1c>
 8002796:	f04f 0350 	mov.w	r3, #80	; 0x50
 800279a:	b672      	cpsid	i
 800279c:	f383 8811 	msr	BASEPRI, r3
 80027a0:	f3bf 8f6f 	isb	sy
 80027a4:	f3bf 8f4f 	dsb	sy
 80027a8:	b662      	cpsie	i
 80027aa:	e7fe      	b.n	80027aa <vPortExitCritical+0x1a>
	uxCriticalNesting--;
 80027ac:	3b01      	subs	r3, #1
 80027ae:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 80027b0:	b90b      	cbnz	r3, 80027b6 <vPortExitCritical+0x26>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 80027b2:	f383 8811 	msr	BASEPRI, r3
 80027b6:	4770      	bx	lr
 80027b8:	20000004 	.word	0x20000004

080027bc <PendSV_Handler>:
	__asm volatile
 80027bc:	f3ef 8009 	mrs	r0, PSP
 80027c0:	f3bf 8f6f 	isb	sy
 80027c4:	4b15      	ldr	r3, [pc, #84]	; (800281c <pxCurrentTCBConst>)
 80027c6:	681a      	ldr	r2, [r3, #0]
 80027c8:	f01e 0f10 	tst.w	lr, #16
 80027cc:	bf08      	it	eq
 80027ce:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 80027d2:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80027d6:	6010      	str	r0, [r2, #0]
 80027d8:	f84d 3d04 	str.w	r3, [sp, #-4]!
 80027dc:	f04f 0050 	mov.w	r0, #80	; 0x50
 80027e0:	b672      	cpsid	i
 80027e2:	f380 8811 	msr	BASEPRI, r0
 80027e6:	f3bf 8f4f 	dsb	sy
 80027ea:	f3bf 8f6f 	isb	sy
 80027ee:	b662      	cpsie	i
 80027f0:	f001 f800 	bl	80037f4 <vTaskSwitchContext>
 80027f4:	f04f 0000 	mov.w	r0, #0
 80027f8:	f380 8811 	msr	BASEPRI, r0
 80027fc:	bc08      	pop	{r3}
 80027fe:	6819      	ldr	r1, [r3, #0]
 8002800:	6808      	ldr	r0, [r1, #0]
 8002802:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002806:	f01e 0f10 	tst.w	lr, #16
 800280a:	bf08      	it	eq
 800280c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8002810:	f380 8809 	msr	PSP, r0
 8002814:	f3bf 8f6f 	isb	sy
 8002818:	4770      	bx	lr
 800281a:	bf00      	nop

0800281c <pxCurrentTCBConst>:
 800281c:	20003c8c 	.word	0x20003c8c

08002820 <xPortSysTickHandler>:
{
 8002820:	b508      	push	{r3, lr}
	__asm volatile
 8002822:	f3ef 8311 	mrs	r3, BASEPRI
 8002826:	f04f 0250 	mov.w	r2, #80	; 0x50
 800282a:	b672      	cpsid	i
 800282c:	f382 8811 	msr	BASEPRI, r2
 8002830:	f3bf 8f6f 	isb	sy
 8002834:	f3bf 8f4f 	dsb	sy
 8002838:	b662      	cpsie	i
		if( xTaskIncrementTick() != pdFALSE )
 800283a:	f000 fe7f 	bl	800353c <xTaskIncrementTick>
 800283e:	b118      	cbz	r0, 8002848 <xPortSysTickHandler+0x28>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8002840:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002844:	4b02      	ldr	r3, [pc, #8]	; (8002850 <xPortSysTickHandler+0x30>)
 8002846:	601a      	str	r2, [r3, #0]
	__asm volatile
 8002848:	2300      	movs	r3, #0
 800284a:	f383 8811 	msr	BASEPRI, r3
 800284e:	bd08      	pop	{r3, pc}
 8002850:	e000ed04 	.word	0xe000ed04

08002854 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8002854:	4b06      	ldr	r3, [pc, #24]	; (8002870 <vPortSetupTimerInterrupt+0x1c>)
 8002856:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800285a:	681b      	ldr	r3, [r3, #0]
 800285c:	fbb3 f3f2 	udiv	r3, r3, r2
 8002860:	4a04      	ldr	r2, [pc, #16]	; (8002874 <vPortSetupTimerInterrupt+0x20>)
 8002862:	3b01      	subs	r3, #1
 8002864:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8002866:	2207      	movs	r2, #7
 8002868:	4b03      	ldr	r3, [pc, #12]	; (8002878 <vPortSetupTimerInterrupt+0x24>)
 800286a:	601a      	str	r2, [r3, #0]
 800286c:	4770      	bx	lr
 800286e:	bf00      	nop
 8002870:	20000000 	.word	0x20000000
 8002874:	e000e014 	.word	0xe000e014
 8002878:	e000e010 	.word	0xe000e010

0800287c <xPortStartScheduler>:
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 800287c:	4b22      	ldr	r3, [pc, #136]	; (8002908 <xPortStartScheduler+0x8c>)
{
 800287e:	b513      	push	{r0, r1, r4, lr}
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8002880:	781a      	ldrb	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8002882:	2100      	movs	r1, #0
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8002884:	b2d2      	uxtb	r2, r2
 8002886:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8002888:	22ff      	movs	r2, #255	; 0xff
 800288a:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 800288c:	781b      	ldrb	r3, [r3, #0]
 800288e:	b2db      	uxtb	r3, r3
 8002890:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8002894:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8002898:	4b1c      	ldr	r3, [pc, #112]	; (800290c <xPortStartScheduler+0x90>)
 800289a:	f002 0250 	and.w	r2, r2, #80	; 0x50
 800289e:	701a      	strb	r2, [r3, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 80028a0:	2207      	movs	r2, #7
 80028a2:	605a      	str	r2, [r3, #4]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80028a4:	f89d 0003 	ldrb.w	r0, [sp, #3]
 80028a8:	1e54      	subs	r4, r2, #1
 80028aa:	0600      	lsls	r0, r0, #24
 80028ac:	d423      	bmi.n	80028f6 <xPortStartScheduler+0x7a>
 80028ae:	b101      	cbz	r1, 80028b2 <xPortStartScheduler+0x36>
 80028b0:	605a      	str	r2, [r3, #4]
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 80028b2:	685a      	ldr	r2, [r3, #4]
 80028b4:	0212      	lsls	r2, r2, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 80028b6:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 80028ba:	605a      	str	r2, [r3, #4]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80028bc:	9b01      	ldr	r3, [sp, #4]
 80028be:	4a12      	ldr	r2, [pc, #72]	; (8002908 <xPortStartScheduler+0x8c>)
 80028c0:	b2db      	uxtb	r3, r3
 80028c2:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80028c4:	4b12      	ldr	r3, [pc, #72]	; (8002910 <xPortStartScheduler+0x94>)
 80028c6:	681a      	ldr	r2, [r3, #0]
 80028c8:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 80028cc:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 80028ce:	681a      	ldr	r2, [r3, #0]
 80028d0:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 80028d4:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 80028d6:	f7ff ffbd 	bl	8002854 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 80028da:	2200      	movs	r2, #0
 80028dc:	4b0d      	ldr	r3, [pc, #52]	; (8002914 <xPortStartScheduler+0x98>)
 80028de:	601a      	str	r2, [r3, #0]
	vPortEnableVFP();
 80028e0:	f7ff ff06 	bl	80026f0 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 80028e4:	4a0c      	ldr	r2, [pc, #48]	; (8002918 <xPortStartScheduler+0x9c>)
 80028e6:	6813      	ldr	r3, [r2, #0]
 80028e8:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 80028ec:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
 80028ee:	f7ff feef 	bl	80026d0 <prvPortStartFirstTask>
	prvTaskExitError();
 80028f2:	f7ff fed1 	bl	8002698 <prvTaskExitError>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 80028f6:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80028fa:	2101      	movs	r1, #1
 80028fc:	0052      	lsls	r2, r2, #1
 80028fe:	b2d2      	uxtb	r2, r2
 8002900:	f88d 2003 	strb.w	r2, [sp, #3]
 8002904:	4622      	mov	r2, r4
 8002906:	e7cd      	b.n	80028a4 <xPortStartScheduler+0x28>
 8002908:	e000e400 	.word	0xe000e400
 800290c:	20000064 	.word	0x20000064
 8002910:	e000ed20 	.word	0xe000ed20
 8002914:	20000004 	.word	0x20000004
 8002918:	e000ef34 	.word	0xe000ef34

0800291c <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 800291c:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8002920:	2b0f      	cmp	r3, #15
 8002922:	4a12      	ldr	r2, [pc, #72]	; (800296c <vPortValidateInterruptPriority+0x50>)
 8002924:	d90f      	bls.n	8002946 <vPortValidateInterruptPriority+0x2a>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8002926:	4912      	ldr	r1, [pc, #72]	; (8002970 <vPortValidateInterruptPriority+0x54>)
 8002928:	5c5b      	ldrb	r3, [r3, r1]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 800292a:	7811      	ldrb	r1, [r2, #0]
 800292c:	4299      	cmp	r1, r3
 800292e:	d90a      	bls.n	8002946 <vPortValidateInterruptPriority+0x2a>
	__asm volatile
 8002930:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002934:	b672      	cpsid	i
 8002936:	f383 8811 	msr	BASEPRI, r3
 800293a:	f3bf 8f6f 	isb	sy
 800293e:	f3bf 8f4f 	dsb	sy
 8002942:	b662      	cpsie	i
 8002944:	e7fe      	b.n	8002944 <vPortValidateInterruptPriority+0x28>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8002946:	4b0b      	ldr	r3, [pc, #44]	; (8002974 <vPortValidateInterruptPriority+0x58>)
 8002948:	6852      	ldr	r2, [r2, #4]
 800294a:	681b      	ldr	r3, [r3, #0]
 800294c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8002950:	4293      	cmp	r3, r2
 8002952:	d90a      	bls.n	800296a <vPortValidateInterruptPriority+0x4e>
 8002954:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002958:	b672      	cpsid	i
 800295a:	f383 8811 	msr	BASEPRI, r3
 800295e:	f3bf 8f6f 	isb	sy
 8002962:	f3bf 8f4f 	dsb	sy
 8002966:	b662      	cpsie	i
 8002968:	e7fe      	b.n	8002968 <vPortValidateInterruptPriority+0x4c>
 800296a:	4770      	bx	lr
 800296c:	20000064 	.word	0x20000064
 8002970:	e000e3f0 	.word	0xe000e3f0
 8002974:	e000ed0c 	.word	0xe000ed0c

08002978 <prvInsertBlockIntoFreeList>:
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8002978:	4b0f      	ldr	r3, [pc, #60]	; (80029b8 <prvInsertBlockIntoFreeList+0x40>)
{
 800297a:	b530      	push	{r4, r5, lr}
 800297c:	461d      	mov	r5, r3
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800297e:	681a      	ldr	r2, [r3, #0]
 8002980:	4282      	cmp	r2, r0
 8002982:	d317      	bcc.n	80029b4 <prvInsertBlockIntoFreeList+0x3c>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8002984:	685c      	ldr	r4, [r3, #4]
 8002986:	1919      	adds	r1, r3, r4
 8002988:	4288      	cmp	r0, r1
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800298a:	bf01      	itttt	eq
 800298c:	6841      	ldreq	r1, [r0, #4]
 800298e:	4618      	moveq	r0, r3
 8002990:	1909      	addeq	r1, r1, r4
 8002992:	6059      	streq	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8002994:	6844      	ldr	r4, [r0, #4]
 8002996:	1901      	adds	r1, r0, r4
 8002998:	428a      	cmp	r2, r1
 800299a:	d106      	bne.n	80029aa <prvInsertBlockIntoFreeList+0x32>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800299c:	68a9      	ldr	r1, [r5, #8]
 800299e:	428a      	cmp	r2, r1
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 80029a0:	bf1f      	itttt	ne
 80029a2:	6851      	ldrne	r1, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 80029a4:	6812      	ldrne	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 80029a6:	1909      	addne	r1, r1, r4
 80029a8:	6041      	strne	r1, [r0, #4]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 80029aa:	4298      	cmp	r0, r3
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 80029ac:	6002      	str	r2, [r0, #0]
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 80029ae:	bf18      	it	ne
 80029b0:	6018      	strne	r0, [r3, #0]
 80029b2:	bd30      	pop	{r4, r5, pc}
 80029b4:	4613      	mov	r3, r2
 80029b6:	e7e2      	b.n	800297e <prvInsertBlockIntoFreeList+0x6>
 80029b8:	2000006c 	.word	0x2000006c

080029bc <pvPortMalloc>:
{
 80029bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80029c0:	4604      	mov	r4, r0
	vTaskSuspendAll();
 80029c2:	f000 fdab 	bl	800351c <vTaskSuspendAll>
		if( pxEnd == NULL )
 80029c6:	4a43      	ldr	r2, [pc, #268]	; (8002ad4 <pvPortMalloc+0x118>)
 80029c8:	4e43      	ldr	r6, [pc, #268]	; (8002ad8 <pvPortMalloc+0x11c>)
 80029ca:	6893      	ldr	r3, [r2, #8]
 80029cc:	bb1b      	cbnz	r3, 8002a16 <pvPortMalloc+0x5a>
	uxAddress = ( size_t ) ucHeap;
 80029ce:	f102 010c 	add.w	r1, r2, #12
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 80029d2:	0748      	lsls	r0, r1, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 80029d4:	bf1b      	ittet	ne
 80029d6:	f102 0013 	addne.w	r0, r2, #19
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 80029da:	f501 5370 	addne.w	r3, r1, #15360	; 0x3c00
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 80029de:	f44f 5370 	moveq.w	r3, #15360	; 0x3c00
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80029e2:	f020 0007 	bicne.w	r0, r0, #7
 80029e6:	bf1c      	itt	ne
 80029e8:	4601      	movne	r1, r0
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 80029ea:	1a1b      	subne	r3, r3, r0
	xStart.xBlockSize = ( size_t ) 0;
 80029ec:	2000      	movs	r0, #0
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 80029ee:	440b      	add	r3, r1
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 80029f0:	6011      	str	r1, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
 80029f2:	6050      	str	r0, [r2, #4]
	uxAddress -= xHeapStructSize;
 80029f4:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80029f6:	f023 0307 	bic.w	r3, r3, #7
	pxEnd->xBlockSize = 0;
 80029fa:	6058      	str	r0, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 80029fc:	6018      	str	r0, [r3, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 80029fe:	1a58      	subs	r0, r3, r1
	pxEnd = ( void * ) uxAddress;
 8002a00:	6093      	str	r3, [r2, #8]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8002a02:	600b      	str	r3, [r1, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8002a04:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8002a08:	6048      	str	r0, [r1, #4]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8002a0a:	f8c6 0924 	str.w	r0, [r6, #2340]	; 0x924
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8002a0e:	f8c6 0928 	str.w	r0, [r6, #2344]	; 0x928
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8002a12:	f8c6 392c 	str.w	r3, [r6, #2348]	; 0x92c
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8002a16:	f8d6 892c 	ldr.w	r8, [r6, #2348]	; 0x92c
 8002a1a:	ea18 0f04 	tst.w	r8, r4
 8002a1e:	d115      	bne.n	8002a4c <pvPortMalloc+0x90>
			if( xWantedSize > 0 )
 8002a20:	2c00      	cmp	r4, #0
 8002a22:	d044      	beq.n	8002aae <pvPortMalloc+0xf2>
				xWantedSize += xHeapStructSize;
 8002a24:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8002a28:	0759      	lsls	r1, r3, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8002a2a:	bf1c      	itt	ne
 8002a2c:	f023 0307 	bicne.w	r3, r3, #7
 8002a30:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8002a32:	b15b      	cbz	r3, 8002a4c <pvPortMalloc+0x90>
 8002a34:	f8d6 7928 	ldr.w	r7, [r6, #2344]	; 0x928
 8002a38:	42bb      	cmp	r3, r7
 8002a3a:	d807      	bhi.n	8002a4c <pvPortMalloc+0x90>
				pxBlock = xStart.pxNextFreeBlock;
 8002a3c:	6815      	ldr	r5, [r2, #0]
				pxPreviousBlock = &xStart;
 8002a3e:	4825      	ldr	r0, [pc, #148]	; (8002ad4 <pvPortMalloc+0x118>)
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8002a40:	6869      	ldr	r1, [r5, #4]
 8002a42:	428b      	cmp	r3, r1
 8002a44:	d804      	bhi.n	8002a50 <pvPortMalloc+0x94>
				if( pxBlock != pxEnd )
 8002a46:	6892      	ldr	r2, [r2, #8]
 8002a48:	4295      	cmp	r5, r2
 8002a4a:	d107      	bne.n	8002a5c <pvPortMalloc+0xa0>
void *pvReturn = NULL;
 8002a4c:	2400      	movs	r4, #0
 8002a4e:	e02e      	b.n	8002aae <pvPortMalloc+0xf2>
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8002a50:	682c      	ldr	r4, [r5, #0]
 8002a52:	2c00      	cmp	r4, #0
 8002a54:	d0f7      	beq.n	8002a46 <pvPortMalloc+0x8a>
 8002a56:	4628      	mov	r0, r5
 8002a58:	4625      	mov	r5, r4
 8002a5a:	e7f1      	b.n	8002a40 <pvPortMalloc+0x84>
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8002a5c:	1ac9      	subs	r1, r1, r3
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8002a5e:	682a      	ldr	r2, [r5, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8002a60:	6804      	ldr	r4, [r0, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8002a62:	2910      	cmp	r1, #16
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8002a64:	6002      	str	r2, [r0, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8002a66:	d911      	bls.n	8002a8c <pvPortMalloc+0xd0>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8002a68:	18e8      	adds	r0, r5, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8002a6a:	0742      	lsls	r2, r0, #29
 8002a6c:	d00a      	beq.n	8002a84 <pvPortMalloc+0xc8>
 8002a6e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002a72:	b672      	cpsid	i
 8002a74:	f383 8811 	msr	BASEPRI, r3
 8002a78:	f3bf 8f6f 	isb	sy
 8002a7c:	f3bf 8f4f 	dsb	sy
 8002a80:	b662      	cpsie	i
 8002a82:	e7fe      	b.n	8002a82 <pvPortMalloc+0xc6>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8002a84:	6041      	str	r1, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8002a86:	606b      	str	r3, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 8002a88:	f7ff ff76 	bl	8002978 <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8002a8c:	686b      	ldr	r3, [r5, #4]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8002a8e:	3408      	adds	r4, #8
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8002a90:	f8d6 1924 	ldr.w	r1, [r6, #2340]	; 0x924
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8002a94:	1aff      	subs	r7, r7, r3
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8002a96:	ea48 0303 	orr.w	r3, r8, r3
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8002a9a:	428f      	cmp	r7, r1
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8002a9c:	606b      	str	r3, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8002a9e:	f04f 0300 	mov.w	r3, #0
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8002aa2:	f8c6 7928 	str.w	r7, [r6, #2344]	; 0x928
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8002aa6:	bf38      	it	cc
 8002aa8:	f8c6 7924 	strcc.w	r7, [r6, #2340]	; 0x924
					pxBlock->pxNextFreeBlock = NULL;
 8002aac:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 8002aae:	f000 fdbd 	bl	800362c <xTaskResumeAll>
	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8002ab2:	0763      	lsls	r3, r4, #29
 8002ab4:	d00a      	beq.n	8002acc <pvPortMalloc+0x110>
 8002ab6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002aba:	b672      	cpsid	i
 8002abc:	f383 8811 	msr	BASEPRI, r3
 8002ac0:	f3bf 8f6f 	isb	sy
 8002ac4:	f3bf 8f4f 	dsb	sy
 8002ac8:	b662      	cpsie	i
 8002aca:	e7fe      	b.n	8002aca <pvPortMalloc+0x10e>
}
 8002acc:	4620      	mov	r0, r4
 8002ace:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002ad2:	bf00      	nop
 8002ad4:	2000006c 	.word	0x2000006c
 8002ad8:	20003354 	.word	0x20003354

08002adc <vPortFree>:
{
 8002adc:	b538      	push	{r3, r4, r5, lr}
	if( pv != NULL )
 8002ade:	4604      	mov	r4, r0
 8002ae0:	b3a0      	cbz	r0, 8002b4c <vPortFree+0x70>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8002ae2:	4d1b      	ldr	r5, [pc, #108]	; (8002b50 <vPortFree+0x74>)
 8002ae4:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8002ae8:	f8d5 292c 	ldr.w	r2, [r5, #2348]	; 0x92c
 8002aec:	4213      	tst	r3, r2
 8002aee:	d10a      	bne.n	8002b06 <vPortFree+0x2a>
 8002af0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002af4:	b672      	cpsid	i
 8002af6:	f383 8811 	msr	BASEPRI, r3
 8002afa:	f3bf 8f6f 	isb	sy
 8002afe:	f3bf 8f4f 	dsb	sy
 8002b02:	b662      	cpsie	i
 8002b04:	e7fe      	b.n	8002b04 <vPortFree+0x28>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8002b06:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8002b0a:	b151      	cbz	r1, 8002b22 <vPortFree+0x46>
 8002b0c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002b10:	b672      	cpsid	i
 8002b12:	f383 8811 	msr	BASEPRI, r3
 8002b16:	f3bf 8f6f 	isb	sy
 8002b1a:	f3bf 8f4f 	dsb	sy
 8002b1e:	b662      	cpsie	i
 8002b20:	e7fe      	b.n	8002b20 <vPortFree+0x44>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8002b22:	ea23 0302 	bic.w	r3, r3, r2
 8002b26:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 8002b2a:	f000 fcf7 	bl	800351c <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8002b2e:	f8d5 2928 	ldr.w	r2, [r5, #2344]	; 0x928
 8002b32:	f854 3c04 	ldr.w	r3, [r4, #-4]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8002b36:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
 8002b3a:	4413      	add	r3, r2
 8002b3c:	f8c5 3928 	str.w	r3, [r5, #2344]	; 0x928
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8002b40:	f7ff ff1a 	bl	8002978 <prvInsertBlockIntoFreeList>
}
 8002b44:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				( void ) xTaskResumeAll();
 8002b48:	f000 bd70 	b.w	800362c <xTaskResumeAll>
 8002b4c:	bd38      	pop	{r3, r4, r5, pc}
 8002b4e:	bf00      	nop
 8002b50:	20003354 	.word	0x20003354

08002b54 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8002b54:	b538      	push	{r3, r4, r5, lr}
 8002b56:	4615      	mov	r5, r2
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8002b58:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
 8002b5a:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8002b5c:	b95a      	cbnz	r2, 8002b76 <prvCopyDataToQueue+0x22>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8002b5e:	6805      	ldr	r5, [r0, #0]
 8002b60:	b10d      	cbz	r5, 8002b66 <prvCopyDataToQueue+0x12>
BaseType_t xReturn = pdFALSE;
 8002b62:	2000      	movs	r0, #0
 8002b64:	e003      	b.n	8002b6e <prvCopyDataToQueue+0x1a>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8002b66:	6840      	ldr	r0, [r0, #4]
 8002b68:	f000 ff98 	bl	8003a9c <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 8002b6c:	6065      	str	r5, [r4, #4]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
 8002b6e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002b70:	3301      	adds	r3, #1
 8002b72:	63a3      	str	r3, [r4, #56]	; 0x38

	return xReturn;
}
 8002b74:	bd38      	pop	{r3, r4, r5, pc}
	else if( xPosition == queueSEND_TO_BACK )
 8002b76:	b965      	cbnz	r5, 8002b92 <prvCopyDataToQueue+0x3e>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8002b78:	6880      	ldr	r0, [r0, #8]
 8002b7a:	f007 f842 	bl	8009c02 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8002b7e:	68a3      	ldr	r3, [r4, #8]
 8002b80:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8002b82:	4413      	add	r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8002b84:	6862      	ldr	r2, [r4, #4]
 8002b86:	4293      	cmp	r3, r2
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8002b88:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8002b8a:	d3ea      	bcc.n	8002b62 <prvCopyDataToQueue+0xe>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8002b8c:	6823      	ldr	r3, [r4, #0]
 8002b8e:	60a3      	str	r3, [r4, #8]
 8002b90:	e7e7      	b.n	8002b62 <prvCopyDataToQueue+0xe>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002b92:	68c0      	ldr	r0, [r0, #12]
 8002b94:	f007 f835 	bl	8009c02 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8002b98:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8002b9a:	68e2      	ldr	r2, [r4, #12]
 8002b9c:	425b      	negs	r3, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8002b9e:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8002ba0:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8002ba2:	428a      	cmp	r2, r1
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8002ba4:	60e2      	str	r2, [r4, #12]
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8002ba6:	bf3e      	ittt	cc
 8002ba8:	6862      	ldrcc	r2, [r4, #4]
 8002baa:	189b      	addcc	r3, r3, r2
 8002bac:	60e3      	strcc	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 8002bae:	2d02      	cmp	r5, #2
 8002bb0:	d1d7      	bne.n	8002b62 <prvCopyDataToQueue+0xe>
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 8002bb2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002bb4:	2b00      	cmp	r3, #0
 8002bb6:	d0d4      	beq.n	8002b62 <prvCopyDataToQueue+0xe>
				--( pxQueue->uxMessagesWaiting );
 8002bb8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002bba:	3b01      	subs	r3, #1
 8002bbc:	63a3      	str	r3, [r4, #56]	; 0x38
 8002bbe:	e7d0      	b.n	8002b62 <prvCopyDataToQueue+0xe>

08002bc0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 8002bc0:	4603      	mov	r3, r0
 8002bc2:	4608      	mov	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8002bc4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
 8002bc6:	b410      	push	{r4}
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8002bc8:	b162      	cbz	r2, 8002be4 <prvCopyDataFromQueue+0x24>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8002bca:	68d9      	ldr	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8002bcc:	685c      	ldr	r4, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8002bce:	4411      	add	r1, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8002bd0:	42a1      	cmp	r1, r4
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8002bd2:	60d9      	str	r1, [r3, #12]
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
	}
}
 8002bd4:	f85d 4b04 	ldr.w	r4, [sp], #4
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8002bd8:	bf24      	itt	cs
 8002bda:	6819      	ldrcs	r1, [r3, #0]
 8002bdc:	60d9      	strcs	r1, [r3, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8002bde:	68d9      	ldr	r1, [r3, #12]
 8002be0:	f007 b80f 	b.w	8009c02 <memcpy>
}
 8002be4:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002be8:	4770      	bx	lr

08002bea <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 8002bea:	b538      	push	{r3, r4, r5, lr}
 8002bec:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8002bee:	f7ff fda9 	bl	8002744 <vPortEnterCritical>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002bf2:	f104 0524 	add.w	r5, r4, #36	; 0x24
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8002bf6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002bf8:	2b00      	cmp	r3, #0
 8002bfa:	dc12      	bgt.n	8002c22 <prvUnlockQueue+0x38>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
 8002bfc:	f04f 33ff 	mov.w	r3, #4294967295
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002c00:	f104 0510 	add.w	r5, r4, #16
		pxQueue->xTxLock = queueUNLOCKED;
 8002c04:	64a3      	str	r3, [r4, #72]	; 0x48
	taskEXIT_CRITICAL();
 8002c06:	f7ff fdc3 	bl	8002790 <vPortExitCritical>
	taskENTER_CRITICAL();
 8002c0a:	f7ff fd9b 	bl	8002744 <vPortEnterCritical>
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8002c0e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002c10:	2b00      	cmp	r3, #0
 8002c12:	dc13      	bgt.n	8002c3c <prvUnlockQueue+0x52>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 8002c14:	f04f 33ff 	mov.w	r3, #4294967295
 8002c18:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
}
 8002c1a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	taskEXIT_CRITICAL();
 8002c1e:	f7ff bdb7 	b.w	8002790 <vPortExitCritical>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002c22:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002c24:	2b00      	cmp	r3, #0
 8002c26:	d0e9      	beq.n	8002bfc <prvUnlockQueue+0x12>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002c28:	4628      	mov	r0, r5
 8002c2a:	f000 fe4f 	bl	80038cc <xTaskRemoveFromEventList>
 8002c2e:	b108      	cbz	r0, 8002c34 <prvUnlockQueue+0x4a>
						vTaskMissedYield();
 8002c30:	f000 fed4 	bl	80039dc <vTaskMissedYield>
			--( pxQueue->xTxLock );
 8002c34:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002c36:	3b01      	subs	r3, #1
 8002c38:	64a3      	str	r3, [r4, #72]	; 0x48
 8002c3a:	e7dc      	b.n	8002bf6 <prvUnlockQueue+0xc>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002c3c:	6923      	ldr	r3, [r4, #16]
 8002c3e:	2b00      	cmp	r3, #0
 8002c40:	d0e8      	beq.n	8002c14 <prvUnlockQueue+0x2a>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002c42:	4628      	mov	r0, r5
 8002c44:	f000 fe42 	bl	80038cc <xTaskRemoveFromEventList>
 8002c48:	b108      	cbz	r0, 8002c4e <prvUnlockQueue+0x64>
					vTaskMissedYield();
 8002c4a:	f000 fec7 	bl	80039dc <vTaskMissedYield>
				--( pxQueue->xRxLock );
 8002c4e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002c50:	3b01      	subs	r3, #1
 8002c52:	6463      	str	r3, [r4, #68]	; 0x44
 8002c54:	e7db      	b.n	8002c0e <prvUnlockQueue+0x24>
	...

08002c58 <xQueueGenericReset>:
{
 8002c58:	b538      	push	{r3, r4, r5, lr}
 8002c5a:	460d      	mov	r5, r1
	configASSERT( pxQueue );
 8002c5c:	4604      	mov	r4, r0
 8002c5e:	b950      	cbnz	r0, 8002c76 <xQueueGenericReset+0x1e>
 8002c60:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002c64:	b672      	cpsid	i
 8002c66:	f383 8811 	msr	BASEPRI, r3
 8002c6a:	f3bf 8f6f 	isb	sy
 8002c6e:	f3bf 8f4f 	dsb	sy
 8002c72:	b662      	cpsie	i
 8002c74:	e7fe      	b.n	8002c74 <xQueueGenericReset+0x1c>
	taskENTER_CRITICAL();
 8002c76:	f7ff fd65 	bl	8002744 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8002c7a:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8002c7c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002c7e:	6822      	ldr	r2, [r4, #0]
 8002c80:	4343      	muls	r3, r0
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8002c82:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8002c84:	18d1      	adds	r1, r2, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8002c86:	1a1b      	subs	r3, r3, r0
 8002c88:	4413      	add	r3, r2
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8002c8a:	6061      	str	r1, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8002c8c:	2100      	movs	r1, #0
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8002c8e:	60e3      	str	r3, [r4, #12]
		pxQueue->xRxLock = queueUNLOCKED;
 8002c90:	f04f 33ff 	mov.w	r3, #4294967295
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8002c94:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->xRxLock = queueUNLOCKED;
 8002c96:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
 8002c98:	64a3      	str	r3, [r4, #72]	; 0x48
		if( xNewQueue == pdFALSE )
 8002c9a:	b99d      	cbnz	r5, 8002cc4 <xQueueGenericReset+0x6c>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002c9c:	6923      	ldr	r3, [r4, #16]
 8002c9e:	b16b      	cbz	r3, 8002cbc <xQueueGenericReset+0x64>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 8002ca0:	f104 0010 	add.w	r0, r4, #16
 8002ca4:	f000 fe12 	bl	80038cc <xTaskRemoveFromEventList>
 8002ca8:	2801      	cmp	r0, #1
 8002caa:	d107      	bne.n	8002cbc <xQueueGenericReset+0x64>
					queueYIELD_IF_USING_PREEMPTION();
 8002cac:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002cb0:	4b09      	ldr	r3, [pc, #36]	; (8002cd8 <xQueueGenericReset+0x80>)
 8002cb2:	601a      	str	r2, [r3, #0]
 8002cb4:	f3bf 8f4f 	dsb	sy
 8002cb8:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
 8002cbc:	f7ff fd68 	bl	8002790 <vPortExitCritical>
}
 8002cc0:	2001      	movs	r0, #1
 8002cc2:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8002cc4:	f104 0010 	add.w	r0, r4, #16
 8002cc8:	f7ff fca4 	bl	8002614 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8002ccc:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8002cd0:	f7ff fca0 	bl	8002614 <vListInitialise>
 8002cd4:	e7f2      	b.n	8002cbc <xQueueGenericReset+0x64>
 8002cd6:	bf00      	nop
 8002cd8:	e000ed04 	.word	0xe000ed04

08002cdc <xQueueGenericCreate>:
{
 8002cdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002cde:	460d      	mov	r5, r1
 8002ce0:	4617      	mov	r7, r2
	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8002ce2:	4606      	mov	r6, r0
 8002ce4:	b950      	cbnz	r0, 8002cfc <xQueueGenericCreate+0x20>
 8002ce6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002cea:	b672      	cpsid	i
 8002cec:	f383 8811 	msr	BASEPRI, r3
 8002cf0:	f3bf 8f6f 	isb	sy
 8002cf4:	f3bf 8f4f 	dsb	sy
 8002cf8:	b662      	cpsie	i
 8002cfa:	e7fe      	b.n	8002cfa <xQueueGenericCreate+0x1e>
	if( uxItemSize == ( UBaseType_t ) 0 )
 8002cfc:	b191      	cbz	r1, 8002d24 <xQueueGenericCreate+0x48>
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002cfe:	4348      	muls	r0, r1
 8002d00:	3001      	adds	r0, #1
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 8002d02:	3054      	adds	r0, #84	; 0x54
 8002d04:	f7ff fe5a 	bl	80029bc <pvPortMalloc>
	if( pxNewQueue != NULL )
 8002d08:	4604      	mov	r4, r0
 8002d0a:	b188      	cbz	r0, 8002d30 <xQueueGenericCreate+0x54>
		if( uxItemSize == ( UBaseType_t ) 0 )
 8002d0c:	b965      	cbnz	r5, 8002d28 <xQueueGenericCreate+0x4c>
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8002d0e:	6020      	str	r0, [r4, #0]
		pxNewQueue->uxLength = uxQueueLength;
 8002d10:	63e6      	str	r6, [r4, #60]	; 0x3c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8002d12:	2101      	movs	r1, #1
		pxNewQueue->uxItemSize = uxItemSize;
 8002d14:	6425      	str	r5, [r4, #64]	; 0x40
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8002d16:	4620      	mov	r0, r4
 8002d18:	f7ff ff9e 	bl	8002c58 <xQueueGenericReset>
			pxNewQueue->ucQueueType = ucQueueType;
 8002d1c:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
}
 8002d20:	4620      	mov	r0, r4
 8002d22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		xQueueSizeInBytes = ( size_t ) 0;
 8002d24:	4608      	mov	r0, r1
 8002d26:	e7ec      	b.n	8002d02 <xQueueGenericCreate+0x26>
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
 8002d28:	f100 0354 	add.w	r3, r0, #84	; 0x54
 8002d2c:	6003      	str	r3, [r0, #0]
 8002d2e:	e7ef      	b.n	8002d10 <xQueueGenericCreate+0x34>
 8002d30:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002d34:	b672      	cpsid	i
 8002d36:	f383 8811 	msr	BASEPRI, r3
 8002d3a:	f3bf 8f6f 	isb	sy
 8002d3e:	f3bf 8f4f 	dsb	sy
 8002d42:	b662      	cpsie	i
 8002d44:	e7fe      	b.n	8002d44 <xQueueGenericCreate+0x68>
	...

08002d48 <xQueueGenericSend>:
{
 8002d48:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8002d4c:	4689      	mov	r9, r1
 8002d4e:	9201      	str	r2, [sp, #4]
 8002d50:	461f      	mov	r7, r3
	configASSERT( pxQueue );
 8002d52:	4604      	mov	r4, r0
 8002d54:	b950      	cbnz	r0, 8002d6c <xQueueGenericSend+0x24>
 8002d56:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002d5a:	b672      	cpsid	i
 8002d5c:	f383 8811 	msr	BASEPRI, r3
 8002d60:	f3bf 8f6f 	isb	sy
 8002d64:	f3bf 8f4f 	dsb	sy
 8002d68:	b662      	cpsie	i
 8002d6a:	e7fe      	b.n	8002d6a <xQueueGenericSend+0x22>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8002d6c:	2900      	cmp	r1, #0
 8002d6e:	f040 808f 	bne.w	8002e90 <xQueueGenericSend+0x148>
 8002d72:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8002d74:	2b00      	cmp	r3, #0
 8002d76:	f000 808b 	beq.w	8002e90 <xQueueGenericSend+0x148>
 8002d7a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002d7e:	b672      	cpsid	i
 8002d80:	f383 8811 	msr	BASEPRI, r3
 8002d84:	f3bf 8f6f 	isb	sy
 8002d88:	f3bf 8f4f 	dsb	sy
 8002d8c:	b662      	cpsie	i
 8002d8e:	e7fe      	b.n	8002d8e <xQueueGenericSend+0x46>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8002d90:	9e01      	ldr	r6, [sp, #4]
 8002d92:	2e00      	cmp	r6, #0
 8002d94:	f000 8087 	beq.w	8002ea6 <xQueueGenericSend+0x15e>
 8002d98:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002d9c:	b672      	cpsid	i
 8002d9e:	f383 8811 	msr	BASEPRI, r3
 8002da2:	f3bf 8f6f 	isb	sy
 8002da6:	f3bf 8f4f 	dsb	sy
 8002daa:	b662      	cpsie	i
 8002dac:	e7fe      	b.n	8002dac <xQueueGenericSend+0x64>
					else if( xYieldRequired != pdFALSE )
 8002dae:	2800      	cmp	r0, #0
 8002db0:	d159      	bne.n	8002e66 <xQueueGenericSend+0x11e>
				taskEXIT_CRITICAL();
 8002db2:	f7ff fced 	bl	8002790 <vPortExitCritical>
				return pdPASS;
 8002db6:	2001      	movs	r0, #1
}
 8002db8:	b004      	add	sp, #16
 8002dba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				if( xTicksToWait == ( TickType_t ) 0 )
 8002dbe:	9d01      	ldr	r5, [sp, #4]
 8002dc0:	b91d      	cbnz	r5, 8002dca <xQueueGenericSend+0x82>
					taskEXIT_CRITICAL();
 8002dc2:	f7ff fce5 	bl	8002790 <vPortExitCritical>
			return errQUEUE_FULL;
 8002dc6:	2000      	movs	r0, #0
 8002dc8:	e7f6      	b.n	8002db8 <xQueueGenericSend+0x70>
				else if( xEntryTimeSet == pdFALSE )
 8002dca:	b916      	cbnz	r6, 8002dd2 <xQueueGenericSend+0x8a>
					vTaskSetTimeOutState( &xTimeOut );
 8002dcc:	a802      	add	r0, sp, #8
 8002dce:	f000 fdbb 	bl	8003948 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 8002dd2:	f7ff fcdd 	bl	8002790 <vPortExitCritical>
		vTaskSuspendAll();
 8002dd6:	f000 fba1 	bl	800351c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8002dda:	f7ff fcb3 	bl	8002744 <vPortEnterCritical>
 8002dde:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002de0:	3301      	adds	r3, #1
 8002de2:	d101      	bne.n	8002de8 <xQueueGenericSend+0xa0>
 8002de4:	f8c4 8044 	str.w	r8, [r4, #68]	; 0x44
 8002de8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002dea:	3301      	adds	r3, #1
 8002dec:	d101      	bne.n	8002df2 <xQueueGenericSend+0xaa>
 8002dee:	f8c4 8048 	str.w	r8, [r4, #72]	; 0x48
 8002df2:	f7ff fccd 	bl	8002790 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8002df6:	a901      	add	r1, sp, #4
 8002df8:	a802      	add	r0, sp, #8
 8002dfa:	f000 fdb3 	bl	8003964 <xTaskCheckForTimeOut>
 8002dfe:	2800      	cmp	r0, #0
 8002e00:	d140      	bne.n	8002e84 <xQueueGenericSend+0x13c>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8002e02:	f7ff fc9f 	bl	8002744 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8002e06:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 8002e08:	6be5      	ldr	r5, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8002e0a:	f7ff fcc1 	bl	8002790 <vPortExitCritical>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8002e0e:	42ae      	cmp	r6, r5
 8002e10:	d132      	bne.n	8002e78 <xQueueGenericSend+0x130>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8002e12:	9901      	ldr	r1, [sp, #4]
 8002e14:	f104 0010 	add.w	r0, r4, #16
 8002e18:	f000 fd22 	bl	8003860 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8002e1c:	4620      	mov	r0, r4
 8002e1e:	f7ff fee4 	bl	8002bea <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8002e22:	f000 fc03 	bl	800362c <xTaskResumeAll>
 8002e26:	b938      	cbnz	r0, 8002e38 <xQueueGenericSend+0xf0>
					portYIELD_WITHIN_API();
 8002e28:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8002e2c:	f8ca 3000 	str.w	r3, [sl]
 8002e30:	f3bf 8f4f 	dsb	sy
 8002e34:	f3bf 8f6f 	isb	sy
 8002e38:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
 8002e3a:	f7ff fc83 	bl	8002744 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8002e3e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002e40:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002e42:	429a      	cmp	r2, r3
 8002e44:	d301      	bcc.n	8002e4a <xQueueGenericSend+0x102>
 8002e46:	2f02      	cmp	r7, #2
 8002e48:	d1b9      	bne.n	8002dbe <xQueueGenericSend+0x76>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8002e4a:	463a      	mov	r2, r7
 8002e4c:	4649      	mov	r1, r9
 8002e4e:	4620      	mov	r0, r4
 8002e50:	f7ff fe80 	bl	8002b54 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002e54:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002e56:	2b00      	cmp	r3, #0
 8002e58:	d0a9      	beq.n	8002dae <xQueueGenericSend+0x66>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 8002e5a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8002e5e:	f000 fd35 	bl	80038cc <xTaskRemoveFromEventList>
 8002e62:	2801      	cmp	r0, #1
 8002e64:	d1a5      	bne.n	8002db2 <xQueueGenericSend+0x6a>
						queueYIELD_IF_USING_PREEMPTION();
 8002e66:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002e6a:	4b17      	ldr	r3, [pc, #92]	; (8002ec8 <xQueueGenericSend+0x180>)
 8002e6c:	601a      	str	r2, [r3, #0]
 8002e6e:	f3bf 8f4f 	dsb	sy
 8002e72:	f3bf 8f6f 	isb	sy
 8002e76:	e79c      	b.n	8002db2 <xQueueGenericSend+0x6a>
				prvUnlockQueue( pxQueue );
 8002e78:	4620      	mov	r0, r4
 8002e7a:	f7ff feb6 	bl	8002bea <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8002e7e:	f000 fbd5 	bl	800362c <xTaskResumeAll>
 8002e82:	e7d9      	b.n	8002e38 <xQueueGenericSend+0xf0>
			prvUnlockQueue( pxQueue );
 8002e84:	4620      	mov	r0, r4
 8002e86:	f7ff feb0 	bl	8002bea <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8002e8a:	f000 fbcf 	bl	800362c <xTaskResumeAll>
 8002e8e:	e79a      	b.n	8002dc6 <xQueueGenericSend+0x7e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8002e90:	2f02      	cmp	r7, #2
 8002e92:	d102      	bne.n	8002e9a <xQueueGenericSend+0x152>
 8002e94:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002e96:	2b01      	cmp	r3, #1
 8002e98:	d10a      	bne.n	8002eb0 <xQueueGenericSend+0x168>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8002e9a:	f000 fda7 	bl	80039ec <xTaskGetSchedulerState>
 8002e9e:	2800      	cmp	r0, #0
 8002ea0:	f43f af76 	beq.w	8002d90 <xQueueGenericSend+0x48>
 8002ea4:	2600      	movs	r6, #0
		prvLockQueue( pxQueue );
 8002ea6:	f04f 0800 	mov.w	r8, #0
					portYIELD_WITHIN_API();
 8002eaa:	f8df a01c 	ldr.w	sl, [pc, #28]	; 8002ec8 <xQueueGenericSend+0x180>
 8002eae:	e7c4      	b.n	8002e3a <xQueueGenericSend+0xf2>
 8002eb0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002eb4:	b672      	cpsid	i
 8002eb6:	f383 8811 	msr	BASEPRI, r3
 8002eba:	f3bf 8f6f 	isb	sy
 8002ebe:	f3bf 8f4f 	dsb	sy
 8002ec2:	b662      	cpsie	i
 8002ec4:	e7fe      	b.n	8002ec4 <xQueueGenericSend+0x17c>
 8002ec6:	bf00      	nop
 8002ec8:	e000ed04 	.word	0xe000ed04

08002ecc <xQueueCreateMutex>:
	{
 8002ecc:	b570      	push	{r4, r5, r6, lr}
 8002ece:	4606      	mov	r6, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
 8002ed0:	2054      	movs	r0, #84	; 0x54
 8002ed2:	f7ff fd73 	bl	80029bc <pvPortMalloc>
		if( pxNewQueue != NULL )
 8002ed6:	4604      	mov	r4, r0
 8002ed8:	b1f8      	cbz	r0, 8002f1a <xQueueCreateMutex+0x4e>
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
 8002eda:	2301      	movs	r3, #1
			pxNewQueue->pxMutexHolder = NULL;
 8002edc:	2500      	movs	r5, #0
				pxNewQueue->ucQueueType = ucQueueType;
 8002ede:	f880 6050 	strb.w	r6, [r0, #80]	; 0x50
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 8002ee2:	3010      	adds	r0, #16
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
 8002ee4:	62c3      	str	r3, [r0, #44]	; 0x2c
			pxNewQueue->xRxLock = queueUNLOCKED;
 8002ee6:	f04f 33ff 	mov.w	r3, #4294967295
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8002eea:	6285      	str	r5, [r0, #40]	; 0x28
			pxNewQueue->pxMutexHolder = NULL;
 8002eec:	f840 5c0c 	str.w	r5, [r0, #-12]
			pxNewQueue->xRxLock = queueUNLOCKED;
 8002ef0:	6343      	str	r3, [r0, #52]	; 0x34
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 8002ef2:	f840 5c10 	str.w	r5, [r0, #-16]
			pxNewQueue->xTxLock = queueUNLOCKED;
 8002ef6:	6383      	str	r3, [r0, #56]	; 0x38
			pxNewQueue->pcWriteTo = NULL;
 8002ef8:	f840 5c08 	str.w	r5, [r0, #-8]
			pxNewQueue->u.pcReadFrom = NULL;
 8002efc:	f840 5c04 	str.w	r5, [r0, #-4]
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
 8002f00:	6305      	str	r5, [r0, #48]	; 0x30
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 8002f02:	f7ff fb87 	bl	8002614 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 8002f06:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8002f0a:	f7ff fb83 	bl	8002614 <vListInitialise>
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 8002f0e:	462b      	mov	r3, r5
 8002f10:	462a      	mov	r2, r5
 8002f12:	4629      	mov	r1, r5
 8002f14:	4620      	mov	r0, r4
 8002f16:	f7ff ff17 	bl	8002d48 <xQueueGenericSend>
	}
 8002f1a:	4620      	mov	r0, r4
 8002f1c:	bd70      	pop	{r4, r5, r6, pc}

08002f1e <xQueueGiveFromISR>:
{
 8002f1e:	b570      	push	{r4, r5, r6, lr}
 8002f20:	460d      	mov	r5, r1
	configASSERT( pxQueue );
 8002f22:	4604      	mov	r4, r0
 8002f24:	b950      	cbnz	r0, 8002f3c <xQueueGiveFromISR+0x1e>
 8002f26:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002f2a:	b672      	cpsid	i
 8002f2c:	f383 8811 	msr	BASEPRI, r3
 8002f30:	f3bf 8f6f 	isb	sy
 8002f34:	f3bf 8f4f 	dsb	sy
 8002f38:	b662      	cpsie	i
 8002f3a:	e7fe      	b.n	8002f3a <xQueueGiveFromISR+0x1c>
	configASSERT( pxQueue->uxItemSize == 0 );
 8002f3c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8002f3e:	b153      	cbz	r3, 8002f56 <xQueueGiveFromISR+0x38>
 8002f40:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002f44:	b672      	cpsid	i
 8002f46:	f383 8811 	msr	BASEPRI, r3
 8002f4a:	f3bf 8f6f 	isb	sy
 8002f4e:	f3bf 8f4f 	dsb	sy
 8002f52:	b662      	cpsie	i
 8002f54:	e7fe      	b.n	8002f54 <xQueueGiveFromISR+0x36>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 8002f56:	6803      	ldr	r3, [r0, #0]
 8002f58:	b913      	cbnz	r3, 8002f60 <xQueueGiveFromISR+0x42>
 8002f5a:	6843      	ldr	r3, [r0, #4]
 8002f5c:	2b00      	cmp	r3, #0
 8002f5e:	d12e      	bne.n	8002fbe <xQueueGiveFromISR+0xa0>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8002f60:	f7ff fcdc 	bl	800291c <vPortValidateInterruptPriority>
	__asm volatile
 8002f64:	f3ef 8611 	mrs	r6, BASEPRI
 8002f68:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002f6c:	b672      	cpsid	i
 8002f6e:	f383 8811 	msr	BASEPRI, r3
 8002f72:	f3bf 8f6f 	isb	sy
 8002f76:	f3bf 8f4f 	dsb	sy
 8002f7a:	b662      	cpsie	i
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 8002f7c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002f7e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002f80:	429a      	cmp	r2, r3
 8002f82:	d301      	bcc.n	8002f88 <xQueueGiveFromISR+0x6a>
			xReturn = errQUEUE_FULL;
 8002f84:	2000      	movs	r0, #0
 8002f86:	e013      	b.n	8002fb0 <xQueueGiveFromISR+0x92>
			++( pxQueue->uxMessagesWaiting );
 8002f88:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002f8a:	3301      	adds	r3, #1
 8002f8c:	63a3      	str	r3, [r4, #56]	; 0x38
			if( pxQueue->xTxLock == queueUNLOCKED )
 8002f8e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002f90:	3301      	adds	r3, #1
 8002f92:	d110      	bne.n	8002fb6 <xQueueGiveFromISR+0x98>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002f94:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002f96:	b90b      	cbnz	r3, 8002f9c <xQueueGiveFromISR+0x7e>
			xReturn = pdPASS;
 8002f98:	2001      	movs	r0, #1
 8002f9a:	e009      	b.n	8002fb0 <xQueueGiveFromISR+0x92>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002f9c:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8002fa0:	f000 fc94 	bl	80038cc <xTaskRemoveFromEventList>
 8002fa4:	2800      	cmp	r0, #0
 8002fa6:	d0f7      	beq.n	8002f98 <xQueueGiveFromISR+0x7a>
							if( pxHigherPriorityTaskWoken != NULL )
 8002fa8:	2d00      	cmp	r5, #0
 8002faa:	d0f5      	beq.n	8002f98 <xQueueGiveFromISR+0x7a>
								*pxHigherPriorityTaskWoken = pdTRUE;
 8002fac:	2001      	movs	r0, #1
 8002fae:	6028      	str	r0, [r5, #0]
	__asm volatile
 8002fb0:	f386 8811 	msr	BASEPRI, r6
}
 8002fb4:	bd70      	pop	{r4, r5, r6, pc}
				++( pxQueue->xTxLock );
 8002fb6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002fb8:	3301      	adds	r3, #1
 8002fba:	64a3      	str	r3, [r4, #72]	; 0x48
 8002fbc:	e7ec      	b.n	8002f98 <xQueueGiveFromISR+0x7a>
	__asm volatile
 8002fbe:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002fc2:	b672      	cpsid	i
 8002fc4:	f383 8811 	msr	BASEPRI, r3
 8002fc8:	f3bf 8f6f 	isb	sy
 8002fcc:	f3bf 8f4f 	dsb	sy
 8002fd0:	b662      	cpsie	i
 8002fd2:	e7fe      	b.n	8002fd2 <xQueueGiveFromISR+0xb4>

08002fd4 <xQueueGenericReceive>:
{
 8002fd4:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8002fd8:	4688      	mov	r8, r1
 8002fda:	9201      	str	r2, [sp, #4]
 8002fdc:	469a      	mov	sl, r3
	configASSERT( pxQueue );
 8002fde:	4604      	mov	r4, r0
 8002fe0:	b950      	cbnz	r0, 8002ff8 <xQueueGenericReceive+0x24>
 8002fe2:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002fe6:	b672      	cpsid	i
 8002fe8:	f383 8811 	msr	BASEPRI, r3
 8002fec:	f3bf 8f6f 	isb	sy
 8002ff0:	f3bf 8f4f 	dsb	sy
 8002ff4:	b662      	cpsie	i
 8002ff6:	e7fe      	b.n	8002ff6 <xQueueGenericReceive+0x22>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8002ff8:	2900      	cmp	r1, #0
 8002ffa:	f040 80a4 	bne.w	8003146 <xQueueGenericReceive+0x172>
 8002ffe:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8003000:	2b00      	cmp	r3, #0
 8003002:	f000 80a0 	beq.w	8003146 <xQueueGenericReceive+0x172>
 8003006:	f04f 0350 	mov.w	r3, #80	; 0x50
 800300a:	b672      	cpsid	i
 800300c:	f383 8811 	msr	BASEPRI, r3
 8003010:	f3bf 8f6f 	isb	sy
 8003014:	f3bf 8f4f 	dsb	sy
 8003018:	b662      	cpsie	i
 800301a:	e7fe      	b.n	800301a <xQueueGenericReceive+0x46>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800301c:	9e01      	ldr	r6, [sp, #4]
 800301e:	2e00      	cmp	r6, #0
 8003020:	f000 8097 	beq.w	8003152 <xQueueGenericReceive+0x17e>
 8003024:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003028:	b672      	cpsid	i
 800302a:	f383 8811 	msr	BASEPRI, r3
 800302e:	f3bf 8f6f 	isb	sy
 8003032:	f3bf 8f4f 	dsb	sy
 8003036:	b662      	cpsie	i
 8003038:	e7fe      	b.n	8003038 <xQueueGenericReceive+0x64>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800303a:	6a63      	ldr	r3, [r4, #36]	; 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 800303c:	60e5      	str	r5, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800303e:	b12b      	cbz	r3, 800304c <xQueueGenericReceive+0x78>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8003040:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8003044:	f000 fc42 	bl	80038cc <xTaskRemoveFromEventList>
 8003048:	2800      	cmp	r0, #0
 800304a:	d167      	bne.n	800311c <xQueueGenericReceive+0x148>
				taskEXIT_CRITICAL();
 800304c:	f7ff fba0 	bl	8002790 <vPortExitCritical>
				return pdPASS;
 8003050:	2001      	movs	r0, #1
}
 8003052:	b004      	add	sp, #16
 8003054:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				if( xTicksToWait == ( TickType_t ) 0 )
 8003058:	9d01      	ldr	r5, [sp, #4]
 800305a:	b91d      	cbnz	r5, 8003064 <xQueueGenericReceive+0x90>
					taskEXIT_CRITICAL();
 800305c:	f7ff fb98 	bl	8002790 <vPortExitCritical>
			return errQUEUE_EMPTY;
 8003060:	2000      	movs	r0, #0
 8003062:	e7f6      	b.n	8003052 <xQueueGenericReceive+0x7e>
				else if( xEntryTimeSet == pdFALSE )
 8003064:	b916      	cbnz	r6, 800306c <xQueueGenericReceive+0x98>
					vTaskSetTimeOutState( &xTimeOut );
 8003066:	a802      	add	r0, sp, #8
 8003068:	f000 fc6e 	bl	8003948 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 800306c:	f7ff fb90 	bl	8002790 <vPortExitCritical>
		vTaskSuspendAll();
 8003070:	f000 fa54 	bl	800351c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8003074:	f7ff fb66 	bl	8002744 <vPortEnterCritical>
 8003078:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800307a:	3301      	adds	r3, #1
 800307c:	d100      	bne.n	8003080 <xQueueGenericReceive+0xac>
 800307e:	6467      	str	r7, [r4, #68]	; 0x44
 8003080:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8003082:	3301      	adds	r3, #1
 8003084:	d100      	bne.n	8003088 <xQueueGenericReceive+0xb4>
 8003086:	64a7      	str	r7, [r4, #72]	; 0x48
 8003088:	f7ff fb82 	bl	8002790 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800308c:	a901      	add	r1, sp, #4
 800308e:	a802      	add	r0, sp, #8
 8003090:	f000 fc68 	bl	8003964 <xTaskCheckForTimeOut>
 8003094:	2800      	cmp	r0, #0
 8003096:	d150      	bne.n	800313a <xQueueGenericReceive+0x166>
	taskENTER_CRITICAL();
 8003098:	f7ff fb54 	bl	8002744 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800309c:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 800309e:	f7ff fb77 	bl	8002790 <vPortExitCritical>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80030a2:	2d00      	cmp	r5, #0
 80030a4:	d143      	bne.n	800312e <xQueueGenericReceive+0x15a>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80030a6:	6823      	ldr	r3, [r4, #0]
 80030a8:	b933      	cbnz	r3, 80030b8 <xQueueGenericReceive+0xe4>
						taskENTER_CRITICAL();
 80030aa:	f7ff fb4b 	bl	8002744 <vPortEnterCritical>
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 80030ae:	6860      	ldr	r0, [r4, #4]
 80030b0:	f000 fcac 	bl	8003a0c <vTaskPriorityInherit>
						taskEXIT_CRITICAL();
 80030b4:	f7ff fb6c 	bl	8002790 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80030b8:	9901      	ldr	r1, [sp, #4]
 80030ba:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80030be:	f000 fbcf 	bl	8003860 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 80030c2:	4620      	mov	r0, r4
 80030c4:	f7ff fd91 	bl	8002bea <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80030c8:	f000 fab0 	bl	800362c <xTaskResumeAll>
 80030cc:	b938      	cbnz	r0, 80030de <xQueueGenericReceive+0x10a>
					portYIELD_WITHIN_API();
 80030ce:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80030d2:	f8c9 3000 	str.w	r3, [r9]
 80030d6:	f3bf 8f4f 	dsb	sy
 80030da:	f3bf 8f6f 	isb	sy
 80030de:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
 80030e0:	f7ff fb30 	bl	8002744 <vPortEnterCritical>
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 80030e4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80030e6:	2b00      	cmp	r3, #0
 80030e8:	d0b6      	beq.n	8003058 <xQueueGenericReceive+0x84>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 80030ea:	4641      	mov	r1, r8
 80030ec:	4620      	mov	r0, r4
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 80030ee:	68e5      	ldr	r5, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 80030f0:	f7ff fd66 	bl	8002bc0 <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
 80030f4:	f1ba 0f00 	cmp.w	sl, #0
 80030f8:	d19f      	bne.n	800303a <xQueueGenericReceive+0x66>
					--( pxQueue->uxMessagesWaiting );
 80030fa:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80030fc:	3b01      	subs	r3, #1
 80030fe:	63a3      	str	r3, [r4, #56]	; 0x38
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8003100:	6823      	ldr	r3, [r4, #0]
 8003102:	b913      	cbnz	r3, 800310a <xQueueGenericReceive+0x136>
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8003104:	f000 fd20 	bl	8003b48 <pvTaskIncrementMutexHeldCount>
 8003108:	6060      	str	r0, [r4, #4]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800310a:	6923      	ldr	r3, [r4, #16]
 800310c:	2b00      	cmp	r3, #0
 800310e:	d09d      	beq.n	800304c <xQueueGenericReceive+0x78>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 8003110:	f104 0010 	add.w	r0, r4, #16
 8003114:	f000 fbda 	bl	80038cc <xTaskRemoveFromEventList>
 8003118:	2801      	cmp	r0, #1
 800311a:	d197      	bne.n	800304c <xQueueGenericReceive+0x78>
							queueYIELD_IF_USING_PREEMPTION();
 800311c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003120:	4b0e      	ldr	r3, [pc, #56]	; (800315c <xQueueGenericReceive+0x188>)
 8003122:	601a      	str	r2, [r3, #0]
 8003124:	f3bf 8f4f 	dsb	sy
 8003128:	f3bf 8f6f 	isb	sy
 800312c:	e78e      	b.n	800304c <xQueueGenericReceive+0x78>
				prvUnlockQueue( pxQueue );
 800312e:	4620      	mov	r0, r4
 8003130:	f7ff fd5b 	bl	8002bea <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8003134:	f000 fa7a 	bl	800362c <xTaskResumeAll>
 8003138:	e7d1      	b.n	80030de <xQueueGenericReceive+0x10a>
			prvUnlockQueue( pxQueue );
 800313a:	4620      	mov	r0, r4
 800313c:	f7ff fd55 	bl	8002bea <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8003140:	f000 fa74 	bl	800362c <xTaskResumeAll>
 8003144:	e78c      	b.n	8003060 <xQueueGenericReceive+0x8c>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8003146:	f000 fc51 	bl	80039ec <xTaskGetSchedulerState>
 800314a:	2800      	cmp	r0, #0
 800314c:	f43f af66 	beq.w	800301c <xQueueGenericReceive+0x48>
 8003150:	2600      	movs	r6, #0
		prvLockQueue( pxQueue );
 8003152:	2700      	movs	r7, #0
					portYIELD_WITHIN_API();
 8003154:	f8df 9004 	ldr.w	r9, [pc, #4]	; 800315c <xQueueGenericReceive+0x188>
 8003158:	e7c2      	b.n	80030e0 <xQueueGenericReceive+0x10c>
 800315a:	bf00      	nop
 800315c:	e000ed04 	.word	0xe000ed04

08003160 <xQueueReceiveFromISR>:
{
 8003160:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003162:	460e      	mov	r6, r1
 8003164:	4617      	mov	r7, r2
	configASSERT( pxQueue );
 8003166:	4604      	mov	r4, r0
 8003168:	b950      	cbnz	r0, 8003180 <xQueueReceiveFromISR+0x20>
 800316a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800316e:	b672      	cpsid	i
 8003170:	f383 8811 	msr	BASEPRI, r3
 8003174:	f3bf 8f6f 	isb	sy
 8003178:	f3bf 8f4f 	dsb	sy
 800317c:	b662      	cpsie	i
 800317e:	e7fe      	b.n	800317e <xQueueReceiveFromISR+0x1e>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8003180:	b9d9      	cbnz	r1, 80031ba <xQueueReceiveFromISR+0x5a>
 8003182:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8003184:	b1cb      	cbz	r3, 80031ba <xQueueReceiveFromISR+0x5a>
 8003186:	f04f 0350 	mov.w	r3, #80	; 0x50
 800318a:	b672      	cpsid	i
 800318c:	f383 8811 	msr	BASEPRI, r3
 8003190:	f3bf 8f6f 	isb	sy
 8003194:	f3bf 8f4f 	dsb	sy
 8003198:	b662      	cpsie	i
 800319a:	e7fe      	b.n	800319a <xQueueReceiveFromISR+0x3a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800319c:	f104 0010 	add.w	r0, r4, #16
 80031a0:	f000 fb94 	bl	80038cc <xTaskRemoveFromEventList>
 80031a4:	b338      	cbz	r0, 80031f6 <xQueueReceiveFromISR+0x96>
						if( pxHigherPriorityTaskWoken != NULL )
 80031a6:	b337      	cbz	r7, 80031f6 <xQueueReceiveFromISR+0x96>
							*pxHigherPriorityTaskWoken = pdTRUE;
 80031a8:	2001      	movs	r0, #1
 80031aa:	6038      	str	r0, [r7, #0]
	__asm volatile
 80031ac:	f385 8811 	msr	BASEPRI, r5
}
 80031b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				++( pxQueue->xRxLock );
 80031b2:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80031b4:	3301      	adds	r3, #1
 80031b6:	6463      	str	r3, [r4, #68]	; 0x44
 80031b8:	e01d      	b.n	80031f6 <xQueueReceiveFromISR+0x96>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80031ba:	f7ff fbaf 	bl	800291c <vPortValidateInterruptPriority>
	__asm volatile
 80031be:	f3ef 8511 	mrs	r5, BASEPRI
 80031c2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80031c6:	b672      	cpsid	i
 80031c8:	f383 8811 	msr	BASEPRI, r3
 80031cc:	f3bf 8f6f 	isb	sy
 80031d0:	f3bf 8f4f 	dsb	sy
 80031d4:	b662      	cpsie	i
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 80031d6:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 80031d8:	2800      	cmp	r0, #0
 80031da:	d0e7      	beq.n	80031ac <xQueueReceiveFromISR+0x4c>
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 80031dc:	4631      	mov	r1, r6
 80031de:	4620      	mov	r0, r4
 80031e0:	f7ff fcee 	bl	8002bc0 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
 80031e4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80031e6:	3b01      	subs	r3, #1
 80031e8:	63a3      	str	r3, [r4, #56]	; 0x38
			if( pxQueue->xRxLock == queueUNLOCKED )
 80031ea:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80031ec:	3301      	adds	r3, #1
 80031ee:	d1e0      	bne.n	80031b2 <xQueueReceiveFromISR+0x52>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80031f0:	6923      	ldr	r3, [r4, #16]
 80031f2:	2b00      	cmp	r3, #0
 80031f4:	d1d2      	bne.n	800319c <xQueueReceiveFromISR+0x3c>
			xReturn = pdPASS;
 80031f6:	2001      	movs	r0, #1
 80031f8:	e7d8      	b.n	80031ac <xQueueReceiveFromISR+0x4c>

080031fa <uxQueueMessagesWaiting>:
{
 80031fa:	b510      	push	{r4, lr}
	configASSERT( xQueue );
 80031fc:	4604      	mov	r4, r0
 80031fe:	b950      	cbnz	r0, 8003216 <uxQueueMessagesWaiting+0x1c>
	__asm volatile
 8003200:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003204:	b672      	cpsid	i
 8003206:	f383 8811 	msr	BASEPRI, r3
 800320a:	f3bf 8f6f 	isb	sy
 800320e:	f3bf 8f4f 	dsb	sy
 8003212:	b662      	cpsie	i
 8003214:	e7fe      	b.n	8003214 <uxQueueMessagesWaiting+0x1a>
	taskENTER_CRITICAL();
 8003216:	f7ff fa95 	bl	8002744 <vPortEnterCritical>
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 800321a:	6ba4      	ldr	r4, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 800321c:	f7ff fab8 	bl	8002790 <vPortExitCritical>
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8003220:	4620      	mov	r0, r4
 8003222:	bd10      	pop	{r4, pc}

08003224 <vQueueUnregisterQueue>:
	{
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8003224:	2300      	movs	r3, #0
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 8003226:	4a07      	ldr	r2, [pc, #28]	; (8003244 <vQueueUnregisterQueue+0x20>)
 8003228:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
 800322c:	6849      	ldr	r1, [r1, #4]
 800322e:	4281      	cmp	r1, r0
 8003230:	d103      	bne.n	800323a <vQueueUnregisterQueue+0x16>
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
 8003232:	2100      	movs	r1, #0
 8003234:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
				break;
 8003238:	4770      	bx	lr
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 800323a:	3301      	adds	r3, #1
 800323c:	2b08      	cmp	r3, #8
 800323e:	d1f3      	bne.n	8003228 <vQueueUnregisterQueue+0x4>
 8003240:	4770      	bx	lr
 8003242:	bf00      	nop
 8003244:	20003f4c 	.word	0x20003f4c

08003248 <vQueueDelete>:
{
 8003248:	b510      	push	{r4, lr}
	configASSERT( pxQueue );
 800324a:	b950      	cbnz	r0, 8003262 <vQueueDelete+0x1a>
 800324c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003250:	b672      	cpsid	i
 8003252:	f383 8811 	msr	BASEPRI, r3
 8003256:	f3bf 8f6f 	isb	sy
 800325a:	f3bf 8f4f 	dsb	sy
 800325e:	b662      	cpsie	i
 8003260:	e7fe      	b.n	8003260 <vQueueDelete+0x18>
		vQueueUnregisterQueue( pxQueue );
 8003262:	f7ff ffdf 	bl	8003224 <vQueueUnregisterQueue>
}
 8003266:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	vPortFree( pxQueue );
 800326a:	f7ff bc37 	b.w	8002adc <vPortFree>
	...

08003270 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003270:	4b06      	ldr	r3, [pc, #24]	; (800328c <prvResetNextTaskUnblockTime+0x1c>)
 8003272:	681a      	ldr	r2, [r3, #0]
 8003274:	6812      	ldr	r2, [r2, #0]
 8003276:	b91a      	cbnz	r2, 8003280 <prvResetNextTaskUnblockTime+0x10>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8003278:	f04f 32ff 	mov.w	r2, #4294967295
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 800327c:	605a      	str	r2, [r3, #4]
 800327e:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8003280:	681a      	ldr	r2, [r3, #0]
 8003282:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 8003284:	68d2      	ldr	r2, [r2, #12]
 8003286:	6852      	ldr	r2, [r2, #4]
 8003288:	e7f8      	b.n	800327c <prvResetNextTaskUnblockTime+0xc>
 800328a:	bf00      	nop
 800328c:	20003c84 	.word	0x20003c84

08003290 <prvAddCurrentTaskToDelayedList>:
{
 8003290:	b538      	push	{r3, r4, r5, lr}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8003292:	4c0c      	ldr	r4, [pc, #48]	; (80032c4 <prvAddCurrentTaskToDelayedList+0x34>)
{
 8003294:	4605      	mov	r5, r0
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8003296:	68a3      	ldr	r3, [r4, #8]
 8003298:	6058      	str	r0, [r3, #4]
	if( xTimeToWake < xTickCount )
 800329a:	68e3      	ldr	r3, [r4, #12]
 800329c:	4298      	cmp	r0, r3
 800329e:	d206      	bcs.n	80032ae <prvAddCurrentTaskToDelayedList+0x1e>
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80032a0:	6920      	ldr	r0, [r4, #16]
 80032a2:	68a1      	ldr	r1, [r4, #8]
}
 80032a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80032a8:	3104      	adds	r1, #4
 80032aa:	f7ff b9cd 	b.w	8002648 <vListInsert>
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80032ae:	6820      	ldr	r0, [r4, #0]
 80032b0:	68a1      	ldr	r1, [r4, #8]
 80032b2:	3104      	adds	r1, #4
 80032b4:	f7ff f9c8 	bl	8002648 <vListInsert>
		if( xTimeToWake < xNextTaskUnblockTime )
 80032b8:	6863      	ldr	r3, [r4, #4]
 80032ba:	429d      	cmp	r5, r3
 80032bc:	d200      	bcs.n	80032c0 <prvAddCurrentTaskToDelayedList+0x30>
			xNextTaskUnblockTime = xTimeToWake;
 80032be:	6065      	str	r5, [r4, #4]
 80032c0:	bd38      	pop	{r3, r4, r5, pc}
 80032c2:	bf00      	nop
 80032c4:	20003c84 	.word	0x20003c84

080032c8 <xTaskGenericCreate.part.5>:
BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
 80032c8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80032cc:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 80032ce:	4682      	mov	sl, r0
 80032d0:	460f      	mov	r7, r1
 80032d2:	4616      	mov	r6, r2
 80032d4:	469b      	mov	fp, r3
 80032d6:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80032da:	b935      	cbnz	r5, 80032ea <xTaskGenericCreate.part.5+0x22>
 80032dc:	0090      	lsls	r0, r2, #2
 80032de:	f7ff fb6d 	bl	80029bc <pvPortMalloc>
		if( pxStack != NULL )
 80032e2:	4605      	mov	r5, r0
 80032e4:	2800      	cmp	r0, #0
 80032e6:	f000 809f 	beq.w	8003428 <xTaskGenericCreate.part.5+0x160>
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 80032ea:	205c      	movs	r0, #92	; 0x5c
 80032ec:	f7ff fb66 	bl	80029bc <pvPortMalloc>
			if( pxNewTCB != NULL )
 80032f0:	4604      	mov	r4, r0
 80032f2:	2800      	cmp	r0, #0
 80032f4:	f000 8095 	beq.w	8003422 <xTaskGenericCreate.part.5+0x15a>
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
 80032f8:	00b6      	lsls	r6, r6, #2
				pxNewTCB->pxStack = pxStack;
 80032fa:	6305      	str	r5, [r0, #48]	; 0x30
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
 80032fc:	21a5      	movs	r1, #165	; 0xa5
 80032fe:	4628      	mov	r0, r5
 8003300:	4632      	mov	r2, r6
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 8003302:	3e04      	subs	r6, #4
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
 8003304:	f006 fc88 	bl	8009c18 <memset>
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 8003308:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800330a:	f104 0234 	add.w	r2, r4, #52	; 0x34
 800330e:	441e      	add	r6, r3
 8003310:	1e7b      	subs	r3, r7, #1
 8003312:	370f      	adds	r7, #15
			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8003314:	f026 0607 	bic.w	r6, r6, #7
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 8003318:	7859      	ldrb	r1, [r3, #1]
 800331a:	f802 1b01 	strb.w	r1, [r2], #1
		if( pcName[ x ] == 0x00 )
 800331e:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 8003322:	b109      	cbz	r1, 8003328 <xTaskGenericCreate.part.5+0x60>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8003324:	42bb      	cmp	r3, r7
 8003326:	d1f7      	bne.n	8003318 <xTaskGenericCreate.part.5+0x50>
 8003328:	4645      	mov	r5, r8
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800332a:	f04f 0900 	mov.w	r9, #0
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 800332e:	1d27      	adds	r7, r4, #4
 8003330:	2d06      	cmp	r5, #6
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8003332:	f884 9043 	strb.w	r9, [r4, #67]	; 0x43
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8003336:	4638      	mov	r0, r7
		pxTCB->uxMutexesHeld = 0;
 8003338:	f8c4 9050 	str.w	r9, [r4, #80]	; 0x50
 800333c:	bf28      	it	cs
 800333e:	2506      	movcs	r5, #6
	pxTCB->uxPriority = uxPriority;
 8003340:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxTCB->uxBasePriority = uxPriority;
 8003342:	64e5      	str	r5, [r4, #76]	; 0x4c
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003344:	f1c5 0507 	rsb	r5, r5, #7
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8003348:	f7ff f96f 	bl	800262a <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 800334c:	f104 0018 	add.w	r0, r4, #24
 8003350:	f7ff f96b 	bl	800262a <vListInitialiseItem>
		pxTCB->ulNotifiedValue = 0;
 8003354:	f8c4 9054 	str.w	r9, [r4, #84]	; 0x54
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 8003358:	6124      	str	r4, [r4, #16]
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800335a:	465a      	mov	r2, fp
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800335c:	61a5      	str	r5, [r4, #24]
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800335e:	4651      	mov	r1, sl
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 8003360:	6264      	str	r4, [r4, #36]	; 0x24
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8003362:	4630      	mov	r0, r6
		pxTCB->eNotifyState = eNotWaitingNotification;
 8003364:	f884 9058 	strb.w	r9, [r4, #88]	; 0x58
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8003368:	f7ff f9cc 	bl	8002704 <pxPortInitialiseStack>
		if( ( void * ) pxCreatedTask != NULL )
 800336c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800336e:	6020      	str	r0, [r4, #0]
		if( ( void * ) pxCreatedTask != NULL )
 8003370:	b103      	cbz	r3, 8003374 <xTaskGenericCreate.part.5+0xac>
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8003372:	601c      	str	r4, [r3, #0]
			uxCurrentNumberOfTasks++;
 8003374:	4d33      	ldr	r5, [pc, #204]	; (8003444 <xTaskGenericCreate.part.5+0x17c>)
		taskENTER_CRITICAL();
 8003376:	f7ff f9e5 	bl	8002744 <vPortEnterCritical>
			uxCurrentNumberOfTasks++;
 800337a:	696b      	ldr	r3, [r5, #20]
 800337c:	f105 0918 	add.w	r9, r5, #24
 8003380:	3301      	adds	r3, #1
 8003382:	616b      	str	r3, [r5, #20]
			if( pxCurrentTCB == NULL )
 8003384:	68ae      	ldr	r6, [r5, #8]
 8003386:	2e00      	cmp	r6, #0
 8003388:	d151      	bne.n	800342e <xTaskGenericCreate.part.5+0x166>
				pxCurrentTCB =  pxNewTCB;
 800338a:	60ac      	str	r4, [r5, #8]
				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 800338c:	696b      	ldr	r3, [r5, #20]
 800338e:	2b01      	cmp	r3, #1
 8003390:	d11e      	bne.n	80033d0 <xTaskGenericCreate.part.5+0x108>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8003392:	eb09 0006 	add.w	r0, r9, r6
 8003396:	3614      	adds	r6, #20
 8003398:	f7ff f93c 	bl	8002614 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800339c:	2e8c      	cmp	r6, #140	; 0x8c
 800339e:	d1f8      	bne.n	8003392 <xTaskGenericCreate.part.5+0xca>
	vListInitialise( &xDelayedTaskList1 );
 80033a0:	4e29      	ldr	r6, [pc, #164]	; (8003448 <xTaskGenericCreate.part.5+0x180>)
	vListInitialise( &xDelayedTaskList2 );
 80033a2:	f106 0a14 	add.w	sl, r6, #20
	vListInitialise( &xDelayedTaskList1 );
 80033a6:	4630      	mov	r0, r6
 80033a8:	f7ff f934 	bl	8002614 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 80033ac:	4650      	mov	r0, sl
 80033ae:	f7ff f931 	bl	8002614 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 80033b2:	f106 0028 	add.w	r0, r6, #40	; 0x28
 80033b6:	f7ff f92d 	bl	8002614 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 80033ba:	f106 003c 	add.w	r0, r6, #60	; 0x3c
 80033be:	f7ff f929 	bl	8002614 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 80033c2:	f106 0050 	add.w	r0, r6, #80	; 0x50
 80033c6:	f7ff f925 	bl	8002614 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 80033ca:	602e      	str	r6, [r5, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80033cc:	f8c5 a010 	str.w	sl, [r5, #16]
			uxTaskNumber++;
 80033d0:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
			prvAddTaskToReadyList( pxNewTCB );
 80033d4:	2014      	movs	r0, #20
 80033d6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
			uxTaskNumber++;
 80033d8:	3301      	adds	r3, #1
			prvAddTaskToReadyList( pxNewTCB );
 80033da:	f8d5 1110 	ldr.w	r1, [r5, #272]	; 0x110
 80033de:	fb00 9002 	mla	r0, r0, r2, r9
				pxNewTCB->uxTCBNumber = uxTaskNumber;
 80033e2:	6463      	str	r3, [r4, #68]	; 0x44
			prvAddTaskToReadyList( pxNewTCB );
 80033e4:	2401      	movs	r4, #1
			uxTaskNumber++;
 80033e6:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c
			prvAddTaskToReadyList( pxNewTCB );
 80033ea:	fa04 f302 	lsl.w	r3, r4, r2
 80033ee:	430b      	orrs	r3, r1
 80033f0:	4639      	mov	r1, r7
 80033f2:	f8c5 3110 	str.w	r3, [r5, #272]	; 0x110
 80033f6:	f7ff f91b 	bl	8002630 <vListInsertEnd>
		taskEXIT_CRITICAL();
 80033fa:	f7ff f9c9 	bl	8002790 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 80033fe:	f8d5 3108 	ldr.w	r3, [r5, #264]	; 0x108
 8003402:	b15b      	cbz	r3, 800341c <xTaskGenericCreate.part.5+0x154>
			if( pxCurrentTCB->uxPriority < uxPriority )
 8003404:	68ab      	ldr	r3, [r5, #8]
 8003406:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003408:	4598      	cmp	r8, r3
 800340a:	d907      	bls.n	800341c <xTaskGenericCreate.part.5+0x154>
				taskYIELD_IF_USING_PREEMPTION();
 800340c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003410:	4b0e      	ldr	r3, [pc, #56]	; (800344c <xTaskGenericCreate.part.5+0x184>)
 8003412:	601a      	str	r2, [r3, #0]
 8003414:	f3bf 8f4f 	dsb	sy
 8003418:	f3bf 8f6f 	isb	sy
}
 800341c:	4620      	mov	r0, r4
 800341e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				vPortFree( pxStack );
 8003422:	4628      	mov	r0, r5
 8003424:	f7ff fb5a 	bl	8002adc <vPortFree>
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8003428:	f04f 34ff 	mov.w	r4, #4294967295
 800342c:	e7f6      	b.n	800341c <xTaskGenericCreate.part.5+0x154>
				if( xSchedulerRunning == pdFALSE )
 800342e:	f8d5 3108 	ldr.w	r3, [r5, #264]	; 0x108
 8003432:	2b00      	cmp	r3, #0
 8003434:	d1cc      	bne.n	80033d0 <xTaskGenericCreate.part.5+0x108>
					if( pxCurrentTCB->uxPriority <= uxPriority )
 8003436:	68ab      	ldr	r3, [r5, #8]
 8003438:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800343a:	4598      	cmp	r8, r3
 800343c:	d3c8      	bcc.n	80033d0 <xTaskGenericCreate.part.5+0x108>
						pxCurrentTCB = pxNewTCB;
 800343e:	60ac      	str	r4, [r5, #8]
 8003440:	e7c6      	b.n	80033d0 <xTaskGenericCreate.part.5+0x108>
 8003442:	bf00      	nop
 8003444:	20003c84 	.word	0x20003c84
 8003448:	20003d28 	.word	0x20003d28
 800344c:	e000ed04 	.word	0xe000ed04

08003450 <prvTaskIsTaskSuspended.part.0>:
 8003450:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003454:	b672      	cpsid	i
 8003456:	f383 8811 	msr	BASEPRI, r3
 800345a:	f3bf 8f6f 	isb	sy
 800345e:	f3bf 8f4f 	dsb	sy
 8003462:	b662      	cpsie	i
 8003464:	e7fe      	b.n	8003464 <prvTaskIsTaskSuspended.part.0+0x14>

08003466 <xTaskGenericCreate>:
{
 8003466:	b470      	push	{r4, r5, r6}
 8003468:	ac03      	add	r4, sp, #12
 800346a:	cc70      	ldmia	r4, {r4, r5, r6}
	configASSERT( pxTaskCode );
 800346c:	b950      	cbnz	r0, 8003484 <xTaskGenericCreate+0x1e>
 800346e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003472:	b672      	cpsid	i
 8003474:	f383 8811 	msr	BASEPRI, r3
 8003478:	f3bf 8f6f 	isb	sy
 800347c:	f3bf 8f4f 	dsb	sy
 8003480:	b662      	cpsie	i
 8003482:	e7fe      	b.n	8003482 <xTaskGenericCreate+0x1c>
	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );
 8003484:	2c06      	cmp	r4, #6
 8003486:	d90a      	bls.n	800349e <xTaskGenericCreate+0x38>
 8003488:	f04f 0350 	mov.w	r3, #80	; 0x50
 800348c:	b672      	cpsid	i
 800348e:	f383 8811 	msr	BASEPRI, r3
 8003492:	f3bf 8f6f 	isb	sy
 8003496:	f3bf 8f4f 	dsb	sy
 800349a:	b662      	cpsie	i
 800349c:	e7fe      	b.n	800349c <xTaskGenericCreate+0x36>
 800349e:	9605      	str	r6, [sp, #20]
 80034a0:	9504      	str	r5, [sp, #16]
 80034a2:	9403      	str	r4, [sp, #12]
}
 80034a4:	bc70      	pop	{r4, r5, r6}
 80034a6:	f7ff bf0f 	b.w	80032c8 <xTaskGenericCreate.part.5>
	...

080034ac <vTaskStartScheduler>:
{
 80034ac:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80034ae:	2400      	movs	r4, #0
 80034b0:	2280      	movs	r2, #128	; 0x80
 80034b2:	4917      	ldr	r1, [pc, #92]	; (8003510 <vTaskStartScheduler+0x64>)
 80034b4:	9402      	str	r4, [sp, #8]
 80034b6:	4623      	mov	r3, r4
 80034b8:	9401      	str	r4, [sp, #4]
 80034ba:	9400      	str	r4, [sp, #0]
 80034bc:	4815      	ldr	r0, [pc, #84]	; (8003514 <vTaskStartScheduler+0x68>)
 80034be:	f7ff ff03 	bl	80032c8 <xTaskGenericCreate.part.5>
	if( xReturn == pdPASS )
 80034c2:	2801      	cmp	r0, #1
 80034c4:	d115      	bne.n	80034f2 <vTaskStartScheduler+0x46>
 80034c6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80034ca:	b672      	cpsid	i
 80034cc:	f383 8811 	msr	BASEPRI, r3
 80034d0:	f3bf 8f6f 	isb	sy
 80034d4:	f3bf 8f4f 	dsb	sy
 80034d8:	b662      	cpsie	i
		xNextTaskUnblockTime = portMAX_DELAY;
 80034da:	4b0f      	ldr	r3, [pc, #60]	; (8003518 <vTaskStartScheduler+0x6c>)
 80034dc:	f04f 32ff 	mov.w	r2, #4294967295
 80034e0:	605a      	str	r2, [r3, #4]
		xSchedulerRunning = pdTRUE;
 80034e2:	f8c3 0108 	str.w	r0, [r3, #264]	; 0x108
		xTickCount = ( TickType_t ) 0U;
 80034e6:	60dc      	str	r4, [r3, #12]
}
 80034e8:	b004      	add	sp, #16
 80034ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		if( xPortStartScheduler() != pdFALSE )
 80034ee:	f7ff b9c5 	b.w	800287c <xPortStartScheduler>
		configASSERT( xReturn );
 80034f2:	b950      	cbnz	r0, 800350a <vTaskStartScheduler+0x5e>
 80034f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80034f8:	b672      	cpsid	i
 80034fa:	f383 8811 	msr	BASEPRI, r3
 80034fe:	f3bf 8f6f 	isb	sy
 8003502:	f3bf 8f4f 	dsb	sy
 8003506:	b662      	cpsie	i
 8003508:	e7fe      	b.n	8003508 <vTaskStartScheduler+0x5c>
}
 800350a:	b004      	add	sp, #16
 800350c:	bd10      	pop	{r4, pc}
 800350e:	bf00      	nop
 8003510:	08009d94 	.word	0x08009d94
 8003514:	08003789 	.word	0x08003789
 8003518:	20003c84 	.word	0x20003c84

0800351c <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 800351c:	4a03      	ldr	r2, [pc, #12]	; (800352c <vTaskSuspendAll+0x10>)
 800351e:	f8d2 3118 	ldr.w	r3, [r2, #280]	; 0x118
 8003522:	3301      	adds	r3, #1
 8003524:	f8c2 3118 	str.w	r3, [r2, #280]	; 0x118
 8003528:	4770      	bx	lr
 800352a:	bf00      	nop
 800352c:	20003c84 	.word	0x20003c84

08003530 <xTaskGetTickCount>:
		xTicks = xTickCount;
 8003530:	4b01      	ldr	r3, [pc, #4]	; (8003538 <xTaskGetTickCount+0x8>)
 8003532:	68d8      	ldr	r0, [r3, #12]
}
 8003534:	4770      	bx	lr
 8003536:	bf00      	nop
 8003538:	20003c84 	.word	0x20003c84

0800353c <xTaskIncrementTick>:
{
 800353c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8003540:	4b38      	ldr	r3, [pc, #224]	; (8003624 <xTaskIncrementTick+0xe8>)
 8003542:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8003546:	461c      	mov	r4, r3
 8003548:	2a00      	cmp	r2, #0
 800354a:	d13e      	bne.n	80035ca <xTaskIncrementTick+0x8e>
		++xTickCount;
 800354c:	68da      	ldr	r2, [r3, #12]
 800354e:	3201      	adds	r2, #1
 8003550:	60da      	str	r2, [r3, #12]
			const TickType_t xConstTickCount = xTickCount;
 8003552:	68df      	ldr	r7, [r3, #12]
			if( xConstTickCount == ( TickType_t ) 0U )
 8003554:	b9c7      	cbnz	r7, 8003588 <xTaskIncrementTick+0x4c>
				taskSWITCH_DELAYED_LISTS();
 8003556:	681b      	ldr	r3, [r3, #0]
 8003558:	681b      	ldr	r3, [r3, #0]
 800355a:	b153      	cbz	r3, 8003572 <xTaskIncrementTick+0x36>
 800355c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003560:	b672      	cpsid	i
 8003562:	f383 8811 	msr	BASEPRI, r3
 8003566:	f3bf 8f6f 	isb	sy
 800356a:	f3bf 8f4f 	dsb	sy
 800356e:	b662      	cpsie	i
 8003570:	e7fe      	b.n	8003570 <xTaskIncrementTick+0x34>
 8003572:	6823      	ldr	r3, [r4, #0]
 8003574:	6922      	ldr	r2, [r4, #16]
 8003576:	6022      	str	r2, [r4, #0]
 8003578:	6123      	str	r3, [r4, #16]
 800357a:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
 800357e:	3301      	adds	r3, #1
 8003580:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
 8003584:	f7ff fe74 	bl	8003270 <prvResetNextTaskUnblockTime>
			if( xConstTickCount >= xNextTaskUnblockTime )
 8003588:	6863      	ldr	r3, [r4, #4]
 800358a:	2500      	movs	r5, #0
 800358c:	429f      	cmp	r7, r3
 800358e:	d30b      	bcc.n	80035a8 <xTaskIncrementTick+0x6c>
						prvAddTaskToReadyList( pxTCB );
 8003590:	f04f 0901 	mov.w	r9, #1
 8003594:	f8df a090 	ldr.w	sl, [pc, #144]	; 8003628 <xTaskIncrementTick+0xec>
 8003598:	f04f 0b14 	mov.w	fp, #20
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800359c:	6823      	ldr	r3, [r4, #0]
 800359e:	681b      	ldr	r3, [r3, #0]
 80035a0:	b9d3      	cbnz	r3, 80035d8 <xTaskIncrementTick+0x9c>
						xNextTaskUnblockTime = portMAX_DELAY;
 80035a2:	f04f 33ff 	mov.w	r3, #4294967295
 80035a6:	6063      	str	r3, [r4, #4]
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 80035a8:	68a3      	ldr	r3, [r4, #8]
 80035aa:	2214      	movs	r2, #20
 80035ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80035ae:	fb02 4303 	mla	r3, r2, r3, r4
 80035b2:	699b      	ldr	r3, [r3, #24]
				xSwitchRequired = pdTRUE;
 80035b4:	2b02      	cmp	r3, #2
 80035b6:	bf28      	it	cs
 80035b8:	2501      	movcs	r5, #1
		if( xYieldPending != pdFALSE )
 80035ba:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
			xSwitchRequired = pdTRUE;
 80035be:	2b00      	cmp	r3, #0
 80035c0:	bf18      	it	ne
 80035c2:	2501      	movne	r5, #1
}
 80035c4:	4628      	mov	r0, r5
 80035c6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		++uxPendedTicks;
 80035ca:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
BaseType_t xSwitchRequired = pdFALSE;
 80035ce:	2500      	movs	r5, #0
		++uxPendedTicks;
 80035d0:	3301      	adds	r3, #1
 80035d2:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120
 80035d6:	e7f0      	b.n	80035ba <xTaskIncrementTick+0x7e>
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 80035d8:	6823      	ldr	r3, [r4, #0]
 80035da:	68db      	ldr	r3, [r3, #12]
 80035dc:	68de      	ldr	r6, [r3, #12]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 80035de:	6873      	ldr	r3, [r6, #4]
						if( xConstTickCount < xItemValue )
 80035e0:	429f      	cmp	r7, r3
 80035e2:	d3e0      	bcc.n	80035a6 <xTaskIncrementTick+0x6a>
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 80035e4:	f106 0804 	add.w	r8, r6, #4
 80035e8:	4640      	mov	r0, r8
 80035ea:	f7ff f844 	bl	8002676 <uxListRemove>
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80035ee:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 80035f0:	b11b      	cbz	r3, 80035fa <xTaskIncrementTick+0xbe>
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80035f2:	f106 0018 	add.w	r0, r6, #24
 80035f6:	f7ff f83e 	bl	8002676 <uxListRemove>
						prvAddTaskToReadyList( pxTCB );
 80035fa:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 80035fc:	4641      	mov	r1, r8
 80035fe:	f8d4 2110 	ldr.w	r2, [r4, #272]	; 0x110
 8003602:	fa09 f300 	lsl.w	r3, r9, r0
 8003606:	fb0b a000 	mla	r0, fp, r0, sl
 800360a:	4313      	orrs	r3, r2
 800360c:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
 8003610:	f7ff f80e 	bl	8002630 <vListInsertEnd>
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8003614:	68a3      	ldr	r3, [r4, #8]
 8003616:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8003618:	6adb      	ldr	r3, [r3, #44]	; 0x2c
								xSwitchRequired = pdTRUE;
 800361a:	429a      	cmp	r2, r3
 800361c:	bf28      	it	cs
 800361e:	2501      	movcs	r5, #1
 8003620:	e7bc      	b.n	800359c <xTaskIncrementTick+0x60>
 8003622:	bf00      	nop
 8003624:	20003c84 	.word	0x20003c84
 8003628:	20003c9c 	.word	0x20003c9c

0800362c <xTaskResumeAll>:
{
 800362c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( uxSchedulerSuspended );
 8003630:	4c36      	ldr	r4, [pc, #216]	; (800370c <xTaskResumeAll+0xe0>)
 8003632:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 8003636:	b953      	cbnz	r3, 800364e <xTaskResumeAll+0x22>
 8003638:	f04f 0350 	mov.w	r3, #80	; 0x50
 800363c:	b672      	cpsid	i
 800363e:	f383 8811 	msr	BASEPRI, r3
 8003642:	f3bf 8f6f 	isb	sy
 8003646:	f3bf 8f4f 	dsb	sy
 800364a:	b662      	cpsie	i
 800364c:	e7fe      	b.n	800364c <xTaskResumeAll+0x20>
	taskENTER_CRITICAL();
 800364e:	f7ff f879 	bl	8002744 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8003652:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 8003656:	3b01      	subs	r3, #1
 8003658:	f8c4 3118 	str.w	r3, [r4, #280]	; 0x118
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800365c:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 8003660:	b12b      	cbz	r3, 800366e <xTaskResumeAll+0x42>
BaseType_t xAlreadyYielded = pdFALSE;
 8003662:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8003664:	f7ff f894 	bl	8002790 <vPortExitCritical>
}
 8003668:	4620      	mov	r0, r4
 800366a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800366e:	6963      	ldr	r3, [r4, #20]
 8003670:	2b00      	cmp	r3, #0
 8003672:	d0f6      	beq.n	8003662 <xTaskResumeAll+0x36>
					prvAddTaskToReadyList( pxTCB );
 8003674:	2601      	movs	r6, #1
 8003676:	f104 0718 	add.w	r7, r4, #24
 800367a:	e01f      	b.n	80036bc <xTaskResumeAll+0x90>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 800367c:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
 8003680:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8003682:	f105 0904 	add.w	r9, r5, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8003686:	f105 0018 	add.w	r0, r5, #24
 800368a:	f7fe fff4 	bl	8002676 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 800368e:	4648      	mov	r0, r9
 8003690:	f7fe fff1 	bl	8002676 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8003694:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8003696:	f8d4 2110 	ldr.w	r2, [r4, #272]	; 0x110
 800369a:	4649      	mov	r1, r9
 800369c:	fa06 f300 	lsl.w	r3, r6, r0
 80036a0:	fb08 7000 	mla	r0, r8, r0, r7
 80036a4:	4313      	orrs	r3, r2
 80036a6:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
 80036aa:	f7fe ffc1 	bl	8002630 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80036ae:	68a3      	ldr	r3, [r4, #8]
 80036b0:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 80036b2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80036b4:	429a      	cmp	r2, r3
 80036b6:	d303      	bcc.n	80036c0 <xTaskResumeAll+0x94>
						xYieldPending = pdTRUE;
 80036b8:	f8c4 6124 	str.w	r6, [r4, #292]	; 0x124
					prvAddTaskToReadyList( pxTCB );
 80036bc:	f04f 0814 	mov.w	r8, #20
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80036c0:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 80036c4:	2b00      	cmp	r3, #0
 80036c6:	d1d9      	bne.n	800367c <xTaskResumeAll+0x50>
				if( uxPendedTicks > ( UBaseType_t ) 0U )
 80036c8:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
 80036cc:	b9db      	cbnz	r3, 8003706 <xTaskResumeAll+0xda>
				if( xYieldPending == pdTRUE )
 80036ce:	f8d4 4124 	ldr.w	r4, [r4, #292]	; 0x124
 80036d2:	2c01      	cmp	r4, #1
 80036d4:	d1c5      	bne.n	8003662 <xTaskResumeAll+0x36>
					taskYIELD_IF_USING_PREEMPTION();
 80036d6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80036da:	4b0d      	ldr	r3, [pc, #52]	; (8003710 <xTaskResumeAll+0xe4>)
 80036dc:	601a      	str	r2, [r3, #0]
 80036de:	f3bf 8f4f 	dsb	sy
 80036e2:	f3bf 8f6f 	isb	sy
 80036e6:	e7bd      	b.n	8003664 <xTaskResumeAll+0x38>
						if( xTaskIncrementTick() != pdFALSE )
 80036e8:	f7ff ff28 	bl	800353c <xTaskIncrementTick>
 80036ec:	b108      	cbz	r0, 80036f2 <xTaskResumeAll+0xc6>
							xYieldPending = pdTRUE;
 80036ee:	f8c4 5124 	str.w	r5, [r4, #292]	; 0x124
						--uxPendedTicks;
 80036f2:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
 80036f6:	3b01      	subs	r3, #1
 80036f8:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 80036fc:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
 8003700:	2b00      	cmp	r3, #0
 8003702:	d1f1      	bne.n	80036e8 <xTaskResumeAll+0xbc>
 8003704:	e7e3      	b.n	80036ce <xTaskResumeAll+0xa2>
							xYieldPending = pdTRUE;
 8003706:	2501      	movs	r5, #1
 8003708:	e7f8      	b.n	80036fc <xTaskResumeAll+0xd0>
 800370a:	bf00      	nop
 800370c:	20003c84 	.word	0x20003c84
 8003710:	e000ed04 	.word	0xe000ed04

08003714 <vTaskDelay>:
	{
 8003714:	b538      	push	{r3, r4, r5, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 8003716:	b940      	cbnz	r0, 800372a <vTaskDelay+0x16>
			portYIELD_WITHIN_API();
 8003718:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800371c:	4b18      	ldr	r3, [pc, #96]	; (8003780 <vTaskDelay+0x6c>)
 800371e:	601a      	str	r2, [r3, #0]
 8003720:	f3bf 8f4f 	dsb	sy
 8003724:	f3bf 8f6f 	isb	sy
 8003728:	bd38      	pop	{r3, r4, r5, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 800372a:	4c16      	ldr	r4, [pc, #88]	; (8003784 <vTaskDelay+0x70>)
 800372c:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 8003730:	b153      	cbz	r3, 8003748 <vTaskDelay+0x34>
 8003732:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003736:	b672      	cpsid	i
 8003738:	f383 8811 	msr	BASEPRI, r3
 800373c:	f3bf 8f6f 	isb	sy
 8003740:	f3bf 8f4f 	dsb	sy
 8003744:	b662      	cpsie	i
 8003746:	e7fe      	b.n	8003746 <vTaskDelay+0x32>
			vTaskSuspendAll();
 8003748:	f7ff fee8 	bl	800351c <vTaskSuspendAll>
				xTimeToWake = xTickCount + xTicksToDelay;
 800374c:	68e5      	ldr	r5, [r4, #12]
 800374e:	4405      	add	r5, r0
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8003750:	68a0      	ldr	r0, [r4, #8]
 8003752:	3004      	adds	r0, #4
 8003754:	f7fe ff8f 	bl	8002676 <uxListRemove>
 8003758:	b948      	cbnz	r0, 800376e <vTaskDelay+0x5a>
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 800375a:	68a2      	ldr	r2, [r4, #8]
 800375c:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
 8003760:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8003762:	2201      	movs	r2, #1
 8003764:	408a      	lsls	r2, r1
 8003766:	ea23 0302 	bic.w	r3, r3, r2
 800376a:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 800376e:	4628      	mov	r0, r5
 8003770:	f7ff fd8e 	bl	8003290 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 8003774:	f7ff ff5a 	bl	800362c <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 8003778:	2800      	cmp	r0, #0
 800377a:	d0cd      	beq.n	8003718 <vTaskDelay+0x4>
 800377c:	bd38      	pop	{r3, r4, r5, pc}
 800377e:	bf00      	nop
 8003780:	e000ed04 	.word	0xe000ed04
 8003784:	20003c84 	.word	0x20003c84

08003788 <prvIdleTask>:
{
 8003788:	b580      	push	{r7, lr}
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 800378a:	4c18      	ldr	r4, [pc, #96]	; (80037ec <prvIdleTask+0x64>)
				taskYIELD();
 800378c:	f04f 5780 	mov.w	r7, #268435456	; 0x10000000
 8003790:	4e17      	ldr	r6, [pc, #92]	; (80037f0 <prvIdleTask+0x68>)
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 8003792:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
 8003796:	b943      	cbnz	r3, 80037aa <prvIdleTask+0x22>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8003798:	69a3      	ldr	r3, [r4, #24]
 800379a:	2b01      	cmp	r3, #1
 800379c:	d9f9      	bls.n	8003792 <prvIdleTask+0xa>
				taskYIELD();
 800379e:	6037      	str	r7, [r6, #0]
 80037a0:	f3bf 8f4f 	dsb	sy
 80037a4:	f3bf 8f6f 	isb	sy
 80037a8:	e7f3      	b.n	8003792 <prvIdleTask+0xa>
			vTaskSuspendAll();
 80037aa:	f7ff feb7 	bl	800351c <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 80037ae:	f8d4 50e0 	ldr.w	r5, [r4, #224]	; 0xe0
			( void ) xTaskResumeAll();
 80037b2:	f7ff ff3b 	bl	800362c <xTaskResumeAll>
			if( xListIsEmpty == pdFALSE )
 80037b6:	2d00      	cmp	r5, #0
 80037b8:	d0eb      	beq.n	8003792 <prvIdleTask+0xa>
				taskENTER_CRITICAL();
 80037ba:	f7fe ffc3 	bl	8002744 <vPortEnterCritical>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 80037be:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 80037c2:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 80037c4:	1d28      	adds	r0, r5, #4
 80037c6:	f7fe ff56 	bl	8002676 <uxListRemove>
					--uxCurrentNumberOfTasks;
 80037ca:	6963      	ldr	r3, [r4, #20]
 80037cc:	3b01      	subs	r3, #1
 80037ce:	6163      	str	r3, [r4, #20]
					--uxTasksDeleted;
 80037d0:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
 80037d4:	3b01      	subs	r3, #1
 80037d6:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
				taskEXIT_CRITICAL();
 80037da:	f7fe ffd9 	bl	8002790 <vPortExitCritical>
			vPortFreeAligned( pxTCB->pxStack );
 80037de:	6b28      	ldr	r0, [r5, #48]	; 0x30
 80037e0:	f7ff f97c 	bl	8002adc <vPortFree>
		vPortFree( pxTCB );
 80037e4:	4628      	mov	r0, r5
 80037e6:	f7ff f979 	bl	8002adc <vPortFree>
 80037ea:	e7d2      	b.n	8003792 <prvIdleTask+0xa>
 80037ec:	20003c84 	.word	0x20003c84
 80037f0:	e000ed04 	.word	0xe000ed04

080037f4 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80037f4:	4b19      	ldr	r3, [pc, #100]	; (800385c <vTaskSwitchContext+0x68>)
 80037f6:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80037fa:	4618      	mov	r0, r3
{
 80037fc:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80037fe:	b11a      	cbz	r2, 8003808 <vTaskSwitchContext+0x14>
		xYieldPending = pdTRUE;
 8003800:	2201      	movs	r2, #1
 8003802:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
 8003806:	bd10      	pop	{r4, pc}
		xYieldPending = pdFALSE;
 8003808:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800380c:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 8003810:	fab2 f282 	clz	r2, r2
 8003814:	b2d2      	uxtb	r2, r2
 8003816:	2114      	movs	r1, #20
 8003818:	f1c2 021f 	rsb	r2, r2, #31
 800381c:	4351      	muls	r1, r2
 800381e:	440b      	add	r3, r1
 8003820:	699c      	ldr	r4, [r3, #24]
 8003822:	b954      	cbnz	r4, 800383a <vTaskSwitchContext+0x46>
	__asm volatile
 8003824:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003828:	b672      	cpsid	i
 800382a:	f383 8811 	msr	BASEPRI, r3
 800382e:	f3bf 8f6f 	isb	sy
 8003832:	f3bf 8f4f 	dsb	sy
 8003836:	b662      	cpsie	i
 8003838:	e7fe      	b.n	8003838 <vTaskSwitchContext+0x44>
 800383a:	69dc      	ldr	r4, [r3, #28]
 800383c:	4401      	add	r1, r0
 800383e:	6864      	ldr	r4, [r4, #4]
 8003840:	3120      	adds	r1, #32
 8003842:	428c      	cmp	r4, r1
 8003844:	61dc      	str	r4, [r3, #28]
 8003846:	bf04      	itt	eq
 8003848:	6861      	ldreq	r1, [r4, #4]
 800384a:	61d9      	streq	r1, [r3, #28]
 800384c:	2314      	movs	r3, #20
 800384e:	fb03 0202 	mla	r2, r3, r2, r0
 8003852:	69d3      	ldr	r3, [r2, #28]
 8003854:	68db      	ldr	r3, [r3, #12]
 8003856:	6083      	str	r3, [r0, #8]
 8003858:	bd10      	pop	{r4, pc}
 800385a:	bf00      	nop
 800385c:	20003c84 	.word	0x20003c84

08003860 <vTaskPlaceOnEventList>:
{
 8003860:	b538      	push	{r3, r4, r5, lr}
 8003862:	460d      	mov	r5, r1
	configASSERT( pxEventList );
 8003864:	b950      	cbnz	r0, 800387c <vTaskPlaceOnEventList+0x1c>
 8003866:	f04f 0350 	mov.w	r3, #80	; 0x50
 800386a:	b672      	cpsid	i
 800386c:	f383 8811 	msr	BASEPRI, r3
 8003870:	f3bf 8f6f 	isb	sy
 8003874:	f3bf 8f4f 	dsb	sy
 8003878:	b662      	cpsie	i
 800387a:	e7fe      	b.n	800387a <vTaskPlaceOnEventList+0x1a>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800387c:	4c11      	ldr	r4, [pc, #68]	; (80038c4 <vTaskPlaceOnEventList+0x64>)
 800387e:	68a1      	ldr	r1, [r4, #8]
 8003880:	3118      	adds	r1, #24
 8003882:	f7fe fee1 	bl	8002648 <vListInsert>
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8003886:	68a0      	ldr	r0, [r4, #8]
 8003888:	3004      	adds	r0, #4
 800388a:	f7fe fef4 	bl	8002676 <uxListRemove>
 800388e:	4623      	mov	r3, r4
 8003890:	b948      	cbnz	r0, 80038a6 <vTaskPlaceOnEventList+0x46>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8003892:	68a1      	ldr	r1, [r4, #8]
 8003894:	f8d4 2110 	ldr.w	r2, [r4, #272]	; 0x110
 8003898:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
 800389a:	2101      	movs	r1, #1
 800389c:	4081      	lsls	r1, r0
 800389e:	ea22 0201 	bic.w	r2, r2, r1
 80038a2:	f8c4 2110 	str.w	r2, [r4, #272]	; 0x110
		if( xTicksToWait == portMAX_DELAY )
 80038a6:	1c6a      	adds	r2, r5, #1
 80038a8:	d106      	bne.n	80038b8 <vTaskPlaceOnEventList+0x58>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80038aa:	6899      	ldr	r1, [r3, #8]
 80038ac:	4806      	ldr	r0, [pc, #24]	; (80038c8 <vTaskPlaceOnEventList+0x68>)
 80038ae:	3104      	adds	r1, #4
}
 80038b0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80038b4:	f7fe bebc 	b.w	8002630 <vListInsertEnd>
			xTimeToWake = xTickCount + xTicksToWait;
 80038b8:	68d8      	ldr	r0, [r3, #12]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 80038ba:	4428      	add	r0, r5
}
 80038bc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 80038c0:	f7ff bce6 	b.w	8003290 <prvAddCurrentTaskToDelayedList>
 80038c4:	20003c84 	.word	0x20003c84
 80038c8:	20003d78 	.word	0x20003d78

080038cc <xTaskRemoveFromEventList>:
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 80038cc:	68c3      	ldr	r3, [r0, #12]
{
 80038ce:	b570      	push	{r4, r5, r6, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 80038d0:	68dd      	ldr	r5, [r3, #12]
	configASSERT( pxUnblockedTCB );
 80038d2:	b955      	cbnz	r5, 80038ea <xTaskRemoveFromEventList+0x1e>
 80038d4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80038d8:	b672      	cpsid	i
 80038da:	f383 8811 	msr	BASEPRI, r3
 80038de:	f3bf 8f6f 	isb	sy
 80038e2:	f3bf 8f4f 	dsb	sy
 80038e6:	b662      	cpsie	i
 80038e8:	e7fe      	b.n	80038e8 <xTaskRemoveFromEventList+0x1c>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 80038ea:	f105 0618 	add.w	r6, r5, #24
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80038ee:	4c15      	ldr	r4, [pc, #84]	; (8003944 <xTaskRemoveFromEventList+0x78>)
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 80038f0:	4630      	mov	r0, r6
 80038f2:	f7fe fec0 	bl	8002676 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80038f6:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 80038fa:	b9e3      	cbnz	r3, 8003936 <xTaskRemoveFromEventList+0x6a>
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 80038fc:	1d2e      	adds	r6, r5, #4
 80038fe:	4630      	mov	r0, r6
 8003900:	f7fe feb9 	bl	8002676 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8003904:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8003906:	2301      	movs	r3, #1
 8003908:	f8d4 1110 	ldr.w	r1, [r4, #272]	; 0x110
 800390c:	2014      	movs	r0, #20
 800390e:	4093      	lsls	r3, r2
 8003910:	430b      	orrs	r3, r1
 8003912:	4631      	mov	r1, r6
 8003914:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
 8003918:	f104 0318 	add.w	r3, r4, #24
 800391c:	fb00 3002 	mla	r0, r0, r2, r3
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8003920:	f7fe fe86 	bl	8002630 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8003924:	68a3      	ldr	r3, [r4, #8]
 8003926:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8003928:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800392a:	429a      	cmp	r2, r3
 800392c:	d907      	bls.n	800393e <xTaskRemoveFromEventList+0x72>
		xYieldPending = pdTRUE;
 800392e:	2001      	movs	r0, #1
 8003930:	f8c4 0124 	str.w	r0, [r4, #292]	; 0x124
 8003934:	bd70      	pop	{r4, r5, r6, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8003936:	4631      	mov	r1, r6
 8003938:	f104 00cc 	add.w	r0, r4, #204	; 0xcc
 800393c:	e7f0      	b.n	8003920 <xTaskRemoveFromEventList+0x54>
		xReturn = pdFALSE;
 800393e:	2000      	movs	r0, #0
}
 8003940:	bd70      	pop	{r4, r5, r6, pc}
 8003942:	bf00      	nop
 8003944:	20003c84 	.word	0x20003c84

08003948 <vTaskSetTimeOutState>:
{
 8003948:	b508      	push	{r3, lr}
	configASSERT( pxTimeOut );
 800394a:	b908      	cbnz	r0, 8003950 <vTaskSetTimeOutState+0x8>
 800394c:	f7ff fd80 	bl	8003450 <prvTaskIsTaskSuspended.part.0>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8003950:	4b03      	ldr	r3, [pc, #12]	; (8003960 <vTaskSetTimeOutState+0x18>)
 8003952:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
	pxTimeOut->xTimeOnEntering = xTickCount;
 8003956:	68db      	ldr	r3, [r3, #12]
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8003958:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800395a:	6043      	str	r3, [r0, #4]
 800395c:	bd08      	pop	{r3, pc}
 800395e:	bf00      	nop
 8003960:	20003c84 	.word	0x20003c84

08003964 <xTaskCheckForTimeOut>:
{
 8003964:	b538      	push	{r3, r4, r5, lr}
 8003966:	460d      	mov	r5, r1
	configASSERT( pxTimeOut );
 8003968:	4604      	mov	r4, r0
 800396a:	b950      	cbnz	r0, 8003982 <xTaskCheckForTimeOut+0x1e>
 800396c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003970:	b672      	cpsid	i
 8003972:	f383 8811 	msr	BASEPRI, r3
 8003976:	f3bf 8f6f 	isb	sy
 800397a:	f3bf 8f4f 	dsb	sy
 800397e:	b662      	cpsie	i
 8003980:	e7fe      	b.n	8003980 <xTaskCheckForTimeOut+0x1c>
	configASSERT( pxTicksToWait );
 8003982:	b951      	cbnz	r1, 800399a <xTaskCheckForTimeOut+0x36>
 8003984:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003988:	b672      	cpsid	i
 800398a:	f383 8811 	msr	BASEPRI, r3
 800398e:	f3bf 8f6f 	isb	sy
 8003992:	f3bf 8f4f 	dsb	sy
 8003996:	b662      	cpsie	i
 8003998:	e7fe      	b.n	8003998 <xTaskCheckForTimeOut+0x34>
	taskENTER_CRITICAL();
 800399a:	f7fe fed3 	bl	8002744 <vPortEnterCritical>
			if( *pxTicksToWait == portMAX_DELAY )
 800399e:	682b      	ldr	r3, [r5, #0]
		const TickType_t xConstTickCount = xTickCount;
 80039a0:	4a0d      	ldr	r2, [pc, #52]	; (80039d8 <xTaskCheckForTimeOut+0x74>)
			if( *pxTicksToWait == portMAX_DELAY )
 80039a2:	1c58      	adds	r0, r3, #1
		const TickType_t xConstTickCount = xTickCount;
 80039a4:	68d1      	ldr	r1, [r2, #12]
			if( *pxTicksToWait == portMAX_DELAY )
 80039a6:	d010      	beq.n	80039ca <xTaskCheckForTimeOut+0x66>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 80039a8:	f8d2 211c 	ldr.w	r2, [r2, #284]	; 0x11c
 80039ac:	6820      	ldr	r0, [r4, #0]
 80039ae:	4290      	cmp	r0, r2
 80039b0:	6862      	ldr	r2, [r4, #4]
 80039b2:	d001      	beq.n	80039b8 <xTaskCheckForTimeOut+0x54>
 80039b4:	4291      	cmp	r1, r2
 80039b6:	d20d      	bcs.n	80039d4 <xTaskCheckForTimeOut+0x70>
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 80039b8:	1a88      	subs	r0, r1, r2
 80039ba:	4283      	cmp	r3, r0
 80039bc:	d90a      	bls.n	80039d4 <xTaskCheckForTimeOut+0x70>
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 80039be:	1a5b      	subs	r3, r3, r1
			vTaskSetTimeOutState( pxTimeOut );
 80039c0:	4620      	mov	r0, r4
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 80039c2:	4413      	add	r3, r2
 80039c4:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 80039c6:	f7ff ffbf 	bl	8003948 <vTaskSetTimeOutState>
				xReturn = pdFALSE;
 80039ca:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 80039cc:	f7fe fee0 	bl	8002790 <vPortExitCritical>
}
 80039d0:	4620      	mov	r0, r4
 80039d2:	bd38      	pop	{r3, r4, r5, pc}
			xReturn = pdTRUE;
 80039d4:	2401      	movs	r4, #1
 80039d6:	e7f9      	b.n	80039cc <xTaskCheckForTimeOut+0x68>
 80039d8:	20003c84 	.word	0x20003c84

080039dc <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 80039dc:	2201      	movs	r2, #1
 80039de:	4b02      	ldr	r3, [pc, #8]	; (80039e8 <vTaskMissedYield+0xc>)
 80039e0:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
 80039e4:	4770      	bx	lr
 80039e6:	bf00      	nop
 80039e8:	20003c84 	.word	0x20003c84

080039ec <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 80039ec:	4b06      	ldr	r3, [pc, #24]	; (8003a08 <xTaskGetSchedulerState+0x1c>)
 80039ee:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
 80039f2:	b132      	cbz	r2, 8003a02 <xTaskGetSchedulerState+0x16>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80039f4:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 80039f8:	2b00      	cmp	r3, #0
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 80039fa:	bf0c      	ite	eq
 80039fc:	2002      	moveq	r0, #2
 80039fe:	2000      	movne	r0, #0
 8003a00:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 8003a02:	2001      	movs	r0, #1
			}
		}

		return xReturn;
	}
 8003a04:	4770      	bx	lr
 8003a06:	bf00      	nop
 8003a08:	20003c84 	.word	0x20003c84

08003a0c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
 8003a0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
 8003a10:	4605      	mov	r5, r0
 8003a12:	2800      	cmp	r0, #0
 8003a14:	d03c      	beq.n	8003a90 <vTaskPriorityInherit+0x84>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 8003a16:	4c1f      	ldr	r4, [pc, #124]	; (8003a94 <vTaskPriorityInherit+0x88>)
 8003a18:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8003a1a:	68a2      	ldr	r2, [r4, #8]
 8003a1c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8003a1e:	4293      	cmp	r3, r2
 8003a20:	d236      	bcs.n	8003a90 <vTaskPriorityInherit+0x84>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8003a22:	6982      	ldr	r2, [r0, #24]
 8003a24:	2a00      	cmp	r2, #0
 8003a26:	db04      	blt.n	8003a32 <vTaskPriorityInherit+0x26>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003a28:	68a2      	ldr	r2, [r4, #8]
 8003a2a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8003a2c:	f1c2 0207 	rsb	r2, r2, #7
 8003a30:	6182      	str	r2, [r0, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8003a32:	4e19      	ldr	r6, [pc, #100]	; (8003a98 <vTaskPriorityInherit+0x8c>)
 8003a34:	2714      	movs	r7, #20
 8003a36:	696a      	ldr	r2, [r5, #20]
 8003a38:	fb07 6303 	mla	r3, r7, r3, r6
 8003a3c:	429a      	cmp	r2, r3
 8003a3e:	d124      	bne.n	8003a8a <vTaskPriorityInherit+0x7e>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8003a40:	f105 0804 	add.w	r8, r5, #4
 8003a44:	4640      	mov	r0, r8
 8003a46:	f7fe fe16 	bl	8002676 <uxListRemove>
 8003a4a:	b960      	cbnz	r0, 8003a66 <vTaskPriorityInherit+0x5a>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8003a4c:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 8003a4e:	fb07 4701 	mla	r7, r7, r1, r4
 8003a52:	69bb      	ldr	r3, [r7, #24]
 8003a54:	b93b      	cbnz	r3, 8003a66 <vTaskPriorityInherit+0x5a>
 8003a56:	2201      	movs	r2, #1
 8003a58:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
 8003a5c:	408a      	lsls	r2, r1
 8003a5e:	ea23 0302 	bic.w	r3, r3, r2
 8003a62:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8003a66:	68a3      	ldr	r3, [r4, #8]
					prvAddTaskToReadyList( pxTCB );
 8003a68:	2014      	movs	r0, #20
 8003a6a:	f8d4 1110 	ldr.w	r1, [r4, #272]	; 0x110
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8003a6e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 8003a70:	2301      	movs	r3, #1
 8003a72:	4093      	lsls	r3, r2
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8003a74:	62ea      	str	r2, [r5, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 8003a76:	fb00 6002 	mla	r0, r0, r2, r6
 8003a7a:	430b      	orrs	r3, r1
 8003a7c:	4641      	mov	r1, r8
 8003a7e:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8003a82:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
					prvAddTaskToReadyList( pxTCB );
 8003a86:	f7fe bdd3 	b.w	8002630 <vListInsertEnd>
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8003a8a:	68a3      	ldr	r3, [r4, #8]
 8003a8c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003a8e:	62eb      	str	r3, [r5, #44]	; 0x2c
 8003a90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003a94:	20003c84 	.word	0x20003c84
 8003a98:	20003c9c 	.word	0x20003c9c

08003a9c <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 8003a9c:	b570      	push	{r4, r5, r6, lr}
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
 8003a9e:	4604      	mov	r4, r0
 8003aa0:	b908      	cbnz	r0, 8003aa6 <xTaskPriorityDisinherit+0xa>
	BaseType_t xReturn = pdFALSE;
 8003aa2:	2000      	movs	r0, #0
 8003aa4:	bd70      	pop	{r4, r5, r6, pc}
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
 8003aa6:	4d26      	ldr	r5, [pc, #152]	; (8003b40 <xTaskPriorityDisinherit+0xa4>)
 8003aa8:	68ab      	ldr	r3, [r5, #8]
 8003aaa:	4298      	cmp	r0, r3
 8003aac:	d00a      	beq.n	8003ac4 <xTaskPriorityDisinherit+0x28>
 8003aae:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003ab2:	b672      	cpsid	i
 8003ab4:	f383 8811 	msr	BASEPRI, r3
 8003ab8:	f3bf 8f6f 	isb	sy
 8003abc:	f3bf 8f4f 	dsb	sy
 8003ac0:	b662      	cpsie	i
 8003ac2:	e7fe      	b.n	8003ac2 <xTaskPriorityDisinherit+0x26>

			configASSERT( pxTCB->uxMutexesHeld );
 8003ac4:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8003ac6:	b953      	cbnz	r3, 8003ade <xTaskPriorityDisinherit+0x42>
 8003ac8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003acc:	b672      	cpsid	i
 8003ace:	f383 8811 	msr	BASEPRI, r3
 8003ad2:	f3bf 8f6f 	isb	sy
 8003ad6:	f3bf 8f4f 	dsb	sy
 8003ada:	b662      	cpsie	i
 8003adc:	e7fe      	b.n	8003adc <xTaskPriorityDisinherit+0x40>
			( pxTCB->uxMutexesHeld )--;

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8003ade:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
			( pxTCB->uxMutexesHeld )--;
 8003ae0:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8003ae2:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
			( pxTCB->uxMutexesHeld )--;
 8003ae4:	6503      	str	r3, [r0, #80]	; 0x50
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8003ae6:	4291      	cmp	r1, r2
 8003ae8:	d0db      	beq.n	8003aa2 <xTaskPriorityDisinherit+0x6>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8003aea:	2b00      	cmp	r3, #0
 8003aec:	d1d9      	bne.n	8003aa2 <xTaskPriorityDisinherit+0x6>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8003aee:	1d06      	adds	r6, r0, #4
 8003af0:	4630      	mov	r0, r6
 8003af2:	f7fe fdc0 	bl	8002676 <uxListRemove>
 8003af6:	b968      	cbnz	r0, 8003b14 <xTaskPriorityDisinherit+0x78>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8003af8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8003afa:	2114      	movs	r1, #20
 8003afc:	fb01 5100 	mla	r1, r1, r0, r5
 8003b00:	698b      	ldr	r3, [r1, #24]
 8003b02:	b93b      	cbnz	r3, 8003b14 <xTaskPriorityDisinherit+0x78>
 8003b04:	2201      	movs	r2, #1
 8003b06:	f8d5 3110 	ldr.w	r3, [r5, #272]	; 0x110
 8003b0a:	4082      	lsls	r2, r0
 8003b0c:	ea23 0302 	bic.w	r3, r3, r2
 8003b10:	f8c5 3110 	str.w	r3, [r5, #272]	; 0x110
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8003b14:	6ce3      	ldr	r3, [r4, #76]	; 0x4c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
					prvAddTaskToReadyList( pxTCB );
 8003b16:	2014      	movs	r0, #20
 8003b18:	f8d5 1110 	ldr.w	r1, [r5, #272]	; 0x110
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003b1c:	f1c3 0207 	rsb	r2, r3, #7
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8003b20:	62e3      	str	r3, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003b22:	61a2      	str	r2, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 8003b24:	2401      	movs	r4, #1
 8003b26:	fa04 f203 	lsl.w	r2, r4, r3
 8003b2a:	430a      	orrs	r2, r1
 8003b2c:	4631      	mov	r1, r6
 8003b2e:	f8c5 2110 	str.w	r2, [r5, #272]	; 0x110
 8003b32:	4a04      	ldr	r2, [pc, #16]	; (8003b44 <xTaskPriorityDisinherit+0xa8>)
 8003b34:	fb00 2003 	mla	r0, r0, r3, r2
 8003b38:	f7fe fd7a 	bl	8002630 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
 8003b3c:	4620      	mov	r0, r4
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
 8003b3e:	bd70      	pop	{r4, r5, r6, pc}
 8003b40:	20003c84 	.word	0x20003c84
 8003b44:	20003c9c 	.word	0x20003c9c

08003b48 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
 8003b48:	4b04      	ldr	r3, [pc, #16]	; (8003b5c <pvTaskIncrementMutexHeldCount+0x14>)
 8003b4a:	689a      	ldr	r2, [r3, #8]
 8003b4c:	b11a      	cbz	r2, 8003b56 <pvTaskIncrementMutexHeldCount+0xe>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
 8003b4e:	6899      	ldr	r1, [r3, #8]
 8003b50:	6d0a      	ldr	r2, [r1, #80]	; 0x50
 8003b52:	3201      	adds	r2, #1
 8003b54:	650a      	str	r2, [r1, #80]	; 0x50
		}

		return pxCurrentTCB;
 8003b56:	6898      	ldr	r0, [r3, #8]
	}
 8003b58:	4770      	bx	lr
 8003b5a:	bf00      	nop
 8003b5c:	20003c84 	.word	0x20003c84

08003b60 <netconn_close_shutdown>:
 * @param how fully close or only shutdown one side?
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
static err_t
netconn_close_shutdown(struct netconn *conn, u8_t how)
{
 8003b60:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  API_MSG_VAR_DECLARE(msg);
  err_t err;
  LWIP_UNUSED_ARG(how);

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
 8003b62:	b170      	cbz	r0, 8003b82 <netconn_close_shutdown+0x22>
#if LWIP_SO_SNDTIMEO || LWIP_SO_LINGER
  /* get the time we started, which is later compared to
     sys_now() + conn->send_timeout */
  API_MSG_VAR_REF(msg).msg.msg.sd.time_started = sys_now();
#else /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
  API_MSG_VAR_REF(msg).msg.msg.sd.polls_left =
 8003b64:	2329      	movs	r3, #41	; 0x29
  API_MSG_VAR_REF(msg).msg.conn = conn;
 8003b66:	9001      	str	r0, [sp, #4]
    ((LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT + TCP_SLOW_INTERVAL - 1) / TCP_SLOW_INTERVAL) + 1;
#endif /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
#endif /* LWIP_TCP */
  TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_close, err);
 8003b68:	a806      	add	r0, sp, #24
  API_MSG_VAR_REF(msg).msg.msg.sd.shut = how;
 8003b6a:	f88d 100c 	strb.w	r1, [sp, #12]
  API_MSG_VAR_REF(msg).msg.msg.sd.polls_left =
 8003b6e:	f88d 300d 	strb.w	r3, [sp, #13]
  TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_close, err);
 8003b72:	4b05      	ldr	r3, [pc, #20]	; (8003b88 <netconn_close_shutdown+0x28>)
 8003b74:	f840 3d18 	str.w	r3, [r0, #-24]!
 8003b78:	f000 fff6 	bl	8004b68 <tcpip_apimsg>
  API_MSG_VAR_FREE(msg);

  return err;
}
 8003b7c:	b007      	add	sp, #28
 8003b7e:	f85d fb04 	ldr.w	pc, [sp], #4
  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
 8003b82:	f06f 000e 	mvn.w	r0, #14
 8003b86:	e7f9      	b.n	8003b7c <netconn_close_shutdown+0x1c>
 8003b88:	0800499f 	.word	0x0800499f

08003b8c <netconn_recv_data>:
{
 8003b8c:	b570      	push	{r4, r5, r6, lr}
  void *buf = NULL;
 8003b8e:	2300      	movs	r3, #0
{
 8003b90:	b088      	sub	sp, #32
 8003b92:	4604      	mov	r4, r0
  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 8003b94:	460e      	mov	r6, r1
  void *buf = NULL;
 8003b96:	9301      	str	r3, [sp, #4]
  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 8003b98:	b919      	cbnz	r1, 8003ba2 <netconn_recv_data+0x16>
 8003b9a:	f06f 000e 	mvn.w	r0, #14
}
 8003b9e:	b008      	add	sp, #32
 8003ba0:	bd70      	pop	{r4, r5, r6, pc}
  *new_buf = NULL;
 8003ba2:	600b      	str	r3, [r1, #0]
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 8003ba4:	2800      	cmp	r0, #0
 8003ba6:	d0f8      	beq.n	8003b9a <netconn_recv_data+0xe>
  if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP)
 8003ba8:	4605      	mov	r5, r0
 8003baa:	f815 3b10 	ldrb.w	r3, [r5], #16
 8003bae:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8003bb2:	2b10      	cmp	r3, #16
 8003bb4:	d10b      	bne.n	8003bce <netconn_recv_data+0x42>
    if (!sys_mbox_valid(&conn->recvmbox)) {
 8003bb6:	4628      	mov	r0, r5
 8003bb8:	f005 fa8a 	bl	80090d0 <sys_mbox_valid>
 8003bbc:	b938      	cbnz	r0, 8003bce <netconn_recv_data+0x42>
      return sys_mbox_valid(&conn->acceptmbox) ? ERR_CONN : ERR_CLSD;
 8003bbe:	f104 0014 	add.w	r0, r4, #20
 8003bc2:	f005 fa85 	bl	80090d0 <sys_mbox_valid>
 8003bc6:	b380      	cbz	r0, 8003c2a <netconn_recv_data+0x9e>
 8003bc8:	f06f 000a 	mvn.w	r0, #10
 8003bcc:	e7e7      	b.n	8003b9e <netconn_recv_data+0x12>
  LWIP_ERROR("netconn_recv: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 8003bce:	4628      	mov	r0, r5
 8003bd0:	f005 fa7e 	bl	80090d0 <sys_mbox_valid>
 8003bd4:	2800      	cmp	r0, #0
 8003bd6:	d0f7      	beq.n	8003bc8 <netconn_recv_data+0x3c>
  err = conn->last_err;
 8003bd8:	f994 0008 	ldrsb.w	r0, [r4, #8]
  if (ERR_IS_FATAL(err)) {
 8003bdc:	f110 0f0b 	cmn.w	r0, #11
 8003be0:	dbdd      	blt.n	8003b9e <netconn_recv_data+0x12>
  sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0);
 8003be2:	2200      	movs	r2, #0
 8003be4:	a901      	add	r1, sp, #4
 8003be6:	4628      	mov	r0, r5
 8003be8:	f005 fa3c 	bl	8009064 <sys_arch_mbox_fetch>
  if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP)
 8003bec:	7823      	ldrb	r3, [r4, #0]
 8003bee:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8003bf2:	2b10      	cmp	r3, #16
 8003bf4:	9b01      	ldr	r3, [sp, #4]
 8003bf6:	d127      	bne.n	8003c48 <netconn_recv_data+0xbc>
    if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
 8003bf8:	7f22      	ldrb	r2, [r4, #28]
 8003bfa:	0712      	lsls	r2, r2, #28
 8003bfc:	d500      	bpl.n	8003c00 <netconn_recv_data+0x74>
 8003bfe:	b94b      	cbnz	r3, 8003c14 <netconn_recv_data+0x88>
      API_MSG_VAR_REF(msg).msg.conn = conn;
 8003c00:	9403      	str	r4, [sp, #12]
      if (buf != NULL) {
 8003c02:	b1ab      	cbz	r3, 8003c30 <netconn_recv_data+0xa4>
        API_MSG_VAR_REF(msg).msg.msg.r.len = ((struct pbuf *)buf)->tot_len;
 8003c04:	891b      	ldrh	r3, [r3, #8]
        API_MSG_VAR_REF(msg).msg.msg.r.len = 1;
 8003c06:	9305      	str	r3, [sp, #20]
      TCPIP_APIMSG_NOERR(&API_MSG_VAR_REF(msg), lwip_netconn_do_recv);
 8003c08:	a808      	add	r0, sp, #32
 8003c0a:	4b11      	ldr	r3, [pc, #68]	; (8003c50 <netconn_recv_data+0xc4>)
 8003c0c:	f840 3d18 	str.w	r3, [r0, #-24]!
 8003c10:	f000 ffaa 	bl	8004b68 <tcpip_apimsg>
    if (buf == NULL) {
 8003c14:	9a01      	ldr	r2, [sp, #4]
 8003c16:	b96a      	cbnz	r2, 8003c34 <netconn_recv_data+0xa8>
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
 8003c18:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003c1a:	b113      	cbz	r3, 8003c22 <netconn_recv_data+0x96>
 8003c1c:	2101      	movs	r1, #1
 8003c1e:	4620      	mov	r0, r4
 8003c20:	4798      	blx	r3
      netconn_close_shutdown(conn, NETCONN_SHUT_RD);
 8003c22:	2101      	movs	r1, #1
 8003c24:	4620      	mov	r0, r4
 8003c26:	f7ff ff9b 	bl	8003b60 <netconn_close_shutdown>
      return sys_mbox_valid(&conn->acceptmbox) ? ERR_CONN : ERR_CLSD;
 8003c2a:	f06f 000d 	mvn.w	r0, #13
 8003c2e:	e7b6      	b.n	8003b9e <netconn_recv_data+0x12>
        API_MSG_VAR_REF(msg).msg.msg.r.len = 1;
 8003c30:	2301      	movs	r3, #1
 8003c32:	e7e8      	b.n	8003c06 <netconn_recv_data+0x7a>
    len = ((struct pbuf *)buf)->tot_len;
 8003c34:	8912      	ldrh	r2, [r2, #8]
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
 8003c36:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003c38:	b113      	cbz	r3, 8003c40 <netconn_recv_data+0xb4>
 8003c3a:	2101      	movs	r1, #1
 8003c3c:	4620      	mov	r0, r4
 8003c3e:	4798      	blx	r3
  *new_buf = buf;
 8003c40:	9b01      	ldr	r3, [sp, #4]
  return ERR_OK;
 8003c42:	2000      	movs	r0, #0
  *new_buf = buf;
 8003c44:	6033      	str	r3, [r6, #0]
  return ERR_OK;
 8003c46:	e7aa      	b.n	8003b9e <netconn_recv_data+0x12>
    len = netbuf_len((struct netbuf *)buf);
 8003c48:	681b      	ldr	r3, [r3, #0]
 8003c4a:	891a      	ldrh	r2, [r3, #8]
 8003c4c:	e7f3      	b.n	8003c36 <netconn_recv_data+0xaa>
 8003c4e:	bf00      	nop
 8003c50:	08004907 	.word	0x08004907

08003c54 <netconn_new_with_proto_and_callback>:
{
 8003c54:	b570      	push	{r4, r5, r6, lr}
 8003c56:	460d      	mov	r5, r1
 8003c58:	b086      	sub	sp, #24
  conn = netconn_alloc(t, callback);
 8003c5a:	4611      	mov	r1, r2
 8003c5c:	f000 fc12 	bl	8004484 <netconn_alloc>
  if (conn != NULL) {
 8003c60:	4604      	mov	r4, r0
 8003c62:	b310      	cbz	r0, 8003caa <netconn_new_with_proto_and_callback+0x56>
    API_MSG_VAR_REF(msg).msg.conn = conn;
 8003c64:	9001      	str	r0, [sp, #4]
    TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_newconn, err);
 8003c66:	a806      	add	r0, sp, #24
 8003c68:	4b11      	ldr	r3, [pc, #68]	; (8003cb0 <netconn_new_with_proto_and_callback+0x5c>)
    API_MSG_VAR_REF(msg).msg.msg.n.proto = proto;
 8003c6a:	f88d 500c 	strb.w	r5, [sp, #12]
    TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_newconn, err);
 8003c6e:	f840 3d18 	str.w	r3, [r0, #-24]!
 8003c72:	f000 ff79 	bl	8004b68 <tcpip_apimsg>
    if (err != ERR_OK) {
 8003c76:	b1c0      	cbz	r0, 8003caa <netconn_new_with_proto_and_callback+0x56>
      LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
 8003c78:	f104 0510 	add.w	r5, r4, #16
      LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
 8003c7c:	f104 060c 	add.w	r6, r4, #12
      LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
 8003c80:	4628      	mov	r0, r5
 8003c82:	f005 fa25 	bl	80090d0 <sys_mbox_valid>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", !sys_mbox_valid(&conn->acceptmbox));
 8003c86:	f104 0014 	add.w	r0, r4, #20
 8003c8a:	f005 fa21 	bl	80090d0 <sys_mbox_valid>
      LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
 8003c8e:	4630      	mov	r0, r6
 8003c90:	f005 fa62 	bl	8009158 <sys_sem_valid>
      sys_sem_free(&conn->op_completed);
 8003c94:	4630      	mov	r0, r6
 8003c96:	f005 fa7b 	bl	8009190 <sys_sem_free>
      sys_mbox_free(&conn->recvmbox);
 8003c9a:	4628      	mov	r0, r5
 8003c9c:	f005 f9b7 	bl	800900e <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
 8003ca0:	4621      	mov	r1, r4
      return NULL;
 8003ca2:	2400      	movs	r4, #0
      memp_free(MEMP_NETCONN, conn);
 8003ca4:	2007      	movs	r0, #7
 8003ca6:	f001 fe8b 	bl	80059c0 <memp_free>
}
 8003caa:	4620      	mov	r0, r4
 8003cac:	b006      	add	sp, #24
 8003cae:	bd70      	pop	{r4, r5, r6, pc}
 8003cb0:	0800440d 	.word	0x0800440d

08003cb4 <netconn_delete>:
{
 8003cb4:	b530      	push	{r4, r5, lr}
  if (conn == NULL) {
 8003cb6:	4604      	mov	r4, r0
{
 8003cb8:	b087      	sub	sp, #28
  if (conn == NULL) {
 8003cba:	b188      	cbz	r0, 8003ce0 <netconn_delete+0x2c>
  API_MSG_VAR_REF(msg).msg.msg.sd.polls_left =
 8003cbc:	2329      	movs	r3, #41	; 0x29
  API_MSG_VAR_REF(msg).msg.conn = conn;
 8003cbe:	9001      	str	r0, [sp, #4]
  TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_delconn, err);
 8003cc0:	a806      	add	r0, sp, #24
  API_MSG_VAR_REF(msg).msg.msg.sd.polls_left =
 8003cc2:	f88d 300d 	strb.w	r3, [sp, #13]
  TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_delconn, err);
 8003cc6:	4b07      	ldr	r3, [pc, #28]	; (8003ce4 <netconn_delete+0x30>)
 8003cc8:	f840 3d18 	str.w	r3, [r0, #-24]!
 8003ccc:	f000 ff4c 	bl	8004b68 <tcpip_apimsg>
  if (err != ERR_OK) {
 8003cd0:	4605      	mov	r5, r0
 8003cd2:	b910      	cbnz	r0, 8003cda <netconn_delete+0x26>
  netconn_free(conn);
 8003cd4:	4620      	mov	r0, r4
 8003cd6:	f000 fc0c 	bl	80044f2 <netconn_free>
}
 8003cda:	4628      	mov	r0, r5
 8003cdc:	b007      	add	sp, #28
 8003cde:	bd30      	pop	{r4, r5, pc}
    return ERR_OK;
 8003ce0:	4605      	mov	r5, r0
 8003ce2:	e7fa      	b.n	8003cda <netconn_delete+0x26>
 8003ce4:	08004655 	.word	0x08004655

08003ce8 <netconn_bind>:
{
 8003ce8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
 8003cea:	b160      	cbz	r0, 8003d06 <netconn_bind+0x1e>
  API_MSG_VAR_REF(msg).msg.conn = conn;
 8003cec:	9001      	str	r0, [sp, #4]
  TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_bind, err);
 8003cee:	a806      	add	r0, sp, #24
 8003cf0:	4b06      	ldr	r3, [pc, #24]	; (8003d0c <netconn_bind+0x24>)
  API_MSG_VAR_REF(msg).msg.msg.bc.ipaddr = API_MSG_VAR_REF(addr);
 8003cf2:	9103      	str	r1, [sp, #12]
  TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_bind, err);
 8003cf4:	f840 3d18 	str.w	r3, [r0, #-24]!
  API_MSG_VAR_REF(msg).msg.msg.bc.port = port;
 8003cf8:	f8ad 2010 	strh.w	r2, [sp, #16]
  TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_bind, err);
 8003cfc:	f000 ff34 	bl	8004b68 <tcpip_apimsg>
}
 8003d00:	b007      	add	sp, #28
 8003d02:	f85d fb04 	ldr.w	pc, [sp], #4
  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
 8003d06:	f06f 000e 	mvn.w	r0, #14
 8003d0a:	e7f9      	b.n	8003d00 <netconn_bind+0x18>
 8003d0c:	080046f1 	.word	0x080046f1

08003d10 <netconn_connect>:
{
 8003d10:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
 8003d12:	b160      	cbz	r0, 8003d2e <netconn_connect+0x1e>
  API_MSG_VAR_REF(msg).msg.conn = conn;
 8003d14:	9001      	str	r0, [sp, #4]
  TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_connect, err);
 8003d16:	a806      	add	r0, sp, #24
 8003d18:	4b06      	ldr	r3, [pc, #24]	; (8003d34 <netconn_connect+0x24>)
  API_MSG_VAR_REF(msg).msg.msg.bc.ipaddr = API_MSG_VAR_REF(addr);
 8003d1a:	9103      	str	r1, [sp, #12]
  TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_connect, err);
 8003d1c:	f840 3d18 	str.w	r3, [r0, #-24]!
  API_MSG_VAR_REF(msg).msg.msg.bc.port = port;
 8003d20:	f8ad 2010 	strh.w	r2, [sp, #16]
  TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_connect, err);
 8003d24:	f000 ff20 	bl	8004b68 <tcpip_apimsg>
}
 8003d28:	b007      	add	sp, #28
 8003d2a:	f85d fb04 	ldr.w	pc, [sp], #4
  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
 8003d2e:	f06f 000e 	mvn.w	r0, #14
 8003d32:	e7f9      	b.n	8003d28 <netconn_connect+0x18>
 8003d34:	0800474d 	.word	0x0800474d

08003d38 <netconn_listen_with_backlog>:
{
 8003d38:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
 8003d3a:	b148      	cbz	r0, 8003d50 <netconn_listen_with_backlog+0x18>
  API_MSG_VAR_REF(msg).msg.conn = conn;
 8003d3c:	9001      	str	r0, [sp, #4]
  TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_listen, err);
 8003d3e:	a806      	add	r0, sp, #24
 8003d40:	4b05      	ldr	r3, [pc, #20]	; (8003d58 <netconn_listen_with_backlog+0x20>)
 8003d42:	f840 3d18 	str.w	r3, [r0, #-24]!
 8003d46:	f000 ff0f 	bl	8004b68 <tcpip_apimsg>
}
 8003d4a:	b007      	add	sp, #28
 8003d4c:	f85d fb04 	ldr.w	pc, [sp], #4
  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
 8003d50:	f06f 000e 	mvn.w	r0, #14
 8003d54:	e7f9      	b.n	8003d4a <netconn_listen_with_backlog+0x12>
 8003d56:	bf00      	nop
 8003d58:	080047e1 	.word	0x080047e1

08003d5c <netconn_accept>:
{
 8003d5c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8003d5e:	4604      	mov	r4, r0
  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
 8003d60:	460d      	mov	r5, r1
 8003d62:	b919      	cbnz	r1, 8003d6c <netconn_accept+0x10>
 8003d64:	f06f 000e 	mvn.w	r0, #14
}
 8003d68:	b003      	add	sp, #12
 8003d6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  *new_conn = NULL;
 8003d6c:	2600      	movs	r6, #0
 8003d6e:	600e      	str	r6, [r1, #0]
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
 8003d70:	2800      	cmp	r0, #0
 8003d72:	d0f7      	beq.n	8003d64 <netconn_accept+0x8>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", sys_mbox_valid(&conn->acceptmbox),   return ERR_ARG;);
 8003d74:	f100 0714 	add.w	r7, r0, #20
 8003d78:	4638      	mov	r0, r7
 8003d7a:	f005 f9a9 	bl	80090d0 <sys_mbox_valid>
 8003d7e:	2800      	cmp	r0, #0
 8003d80:	d0f0      	beq.n	8003d64 <netconn_accept+0x8>
  err = conn->last_err;
 8003d82:	f994 0008 	ldrsb.w	r0, [r4, #8]
  if (ERR_IS_FATAL(err)) {
 8003d86:	f110 0f0b 	cmn.w	r0, #11
 8003d8a:	dbed      	blt.n	8003d68 <netconn_accept+0xc>
  sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, 0);
 8003d8c:	4632      	mov	r2, r6
 8003d8e:	a901      	add	r1, sp, #4
 8003d90:	4638      	mov	r0, r7
 8003d92:	f005 f967 	bl	8009064 <sys_arch_mbox_fetch>
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
 8003d96:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003d98:	b11b      	cbz	r3, 8003da2 <netconn_accept+0x46>
 8003d9a:	4632      	mov	r2, r6
 8003d9c:	2101      	movs	r1, #1
 8003d9e:	4620      	mov	r0, r4
 8003da0:	4798      	blx	r3
  if (newconn == NULL) {
 8003da2:	9b01      	ldr	r3, [sp, #4]
 8003da4:	b943      	cbnz	r3, 8003db8 <netconn_accept+0x5c>
    NETCONN_SET_SAFE_ERR(conn, ERR_ABRT);
 8003da6:	f994 3008 	ldrsb.w	r3, [r4, #8]
 8003daa:	330b      	adds	r3, #11
 8003dac:	db01      	blt.n	8003db2 <netconn_accept+0x56>
 8003dae:	23f4      	movs	r3, #244	; 0xf4
 8003db0:	7223      	strb	r3, [r4, #8]
    return ERR_ABRT;
 8003db2:	f06f 000b 	mvn.w	r0, #11
 8003db6:	e7d7      	b.n	8003d68 <netconn_accept+0xc>
  *new_conn = newconn;
 8003db8:	602b      	str	r3, [r5, #0]
  return ERR_OK;
 8003dba:	2000      	movs	r0, #0
 8003dbc:	e7d4      	b.n	8003d68 <netconn_accept+0xc>

08003dbe <netconn_recv>:
{
 8003dbe:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8003dc0:	4604      	mov	r4, r0
  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 8003dc2:	460e      	mov	r6, r1
 8003dc4:	b921      	cbnz	r1, 8003dd0 <netconn_recv+0x12>
 8003dc6:	f06f 040e 	mvn.w	r4, #14
}
 8003dca:	4620      	mov	r0, r4
 8003dcc:	b002      	add	sp, #8
 8003dce:	bd70      	pop	{r4, r5, r6, pc}
  *new_buf = NULL;
 8003dd0:	2500      	movs	r5, #0
 8003dd2:	600d      	str	r5, [r1, #0]
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 8003dd4:	2800      	cmp	r0, #0
 8003dd6:	d0f6      	beq.n	8003dc6 <netconn_recv+0x8>
  LWIP_ERROR("netconn_recv: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 8003dd8:	3010      	adds	r0, #16
 8003dda:	f005 f979 	bl	80090d0 <sys_mbox_valid>
 8003dde:	b328      	cbz	r0, 8003e2c <netconn_recv+0x6e>
  if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP)
 8003de0:	7823      	ldrb	r3, [r4, #0]
 8003de2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8003de6:	2b10      	cmp	r3, #16
 8003de8:	d11a      	bne.n	8003e20 <netconn_recv+0x62>
    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 8003dea:	2006      	movs	r0, #6
    struct pbuf *p = NULL;
 8003dec:	9501      	str	r5, [sp, #4]
    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 8003dee:	f001 fddb 	bl	80059a8 <memp_malloc>
    if (buf == NULL) {
 8003df2:	4605      	mov	r5, r0
 8003df4:	b188      	cbz	r0, 8003e1a <netconn_recv+0x5c>
    err = netconn_recv_data(conn, (void **)&p);
 8003df6:	4620      	mov	r0, r4
 8003df8:	a901      	add	r1, sp, #4
 8003dfa:	f7ff fec7 	bl	8003b8c <netconn_recv_data>
    if (err != ERR_OK) {
 8003dfe:	4604      	mov	r4, r0
 8003e00:	b120      	cbz	r0, 8003e0c <netconn_recv+0x4e>
      memp_free(MEMP_NETBUF, buf);
 8003e02:	4629      	mov	r1, r5
 8003e04:	2006      	movs	r0, #6
 8003e06:	f001 fddb 	bl	80059c0 <memp_free>
      return err;
 8003e0a:	e7de      	b.n	8003dca <netconn_recv+0xc>
    LWIP_ASSERT("p != NULL", p != NULL);
 8003e0c:	9b01      	ldr	r3, [sp, #4]
    buf->port = 0;
 8003e0e:	81a8      	strh	r0, [r5, #12]
    buf->p = p;
 8003e10:	602b      	str	r3, [r5, #0]
    buf->ptr = p;
 8003e12:	606b      	str	r3, [r5, #4]
    ip_addr_set_zero(&buf->addr);
 8003e14:	60a8      	str	r0, [r5, #8]
    *new_buf = buf;
 8003e16:	6035      	str	r5, [r6, #0]
    return ERR_OK;
 8003e18:	e7d7      	b.n	8003dca <netconn_recv+0xc>
      return ERR_MEM;
 8003e1a:	f04f 34ff 	mov.w	r4, #4294967295
 8003e1e:	e7d4      	b.n	8003dca <netconn_recv+0xc>
    return netconn_recv_data(conn, (void **)new_buf);
 8003e20:	4620      	mov	r0, r4
 8003e22:	4631      	mov	r1, r6
 8003e24:	f7ff feb2 	bl	8003b8c <netconn_recv_data>
 8003e28:	4604      	mov	r4, r0
 8003e2a:	e7ce      	b.n	8003dca <netconn_recv+0xc>
  LWIP_ERROR("netconn_recv: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 8003e2c:	f06f 040a 	mvn.w	r4, #10
 8003e30:	e7cb      	b.n	8003dca <netconn_recv+0xc>
	...

08003e34 <netconn_send>:
{
 8003e34:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
 8003e36:	b150      	cbz	r0, 8003e4e <netconn_send+0x1a>
  API_MSG_VAR_REF(msg).msg.conn = conn;
 8003e38:	9001      	str	r0, [sp, #4]
  TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_send, err);
 8003e3a:	a806      	add	r0, sp, #24
 8003e3c:	4b05      	ldr	r3, [pc, #20]	; (8003e54 <netconn_send+0x20>)
  API_MSG_VAR_REF(msg).msg.msg.b = buf;
 8003e3e:	9103      	str	r1, [sp, #12]
  TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_send, err);
 8003e40:	f840 3d18 	str.w	r3, [r0, #-24]!
 8003e44:	f000 fe90 	bl	8004b68 <tcpip_apimsg>
}
 8003e48:	b007      	add	sp, #28
 8003e4a:	f85d fb04 	ldr.w	pc, [sp], #4
  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
 8003e4e:	f06f 000e 	mvn.w	r0, #14
 8003e52:	e7f9      	b.n	8003e48 <netconn_send+0x14>
 8003e54:	080048a9 	.word	0x080048a9

08003e58 <netconn_write_partly>:
{
 8003e58:	b570      	push	{r4, r5, r6, lr}
 8003e5a:	b086      	sub	sp, #24
 8003e5c:	4615      	mov	r5, r2
 8003e5e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
 8003e60:	b348      	cbz	r0, 8003eb6 <netconn_write_partly+0x5e>
  LWIP_ERROR("netconn_write: invalid conn->type",  (NETCONNTYPE_GROUP(conn->type)== NETCONN_TCP), return ERR_VAL;);
 8003e62:	7802      	ldrb	r2, [r0, #0]
 8003e64:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8003e68:	2a10      	cmp	r2, #16
 8003e6a:	d11f      	bne.n	8003eac <netconn_write_partly+0x54>
  if (size == 0) {
 8003e6c:	b915      	cbnz	r5, 8003e74 <netconn_write_partly+0x1c>
    return ERR_OK;
 8003e6e:	2000      	movs	r0, #0
}
 8003e70:	b006      	add	sp, #24
 8003e72:	bd70      	pop	{r4, r5, r6, pc}
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 8003e74:	7f02      	ldrb	r2, [r0, #28]
 8003e76:	0792      	lsls	r2, r2, #30
 8003e78:	d415      	bmi.n	8003ea6 <netconn_write_partly+0x4e>
 8003e7a:	f3c3 0680 	ubfx	r6, r3, #2, #1
  if (dontblock && !bytes_written) {
 8003e7e:	b99e      	cbnz	r6, 8003ea8 <netconn_write_partly+0x50>
  API_MSG_VAR_REF(msg).msg.conn = conn;
 8003e80:	9001      	str	r0, [sp, #4]
  TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_write, err);
 8003e82:	a806      	add	r0, sp, #24
  API_MSG_VAR_REF(msg).msg.msg.w.apiflags = apiflags;
 8003e84:	f88d 3014 	strb.w	r3, [sp, #20]
  TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_write, err);
 8003e88:	4b0c      	ldr	r3, [pc, #48]	; (8003ebc <netconn_write_partly+0x64>)
  API_MSG_VAR_REF(msg).msg.msg.w.dataptr = dataptr;
 8003e8a:	9103      	str	r1, [sp, #12]
  TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_write, err);
 8003e8c:	f840 3d18 	str.w	r3, [r0, #-24]!
  API_MSG_VAR_REF(msg).msg.msg.w.len = size;
 8003e90:	9504      	str	r5, [sp, #16]
  TCPIP_APIMSG(&API_MSG_VAR_REF(msg), lwip_netconn_do_write, err);
 8003e92:	f000 fe69 	bl	8004b68 <tcpip_apimsg>
  if ((err == ERR_OK) && (bytes_written != NULL)) {
 8003e96:	2800      	cmp	r0, #0
 8003e98:	d1ea      	bne.n	8003e70 <netconn_write_partly+0x18>
 8003e9a:	2c00      	cmp	r4, #0
 8003e9c:	d0e7      	beq.n	8003e6e <netconn_write_partly+0x16>
    if (dontblock
 8003e9e:	b146      	cbz	r6, 8003eb2 <netconn_write_partly+0x5a>
      *bytes_written = API_MSG_VAR_REF(msg).msg.msg.w.len;
 8003ea0:	9b04      	ldr	r3, [sp, #16]
 8003ea2:	6023      	str	r3, [r4, #0]
 8003ea4:	e7e4      	b.n	8003e70 <netconn_write_partly+0x18>
 8003ea6:	2601      	movs	r6, #1
  if (dontblock && !bytes_written) {
 8003ea8:	2c00      	cmp	r4, #0
 8003eaa:	d1e9      	bne.n	8003e80 <netconn_write_partly+0x28>
  LWIP_ERROR("netconn_write: invalid conn->type",  (NETCONNTYPE_GROUP(conn->type)== NETCONN_TCP), return ERR_VAL;);
 8003eac:	f06f 0005 	mvn.w	r0, #5
 8003eb0:	e7de      	b.n	8003e70 <netconn_write_partly+0x18>
      *bytes_written = size;
 8003eb2:	6025      	str	r5, [r4, #0]
 8003eb4:	e7dc      	b.n	8003e70 <netconn_write_partly+0x18>
  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
 8003eb6:	f06f 000e 	mvn.w	r0, #14
 8003eba:	e7d9      	b.n	8003e70 <netconn_write_partly+0x18>
 8003ebc:	08004959 	.word	0x08004959

08003ec0 <netconn_close>:
 */
err_t
netconn_close(struct netconn *conn)
{
  /* shutting down both ends is the same as closing */
  return netconn_close_shutdown(conn, NETCONN_SHUT_RDWR);
 8003ec0:	2103      	movs	r1, #3
 8003ec2:	f7ff be4d 	b.w	8003b60 <netconn_close_shutdown>

08003ec6 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   const ip_addr_t *addr, u16_t port)
{
 8003ec6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003eca:	4617      	mov	r7, r2
 8003ecc:	461d      	mov	r5, r3
 8003ece:	f8bd 9020 	ldrh.w	r9, [sp, #32]
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox)) {
 8003ed2:	4606      	mov	r6, r0
 8003ed4:	b128      	cbz	r0, 8003ee2 <recv_udp+0x1c>
 8003ed6:	f100 0810 	add.w	r8, r0, #16
 8003eda:	4640      	mov	r0, r8
 8003edc:	f005 f8f8 	bl	80090d0 <sys_mbox_valid>
 8003ee0:	b920      	cbnz	r0, 8003eec <recv_udp+0x26>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
 8003ee2:	4638      	mov	r0, r7
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  }
}
 8003ee4:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    pbuf_free(p);
 8003ee8:	f001 be85 	b.w	8005bf6 <pbuf_free>
  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 8003eec:	2006      	movs	r0, #6
 8003eee:	f001 fd5b 	bl	80059a8 <memp_malloc>
  if (buf == NULL) {
 8003ef2:	4604      	mov	r4, r0
 8003ef4:	2800      	cmp	r0, #0
 8003ef6:	d0f4      	beq.n	8003ee2 <recv_udp+0x1c>
    buf->p = p;
 8003ef8:	6007      	str	r7, [r0, #0]
    buf->ptr = p;
 8003efa:	6047      	str	r7, [r0, #4]
    ip_addr_set(&buf->addr, addr);
 8003efc:	b105      	cbz	r5, 8003f00 <recv_udp+0x3a>
 8003efe:	682d      	ldr	r5, [r5, #0]
 8003f00:	60a5      	str	r5, [r4, #8]
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 8003f02:	4621      	mov	r1, r4
    buf->port = port;
 8003f04:	f8a4 900c 	strh.w	r9, [r4, #12]
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 8003f08:	4640      	mov	r0, r8
  len = p->tot_len;
 8003f0a:	893d      	ldrh	r5, [r7, #8]
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 8003f0c:	f005 f899 	bl	8009042 <sys_mbox_trypost>
 8003f10:	4601      	mov	r1, r0
 8003f12:	b120      	cbz	r0, 8003f1e <recv_udp+0x58>
    netbuf_delete(buf);
 8003f14:	4620      	mov	r0, r4
}
 8003f16:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    netbuf_delete(buf);
 8003f1a:	f000 bd70 	b.w	80049fe <netbuf_delete>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 8003f1e:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8003f20:	b123      	cbz	r3, 8003f2c <recv_udp+0x66>
 8003f22:	462a      	mov	r2, r5
 8003f24:	4630      	mov	r0, r6
}
 8003f26:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 8003f2a:	4718      	bx	r3
 8003f2c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08003f30 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
 8003f30:	b510      	push	{r4, lr}
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
 8003f32:	6844      	ldr	r4, [r0, #4]
{
 8003f34:	4601      	mov	r1, r0
  tcp_arg(pcb, conn);
 8003f36:	4620      	mov	r0, r4
 8003f38:	f002 f8e8 	bl	800610c <tcp_arg>
  tcp_recv(pcb, recv_tcp);
 8003f3c:	4620      	mov	r0, r4
 8003f3e:	4909      	ldr	r1, [pc, #36]	; (8003f64 <setup_tcp+0x34>)
 8003f40:	f002 f8e6 	bl	8006110 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
 8003f44:	4620      	mov	r0, r4
 8003f46:	4908      	ldr	r1, [pc, #32]	; (8003f68 <setup_tcp+0x38>)
 8003f48:	f002 f8e5 	bl	8006116 <tcp_sent>
  tcp_poll(pcb, poll_tcp, NETCONN_TCP_POLL_INTERVAL);
 8003f4c:	4620      	mov	r0, r4
 8003f4e:	4907      	ldr	r1, [pc, #28]	; (8003f6c <setup_tcp+0x3c>)
 8003f50:	2202      	movs	r2, #2
 8003f52:	f002 f8e7 	bl	8006124 <tcp_poll>
  tcp_err(pcb, err_tcp);
 8003f56:	4620      	mov	r0, r4
 8003f58:	4905      	ldr	r1, [pc, #20]	; (8003f70 <setup_tcp+0x40>)
}
 8003f5a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  tcp_err(pcb, err_tcp);
 8003f5e:	f002 b8dc 	b.w	800611a <tcp_err>
 8003f62:	bf00      	nop
 8003f64:	0800439b 	.word	0x0800439b
 8003f68:	08004351 	.word	0x08004351
 8003f6c:	080042f9 	.word	0x080042f9
 8003f70:	08003fd3 	.word	0x08003fd3

08003f74 <lwip_netconn_do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
lwip_netconn_do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
 8003f74:	b570      	push	{r4, r5, r6, lr}

  LWIP_UNUSED_ARG(pcb);

  conn = (struct netconn *)arg;

  if (conn == NULL) {
 8003f76:	4604      	mov	r4, r0
 8003f78:	b340      	cbz	r0, 8003fcc <lwip_netconn_do_connected+0x58>
    return ERR_VAL;
  }

  LWIP_ASSERT("conn->state == NETCONN_CONNECT", conn->state == NETCONN_CONNECT);
  LWIP_ASSERT("(conn->current_msg != NULL) || conn->in_non_blocking_connect",
 8003f7a:	6a46      	ldr	r6, [r0, #36]	; 0x24
    (conn->current_msg != NULL) || IN_NONBLOCKING_CONNECT(conn));

  if (conn->current_msg != NULL) {
 8003f7c:	b116      	cbz	r6, 8003f84 <lwip_netconn_do_connected+0x10>
    conn->current_msg->err = err;
 8003f7e:	7132      	strb	r2, [r6, #4]
    op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 8003f80:	6836      	ldr	r6, [r6, #0]
 8003f82:	360c      	adds	r6, #12
  }
  if ((NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP) && (err == ERR_OK)) {
 8003f84:	7823      	ldrb	r3, [r4, #0]
 8003f86:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8003f8a:	2b10      	cmp	r3, #16
 8003f8c:	d103      	bne.n	8003f96 <lwip_netconn_do_connected+0x22>
 8003f8e:	b912      	cbnz	r2, 8003f96 <lwip_netconn_do_connected+0x22>
    setup_tcp(conn);
 8003f90:	4620      	mov	r0, r4
 8003f92:	f7ff ffcd 	bl	8003f30 <setup_tcp>
  }
  was_blocking = !IN_NONBLOCKING_CONNECT(conn);
 8003f96:	7f23      	ldrb	r3, [r4, #28]
  LWIP_ASSERT("blocking connect state error",
    (was_blocking && op_completed_sem != NULL) ||
    (!was_blocking && op_completed_sem == NULL));
  conn->current_msg = NULL;
  conn->state = NETCONN_NONE;
  NETCONN_SET_SAFE_ERR(conn, ERR_OK);
 8003f98:	f994 2008 	ldrsb.w	r2, [r4, #8]
 8003f9c:	f003 0504 	and.w	r5, r3, #4
  SET_NONBLOCKING_CONNECT(conn, 0);
 8003fa0:	f023 0304 	bic.w	r3, r3, #4
  NETCONN_SET_SAFE_ERR(conn, ERR_OK);
 8003fa4:	320b      	adds	r2, #11
  SET_NONBLOCKING_CONNECT(conn, 0);
 8003fa6:	7723      	strb	r3, [r4, #28]
  conn->current_msg = NULL;
 8003fa8:	f04f 0300 	mov.w	r3, #0
 8003fac:	6263      	str	r3, [r4, #36]	; 0x24
  conn->state = NETCONN_NONE;
 8003fae:	7063      	strb	r3, [r4, #1]
  NETCONN_SET_SAFE_ERR(conn, ERR_OK);
 8003fb0:	bfa8      	it	ge
 8003fb2:	7223      	strbge	r3, [r4, #8]
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 8003fb4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003fb6:	b11b      	cbz	r3, 8003fc0 <lwip_netconn_do_connected+0x4c>
 8003fb8:	2200      	movs	r2, #0
 8003fba:	2102      	movs	r1, #2
 8003fbc:	4620      	mov	r0, r4
 8003fbe:	4798      	blx	r3

  if (was_blocking) {
 8003fc0:	b915      	cbnz	r5, 8003fc8 <lwip_netconn_do_connected+0x54>
    sys_sem_signal(op_completed_sem);
 8003fc2:	4630      	mov	r0, r6
 8003fc4:	f005 f8ef 	bl	80091a6 <sys_sem_signal>
  }
  return ERR_OK;
 8003fc8:	2000      	movs	r0, #0
}
 8003fca:	bd70      	pop	{r4, r5, r6, pc}
    return ERR_VAL;
 8003fcc:	f06f 0005 	mvn.w	r0, #5
 8003fd0:	bd70      	pop	{r4, r5, r6, pc}

08003fd2 <err_tcp>:
{
 8003fd2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  conn->pcb.tcp = NULL;
 8003fd4:	2200      	movs	r2, #0
{
 8003fd6:	4604      	mov	r4, r0
 8003fd8:	460f      	mov	r7, r1
  conn->pcb.tcp = NULL;
 8003fda:	6042      	str	r2, [r0, #4]
  SYS_ARCH_SET(conn->last_err, err);
 8003fdc:	7221      	strb	r1, [r4, #8]
  API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 8003fde:	6a83      	ldr	r3, [r0, #40]	; 0x28
  old_state = conn->state;
 8003fe0:	7845      	ldrb	r5, [r0, #1]
  conn->state = NETCONN_NONE;
 8003fe2:	7042      	strb	r2, [r0, #1]
  API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 8003fe4:	b10b      	cbz	r3, 8003fea <err_tcp+0x18>
 8003fe6:	2104      	movs	r1, #4
 8003fe8:	4798      	blx	r3
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 8003fea:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003fec:	b11b      	cbz	r3, 8003ff6 <err_tcp+0x24>
 8003fee:	2200      	movs	r2, #0
 8003ff0:	4620      	mov	r0, r4
 8003ff2:	4611      	mov	r1, r2
 8003ff4:	4798      	blx	r3
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 8003ff6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003ff8:	b11b      	cbz	r3, 8004002 <err_tcp+0x30>
 8003ffa:	2200      	movs	r2, #0
 8003ffc:	2102      	movs	r1, #2
 8003ffe:	4620      	mov	r0, r4
 8004000:	4798      	blx	r3
  if (sys_mbox_valid(&conn->recvmbox)) {
 8004002:	f104 0610 	add.w	r6, r4, #16
 8004006:	4630      	mov	r0, r6
 8004008:	f005 f862 	bl	80090d0 <sys_mbox_valid>
 800400c:	b118      	cbz	r0, 8004016 <err_tcp+0x44>
    sys_mbox_trypost(&conn->recvmbox, NULL);
 800400e:	2100      	movs	r1, #0
 8004010:	4630      	mov	r0, r6
 8004012:	f005 f816 	bl	8009042 <sys_mbox_trypost>
  if (sys_mbox_valid(&conn->acceptmbox)) {
 8004016:	f104 0614 	add.w	r6, r4, #20
 800401a:	4630      	mov	r0, r6
 800401c:	f005 f858 	bl	80090d0 <sys_mbox_valid>
 8004020:	b118      	cbz	r0, 800402a <err_tcp+0x58>
    sys_mbox_trypost(&conn->acceptmbox, NULL);
 8004022:	2100      	movs	r1, #0
 8004024:	4630      	mov	r0, r6
 8004026:	f005 f80c 	bl	8009042 <sys_mbox_trypost>
  if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
 800402a:	2d01      	cmp	r5, #1
 800402c:	d002      	beq.n	8004034 <err_tcp+0x62>
 800402e:	3d03      	subs	r5, #3
 8004030:	2d01      	cmp	r5, #1
 8004032:	d818      	bhi.n	8004066 <err_tcp+0x94>
    int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
 8004034:	7f23      	ldrb	r3, [r4, #28]
    SET_NONBLOCKING_CONNECT(conn, 0);
 8004036:	f023 0204 	bic.w	r2, r3, #4
    if (!was_nonblocking_connect) {
 800403a:	f013 0504 	ands.w	r5, r3, #4
    SET_NONBLOCKING_CONNECT(conn, 0);
 800403e:	7722      	strb	r2, [r4, #28]
    if (!was_nonblocking_connect) {
 8004040:	d111      	bne.n	8004066 <err_tcp+0x94>
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 8004042:	6a63      	ldr	r3, [r4, #36]	; 0x24
      op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 8004044:	681e      	ldr	r6, [r3, #0]
      conn->current_msg->err = err;
 8004046:	711f      	strb	r7, [r3, #4]
      op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 8004048:	360c      	adds	r6, #12
      LWIP_ASSERT("inavlid op_completed_sem", sys_sem_valid(op_completed_sem));
 800404a:	4630      	mov	r0, r6
 800404c:	f005 f884 	bl	8009158 <sys_sem_valid>
      NETCONN_SET_SAFE_ERR(conn, err);
 8004050:	f994 3008 	ldrsb.w	r3, [r4, #8]
      conn->current_msg = NULL;
 8004054:	6265      	str	r5, [r4, #36]	; 0x24
      sys_sem_signal(op_completed_sem);
 8004056:	4630      	mov	r0, r6
      NETCONN_SET_SAFE_ERR(conn, err);
 8004058:	330b      	adds	r3, #11
 800405a:	bfa8      	it	ge
 800405c:	7227      	strbge	r7, [r4, #8]
}
 800405e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      sys_sem_signal(op_completed_sem);
 8004062:	f005 b8a0 	b.w	80091a6 <sys_sem_signal>
 8004066:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08004068 <lwip_netconn_do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
lwip_netconn_do_writemore(struct netconn *conn  WRITE_DELAYED_PARAM)
{
 8004068:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  u8_t dontblock;
  u8_t apiflags;

  LWIP_ASSERT("conn != NULL", conn != NULL);
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 800406a:	6a41      	ldr	r1, [r0, #36]	; 0x24
{
 800406c:	4604      	mov	r4, r0
  LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
 800406e:	6840      	ldr	r0, [r0, #4]
  LWIP_ASSERT("conn->write_offset < conn->current_msg->msg.w.len",
 8004070:	6a25      	ldr	r5, [r4, #32]
 8004072:	68ca      	ldr	r2, [r1, #12]
    conn->write_offset < conn->current_msg->msg.w.len);

  dontblock = netconn_is_nonblocking(conn) ||
 8004074:	7f23      	ldrb	r3, [r4, #28]
    }
  } else
#endif /* LWIP_SO_SNDTIMEO */
  {
    dataptr = (const u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
    diff = conn->current_msg->msg.w.len - conn->write_offset;
 8004076:	1b52      	subs	r2, r2, r5
      len = 0xffff;
      apiflags |= TCP_WRITE_FLAG_MORE;
    } else {
      len = (u16_t)diff;
    }
    available = tcp_sndbuf(conn->pcb.tcp);
 8004078:	f8b0 6066 	ldrh.w	r6, [r0, #102]	; 0x66
  dontblock = netconn_is_nonblocking(conn) ||
 800407c:	f013 0f02 	tst.w	r3, #2
 8004080:	7c0b      	ldrb	r3, [r1, #16]
    dataptr = (const u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
 8004082:	6889      	ldr	r1, [r1, #8]
  dontblock = netconn_is_nonblocking(conn) ||
 8004084:	bf0c      	ite	eq
 8004086:	f3c3 0780 	ubfxeq	r7, r3, #2, #1
 800408a:	2701      	movne	r7, #1
    if (diff > 0xffffUL) { /* max_u16_t */
 800408c:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
    dataptr = (const u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
 8004090:	4429      	add	r1, r5
      len = 0xffff;
 8004092:	bf2a      	itet	cs
 8004094:	f64f 72ff 	movwcs	r2, #65535	; 0xffff
      len = (u16_t)diff;
 8004098:	b292      	uxthcc	r2, r2
      apiflags |= TCP_WRITE_FLAG_MORE;
 800409a:	f043 0302 	orrcs.w	r3, r3, #2
    if (available < len) {
 800409e:	42b2      	cmp	r2, r6
 80040a0:	d949      	bls.n	8004136 <lwip_netconn_do_writemore+0xce>
      /* don't try to write more than sendbuf */
      len = available;
      if (dontblock) {
 80040a2:	2f00      	cmp	r7, #0
 80040a4:	d044      	beq.n	8004130 <lwip_netconn_do_writemore+0xc8>
        if (!len) {
 80040a6:	2e00      	cmp	r6, #0
 80040a8:	d047      	beq.n	800413a <lwip_netconn_do_writemore+0xd2>
      } else {
        apiflags |= TCP_WRITE_FLAG_MORE;
      }
    }
    LWIP_ASSERT("lwip_netconn_do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
 80040aa:	4632      	mov	r2, r6
 80040ac:	f003 fe07 	bl	8007cbe <tcp_write>
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
 80040b0:	1c43      	adds	r3, r0, #1
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
 80040b2:	4605      	mov	r5, r0
    if ((err == ERR_OK) || (err == ERR_MEM)) {
 80040b4:	b2db      	uxtb	r3, r3
 80040b6:	2b01      	cmp	r3, #1
 80040b8:	d862      	bhi.n	8004180 <lwip_netconn_do_writemore+0x118>
err_mem:
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
 80040ba:	2f00      	cmp	r7, #0
 80040bc:	d040      	beq.n	8004140 <lwip_netconn_do_writemore+0xd8>
 80040be:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80040c0:	68db      	ldr	r3, [r3, #12]
 80040c2:	429e      	cmp	r6, r3
 80040c4:	d23c      	bcs.n	8004140 <lwip_netconn_do_writemore+0xd8>
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
 80040c6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80040c8:	b11b      	cbz	r3, 80040d2 <lwip_netconn_do_writemore+0x6a>
 80040ca:	4632      	mov	r2, r6
 80040cc:	2103      	movs	r1, #3
 80040ce:	4620      	mov	r0, r4
 80040d0:	4798      	blx	r3
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
 80040d2:	7f23      	ldrb	r3, [r4, #28]
 80040d4:	f043 0310 	orr.w	r3, r3, #16
 80040d8:	7723      	strb	r3, [r4, #28]
           let select mark this pcb as non-writable. */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
      }
    }

    if (err == ERR_OK) {
 80040da:	2d00      	cmp	r5, #0
 80040dc:	d144      	bne.n	8004168 <lwip_netconn_do_writemore+0x100>
      err_t out_err;
      conn->write_offset += len;
 80040de:	6a23      	ldr	r3, [r4, #32]
 80040e0:	441e      	add	r6, r3
      if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
 80040e2:	6a63      	ldr	r3, [r4, #36]	; 0x24
      conn->write_offset += len;
 80040e4:	6226      	str	r6, [r4, #32]
      if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
 80040e6:	68da      	ldr	r2, [r3, #12]
 80040e8:	4296      	cmp	r6, r2
 80040ea:	462a      	mov	r2, r5
 80040ec:	d001      	beq.n	80040f2 <lwip_netconn_do_writemore+0x8a>
 80040ee:	2f00      	cmp	r7, #0
 80040f0:	d038      	beq.n	8004164 <lwip_netconn_do_writemore+0xfc>
        /* return sent length */
        conn->current_msg->msg.w.len = conn->write_offset;
 80040f2:	60de      	str	r6, [r3, #12]
        /* everything was written */
        write_finished = 1;
 80040f4:	2601      	movs	r6, #1
        conn->write_offset = 0;
 80040f6:	6222      	str	r2, [r4, #32]
      }
      out_err = tcp_output(conn->pcb.tcp);
 80040f8:	6860      	ldr	r0, [r4, #4]
 80040fa:	f004 f81b 	bl	8008134 <tcp_output>
      if (ERR_IS_FATAL(out_err) || (out_err == ERR_RTE)) {
 80040fe:	f110 0f0b 	cmn.w	r0, #11
 8004102:	db01      	blt.n	8004108 <lwip_netconn_do_writemore+0xa0>
 8004104:	1d01      	adds	r1, r0, #4
 8004106:	d13f      	bne.n	8004188 <lwip_netconn_do_writemore+0x120>
        /* If tcp_output fails with fatal error or no route is found,
           don't try writing any more but return the error
           to the application thread. */
        err = out_err;
        write_finished = 1;
        conn->current_msg->msg.w.len = 0;
 8004108:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800410a:	2200      	movs	r2, #0
      out_err = tcp_output(conn->pcb.tcp);
 800410c:	4605      	mov	r5, r0
        conn->current_msg->msg.w.len = 0;
 800410e:	60da      	str	r2, [r3, #12]
    }
  }
  if (write_finished) {
    /* everything was written: set back connection state
       and back to application task */
    sys_sem_t* op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 8004110:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004112:	6818      	ldr	r0, [r3, #0]
    conn->current_msg->err = err;
 8004114:	711d      	strb	r5, [r3, #4]
    conn->current_msg = NULL;
 8004116:	2300      	movs	r3, #0
    sys_sem_t* op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 8004118:	300c      	adds	r0, #12
    conn->current_msg = NULL;
 800411a:	6263      	str	r3, [r4, #36]	; 0x24
    conn->state = NETCONN_NONE;
 800411c:	7063      	strb	r3, [r4, #1]
    NETCONN_SET_SAFE_ERR(conn, err);
 800411e:	f994 3008 	ldrsb.w	r3, [r4, #8]
 8004122:	330b      	adds	r3, #11
 8004124:	bfa8      	it	ge
 8004126:	7225      	strbge	r5, [r4, #8]
#if LWIP_TCPIP_CORE_LOCKING
    if (delayed)
#endif
    {
      sys_sem_signal(op_completed_sem);
 8004128:	f005 f83d 	bl	80091a6 <sys_sem_signal>
  else {
    return ERR_MEM;
  }
#endif
  return ERR_OK;
}
 800412c:	2000      	movs	r0, #0
 800412e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        apiflags |= TCP_WRITE_FLAG_MORE;
 8004130:	f043 0302 	orr.w	r3, r3, #2
 8004134:	e7b9      	b.n	80040aa <lwip_netconn_do_writemore+0x42>
 8004136:	4616      	mov	r6, r2
 8004138:	e7b7      	b.n	80040aa <lwip_netconn_do_writemore+0x42>
          err = ERR_WOULDBLOCK;
 800413a:	f06f 0506 	mvn.w	r5, #6
 800413e:	e7be      	b.n	80040be <lwip_netconn_do_writemore+0x56>
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
 8004140:	6863      	ldr	r3, [r4, #4]
 8004142:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
 8004146:	f5b2 6f86 	cmp.w	r2, #1072	; 0x430
 800414a:	d303      	bcc.n	8004154 <lwip_netconn_do_writemore+0xec>
 800414c:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
 8004150:	2b04      	cmp	r3, #4
 8004152:	d9c2      	bls.n	80040da <lwip_netconn_do_writemore+0x72>
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
 8004154:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8004156:	2b00      	cmp	r3, #0
 8004158:	d0bf      	beq.n	80040da <lwip_netconn_do_writemore+0x72>
 800415a:	4632      	mov	r2, r6
 800415c:	2103      	movs	r1, #3
 800415e:	4620      	mov	r0, r4
 8004160:	4798      	blx	r3
 8004162:	e7ba      	b.n	80040da <lwip_netconn_do_writemore+0x72>
  u8_t write_finished = 0;
 8004164:	462e      	mov	r6, r5
 8004166:	e7c7      	b.n	80040f8 <lwip_netconn_do_writemore+0x90>
    } else if ((err == ERR_MEM) && !dontblock) {
 8004168:	1c6a      	adds	r2, r5, #1
 800416a:	d109      	bne.n	8004180 <lwip_netconn_do_writemore+0x118>
 800416c:	b947      	cbnz	r7, 8004180 <lwip_netconn_do_writemore+0x118>
      err_t out_err = tcp_output(conn->pcb.tcp);
 800416e:	6860      	ldr	r0, [r4, #4]
 8004170:	f003 ffe0 	bl	8008134 <tcp_output>
      if (ERR_IS_FATAL(out_err) || (out_err == ERR_RTE)) {
 8004174:	f110 0f0b 	cmn.w	r0, #11
      err_t out_err = tcp_output(conn->pcb.tcp);
 8004178:	4605      	mov	r5, r0
      if (ERR_IS_FATAL(out_err) || (out_err == ERR_RTE)) {
 800417a:	db01      	blt.n	8004180 <lwip_netconn_do_writemore+0x118>
 800417c:	1d03      	adds	r3, r0, #4
 800417e:	d1d5      	bne.n	800412c <lwip_netconn_do_writemore+0xc4>
      conn->current_msg->msg.w.len = 0;
 8004180:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004182:	2200      	movs	r2, #0
 8004184:	60da      	str	r2, [r3, #12]
 8004186:	e7c3      	b.n	8004110 <lwip_netconn_do_writemore+0xa8>
  if (write_finished) {
 8004188:	2e00      	cmp	r6, #0
 800418a:	d0cf      	beq.n	800412c <lwip_netconn_do_writemore+0xc4>
    sys_sem_t* op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 800418c:	6a62      	ldr	r2, [r4, #36]	; 0x24
    conn->current_msg->err = err;
 800418e:	2300      	movs	r3, #0
    sys_sem_t* op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 8004190:	6810      	ldr	r0, [r2, #0]
    conn->current_msg->err = err;
 8004192:	7113      	strb	r3, [r2, #4]
    sys_sem_t* op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 8004194:	300c      	adds	r0, #12
 8004196:	e7c0      	b.n	800411a <lwip_netconn_do_writemore+0xb2>

08004198 <lwip_netconn_do_close_internal>:
  shut = conn->current_msg->msg.sd.shut;
 8004198:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
 800419a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  shut = conn->current_msg->msg.sd.shut;
 800419e:	7a1b      	ldrb	r3, [r3, #8]
{
 80041a0:	4604      	mov	r4, r0
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
 80041a2:	6845      	ldr	r5, [r0, #4]
  if (shut == NETCONN_SHUT_RDWR) {
 80041a4:	2b03      	cmp	r3, #3
  shut_rx = shut & NETCONN_SHUT_RD;
 80041a6:	f003 0901 	and.w	r9, r3, #1
  shut_tx = shut & NETCONN_SHUT_WR;
 80041aa:	f003 0802 	and.w	r8, r3, #2
  if (shut == NETCONN_SHUT_RDWR) {
 80041ae:	d07f      	beq.n	80042b0 <lwip_netconn_do_close_internal+0x118>
  } else if (shut_rx &&
 80041b0:	f1b9 0f00 	cmp.w	r9, #0
 80041b4:	d005      	beq.n	80041c2 <lwip_netconn_do_close_internal+0x2a>
             ((tpcb->state == FIN_WAIT_1) ||
 80041b6:	7e2b      	ldrb	r3, [r5, #24]
  } else if (shut_rx &&
 80041b8:	1f5a      	subs	r2, r3, #5
 80041ba:	2a01      	cmp	r2, #1
 80041bc:	d978      	bls.n	80042b0 <lwip_netconn_do_close_internal+0x118>
              (tpcb->state == FIN_WAIT_2) ||
 80041be:	2b08      	cmp	r3, #8
 80041c0:	d076      	beq.n	80042b0 <lwip_netconn_do_close_internal+0x118>
  } else if (shut_tx && ((tpcb->flags & TF_RXCLOSED) != 0)) {
 80041c2:	f1b8 0f00 	cmp.w	r8, #0
 80041c6:	d011      	beq.n	80041ec <lwip_netconn_do_close_internal+0x54>
 80041c8:	7faf      	ldrb	r7, [r5, #30]
 80041ca:	f017 0710 	ands.w	r7, r7, #16
 80041ce:	d16f      	bne.n	80042b0 <lwip_netconn_do_close_internal+0x118>
  if (tpcb->state == LISTEN) {
 80041d0:	7e2b      	ldrb	r3, [r5, #24]
 80041d2:	2b01      	cmp	r3, #1
 80041d4:	d10c      	bne.n	80041f0 <lwip_netconn_do_close_internal+0x58>
    tcp_accept(tpcb, NULL);
 80041d6:	2100      	movs	r1, #0
 80041d8:	4628      	mov	r0, r5
 80041da:	f001 ffa1 	bl	8006120 <tcp_accept>
  if (close) {
 80041de:	bb27      	cbnz	r7, 800422a <lwip_netconn_do_close_internal+0x92>
    err = tcp_shutdown(tpcb, shut_rx, shut_tx);
 80041e0:	4642      	mov	r2, r8
 80041e2:	4649      	mov	r1, r9
 80041e4:	4628      	mov	r0, r5
 80041e6:	f002 fa99 	bl	800671c <tcp_shutdown>
 80041ea:	e021      	b.n	8004230 <lwip_netconn_do_close_internal+0x98>
 80041ec:	4647      	mov	r7, r8
 80041ee:	e7ef      	b.n	80041d0 <lwip_netconn_do_close_internal+0x38>
    if (shut_rx) {
 80041f0:	f1b9 0f00 	cmp.w	r9, #0
 80041f4:	d007      	beq.n	8004206 <lwip_netconn_do_close_internal+0x6e>
      tcp_recv(tpcb, NULL);
 80041f6:	2100      	movs	r1, #0
 80041f8:	4628      	mov	r0, r5
 80041fa:	f001 ff89 	bl	8006110 <tcp_recv>
      tcp_accept(tpcb, NULL);
 80041fe:	2100      	movs	r1, #0
 8004200:	4628      	mov	r0, r5
 8004202:	f001 ff8d 	bl	8006120 <tcp_accept>
    if (shut_tx) {
 8004206:	f1b8 0f00 	cmp.w	r8, #0
 800420a:	d003      	beq.n	8004214 <lwip_netconn_do_close_internal+0x7c>
      tcp_sent(tpcb, NULL);
 800420c:	2100      	movs	r1, #0
 800420e:	4628      	mov	r0, r5
 8004210:	f001 ff81 	bl	8006116 <tcp_sent>
    if (close) {
 8004214:	2f00      	cmp	r7, #0
 8004216:	d0e3      	beq.n	80041e0 <lwip_netconn_do_close_internal+0x48>
      tcp_poll(tpcb, NULL, 0);
 8004218:	2200      	movs	r2, #0
 800421a:	4628      	mov	r0, r5
 800421c:	4611      	mov	r1, r2
 800421e:	f001 ff81 	bl	8006124 <tcp_poll>
      tcp_err(tpcb, NULL);
 8004222:	2100      	movs	r1, #0
 8004224:	4628      	mov	r0, r5
 8004226:	f001 ff78 	bl	800611a <tcp_err>
      err = tcp_close(tpcb);
 800422a:	4628      	mov	r0, r5
 800422c:	f002 f9da 	bl	80065e4 <tcp_close>
    err = tcp_shutdown(tpcb, shut_rx, shut_tx);
 8004230:	4606      	mov	r6, r0
  if (err == ERR_OK) {
 8004232:	b178      	cbz	r0, 8004254 <lwip_netconn_do_close_internal+0xbc>
    if (err == ERR_MEM) {
 8004234:	1c42      	adds	r2, r0, #1
 8004236:	d10d      	bne.n	8004254 <lwip_netconn_do_close_internal+0xbc>
      if (netconn_is_nonblocking(conn)) {
 8004238:	7f23      	ldrb	r3, [r4, #28]
 800423a:	079b      	lsls	r3, r3, #30
 800423c:	d43e      	bmi.n	80042bc <lwip_netconn_do_close_internal+0x124>
        if (conn->current_msg->msg.sd.polls_left == 0) {
 800423e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004240:	f893 a009 	ldrb.w	sl, [r3, #9]
 8004244:	f1ba 0f00 	cmp.w	sl, #0
 8004248:	d13b      	bne.n	80042c2 <lwip_netconn_do_close_internal+0x12a>
          if (close) {
 800424a:	b11f      	cbz	r7, 8004254 <lwip_netconn_do_close_internal+0xbc>
            err = ERR_OK;
 800424c:	4656      	mov	r6, sl
            tcp_abort(tpcb);
 800424e:	4628      	mov	r0, r5
 8004250:	f002 faf2 	bl	8006838 <tcp_abort>
    sys_sem_t* op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 8004254:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004256:	681d      	ldr	r5, [r3, #0]
    conn->current_msg->err = err;
 8004258:	711e      	strb	r6, [r3, #4]
    conn->current_msg = NULL;
 800425a:	2300      	movs	r3, #0
 800425c:	6263      	str	r3, [r4, #36]	; 0x24
    conn->state = NETCONN_NONE;
 800425e:	7063      	strb	r3, [r4, #1]
    if (err == ERR_OK) {
 8004260:	b9ce      	cbnz	r6, 8004296 <lwip_netconn_do_close_internal+0xfe>
      if (close) {
 8004262:	b137      	cbz	r7, 8004272 <lwip_netconn_do_close_internal+0xda>
        API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 8004264:	6aa3      	ldr	r3, [r4, #40]	; 0x28
        conn->pcb.tcp = NULL;
 8004266:	6066      	str	r6, [r4, #4]
        API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 8004268:	b11b      	cbz	r3, 8004272 <lwip_netconn_do_close_internal+0xda>
 800426a:	4632      	mov	r2, r6
 800426c:	2104      	movs	r1, #4
 800426e:	4620      	mov	r0, r4
 8004270:	4798      	blx	r3
      if (shut_rx) {
 8004272:	f1b9 0f00 	cmp.w	r9, #0
 8004276:	d005      	beq.n	8004284 <lwip_netconn_do_close_internal+0xec>
        API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 8004278:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800427a:	b163      	cbz	r3, 8004296 <lwip_netconn_do_close_internal+0xfe>
 800427c:	2200      	movs	r2, #0
 800427e:	4620      	mov	r0, r4
 8004280:	4611      	mov	r1, r2
 8004282:	4798      	blx	r3
      if (shut_tx) {
 8004284:	f1b8 0f00 	cmp.w	r8, #0
 8004288:	d005      	beq.n	8004296 <lwip_netconn_do_close_internal+0xfe>
        API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 800428a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800428c:	b11b      	cbz	r3, 8004296 <lwip_netconn_do_close_internal+0xfe>
 800428e:	2200      	movs	r2, #0
 8004290:	2102      	movs	r1, #2
 8004292:	4620      	mov	r0, r4
 8004294:	4798      	blx	r3
    NETCONN_SET_SAFE_ERR(conn, err);
 8004296:	f994 3008 	ldrsb.w	r3, [r4, #8]
      sys_sem_signal(op_completed_sem);
 800429a:	f105 000c 	add.w	r0, r5, #12
    NETCONN_SET_SAFE_ERR(conn, err);
 800429e:	330b      	adds	r3, #11
 80042a0:	bfa8      	it	ge
 80042a2:	7226      	strbge	r6, [r4, #8]
    return ERR_OK;
 80042a4:	2600      	movs	r6, #0
      sys_sem_signal(op_completed_sem);
 80042a6:	f004 ff7e 	bl	80091a6 <sys_sem_signal>
}
 80042aa:	4630      	mov	r0, r6
 80042ac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    tcp_arg(tpcb, NULL);
 80042b0:	2100      	movs	r1, #0
 80042b2:	4628      	mov	r0, r5
 80042b4:	f001 ff2a 	bl	800610c <tcp_arg>
 80042b8:	2701      	movs	r7, #1
 80042ba:	e789      	b.n	80041d0 <lwip_netconn_do_close_internal+0x38>
        err = ERR_WOULDBLOCK;
 80042bc:	f06f 0606 	mvn.w	r6, #6
 80042c0:	e7c8      	b.n	8004254 <lwip_netconn_do_close_internal+0xbc>
    if (shut_tx) {
 80042c2:	f1b8 0f00 	cmp.w	r8, #0
 80042c6:	d003      	beq.n	80042d0 <lwip_netconn_do_close_internal+0x138>
      tcp_sent(tpcb, sent_tcp);
 80042c8:	4908      	ldr	r1, [pc, #32]	; (80042ec <lwip_netconn_do_close_internal+0x154>)
 80042ca:	4628      	mov	r0, r5
 80042cc:	f001 ff23 	bl	8006116 <tcp_sent>
    tcp_poll(tpcb, poll_tcp, 1);
 80042d0:	2201      	movs	r2, #1
 80042d2:	4628      	mov	r0, r5
 80042d4:	4906      	ldr	r1, [pc, #24]	; (80042f0 <lwip_netconn_do_close_internal+0x158>)
 80042d6:	f001 ff25 	bl	8006124 <tcp_poll>
    tcp_err(tpcb, err_tcp);
 80042da:	4628      	mov	r0, r5
 80042dc:	4905      	ldr	r1, [pc, #20]	; (80042f4 <lwip_netconn_do_close_internal+0x15c>)
 80042de:	f001 ff1c 	bl	800611a <tcp_err>
    tcp_arg(tpcb, conn);
 80042e2:	4621      	mov	r1, r4
 80042e4:	4628      	mov	r0, r5
 80042e6:	f001 ff11 	bl	800610c <tcp_arg>
  return err;
 80042ea:	e7de      	b.n	80042aa <lwip_netconn_do_close_internal+0x112>
 80042ec:	08004351 	.word	0x08004351
 80042f0:	080042f9 	.word	0x080042f9
 80042f4:	08003fd3 	.word	0x08003fd3

080042f8 <poll_tcp>:
  if (conn->state == NETCONN_WRITE) {
 80042f8:	7843      	ldrb	r3, [r0, #1]
 80042fa:	2b01      	cmp	r3, #1
{
 80042fc:	b510      	push	{r4, lr}
 80042fe:	4604      	mov	r4, r0
  if (conn->state == NETCONN_WRITE) {
 8004300:	d11a      	bne.n	8004338 <poll_tcp+0x40>
    lwip_netconn_do_writemore(conn  WRITE_DELAYED);
 8004302:	f7ff feb1 	bl	8004068 <lwip_netconn_do_writemore>
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
 8004306:	7f23      	ldrb	r3, [r4, #28]
 8004308:	06da      	lsls	r2, r3, #27
 800430a:	d513      	bpl.n	8004334 <poll_tcp+0x3c>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 800430c:	6862      	ldr	r2, [r4, #4]
 800430e:	b18a      	cbz	r2, 8004334 <poll_tcp+0x3c>
 8004310:	f8b2 1066 	ldrh.w	r1, [r2, #102]	; 0x66
 8004314:	f5b1 6f86 	cmp.w	r1, #1072	; 0x430
 8004318:	d30c      	bcc.n	8004334 <poll_tcp+0x3c>
 800431a:	f8b2 2068 	ldrh.w	r2, [r2, #104]	; 0x68
 800431e:	2a04      	cmp	r2, #4
 8004320:	d808      	bhi.n	8004334 <poll_tcp+0x3c>
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
 8004322:	f023 0310 	bic.w	r3, r3, #16
 8004326:	7723      	strb	r3, [r4, #28]
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 8004328:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800432a:	b11b      	cbz	r3, 8004334 <poll_tcp+0x3c>
 800432c:	2200      	movs	r2, #0
 800432e:	2102      	movs	r1, #2
 8004330:	4620      	mov	r0, r4
 8004332:	4798      	blx	r3
}
 8004334:	2000      	movs	r0, #0
 8004336:	bd10      	pop	{r4, pc}
  } else if (conn->state == NETCONN_CLOSE) {
 8004338:	2b04      	cmp	r3, #4
 800433a:	d1e4      	bne.n	8004306 <poll_tcp+0xe>
    if (conn->current_msg && conn->current_msg->msg.sd.polls_left) {
 800433c:	6a42      	ldr	r2, [r0, #36]	; 0x24
 800433e:	b11a      	cbz	r2, 8004348 <poll_tcp+0x50>
 8004340:	7a53      	ldrb	r3, [r2, #9]
 8004342:	b10b      	cbz	r3, 8004348 <poll_tcp+0x50>
      conn->current_msg->msg.sd.polls_left--;
 8004344:	3b01      	subs	r3, #1
 8004346:	7253      	strb	r3, [r2, #9]
    lwip_netconn_do_close_internal(conn  WRITE_DELAYED);
 8004348:	4620      	mov	r0, r4
 800434a:	f7ff ff25 	bl	8004198 <lwip_netconn_do_close_internal>
 800434e:	e7da      	b.n	8004306 <poll_tcp+0xe>

08004350 <sent_tcp>:
{
 8004350:	b538      	push	{r3, r4, r5, lr}
 8004352:	4615      	mov	r5, r2
  if (conn) {
 8004354:	4604      	mov	r4, r0
 8004356:	b1c8      	cbz	r0, 800438c <sent_tcp+0x3c>
    if (conn->state == NETCONN_WRITE) {
 8004358:	7843      	ldrb	r3, [r0, #1]
 800435a:	2b01      	cmp	r3, #1
 800435c:	d118      	bne.n	8004390 <sent_tcp+0x40>
      lwip_netconn_do_writemore(conn  WRITE_DELAYED);
 800435e:	f7ff fe83 	bl	8004068 <lwip_netconn_do_writemore>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 8004362:	6863      	ldr	r3, [r4, #4]
 8004364:	b193      	cbz	r3, 800438c <sent_tcp+0x3c>
 8004366:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
 800436a:	f5b2 6f86 	cmp.w	r2, #1072	; 0x430
 800436e:	d30d      	bcc.n	800438c <sent_tcp+0x3c>
 8004370:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
 8004374:	2b04      	cmp	r3, #4
 8004376:	d809      	bhi.n	800438c <sent_tcp+0x3c>
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
 8004378:	7f23      	ldrb	r3, [r4, #28]
 800437a:	f023 0310 	bic.w	r3, r3, #16
 800437e:	7723      	strb	r3, [r4, #28]
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
 8004380:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8004382:	b11b      	cbz	r3, 800438c <sent_tcp+0x3c>
 8004384:	462a      	mov	r2, r5
 8004386:	2102      	movs	r1, #2
 8004388:	4620      	mov	r0, r4
 800438a:	4798      	blx	r3
}
 800438c:	2000      	movs	r0, #0
 800438e:	bd38      	pop	{r3, r4, r5, pc}
    } else if (conn->state == NETCONN_CLOSE) {
 8004390:	2b04      	cmp	r3, #4
 8004392:	d1e6      	bne.n	8004362 <sent_tcp+0x12>
      lwip_netconn_do_close_internal(conn  WRITE_DELAYED);
 8004394:	f7ff ff00 	bl	8004198 <lwip_netconn_do_close_internal>
 8004398:	e7e3      	b.n	8004362 <sent_tcp+0x12>

0800439a <recv_tcp>:
{
 800439a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800439e:	4689      	mov	r9, r1
 80043a0:	4615      	mov	r5, r2
 80043a2:	461f      	mov	r7, r3
  if (conn == NULL) {
 80043a4:	4606      	mov	r6, r0
 80043a6:	b358      	cbz	r0, 8004400 <recv_tcp+0x66>
  if (!sys_mbox_valid(&conn->recvmbox)) {
 80043a8:	f100 0810 	add.w	r8, r0, #16
 80043ac:	4640      	mov	r0, r8
 80043ae:	f004 fe8f 	bl	80090d0 <sys_mbox_valid>
 80043b2:	4604      	mov	r4, r0
 80043b4:	b960      	cbnz	r0, 80043d0 <recv_tcp+0x36>
    if (p != NULL) {
 80043b6:	b91d      	cbnz	r5, 80043c0 <recv_tcp+0x26>
    return ERR_OK;
 80043b8:	2400      	movs	r4, #0
}
 80043ba:	4620      	mov	r0, r4
 80043bc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      tcp_recved(pcb, p->tot_len);
 80043c0:	4648      	mov	r0, r9
 80043c2:	8929      	ldrh	r1, [r5, #8]
 80043c4:	f001 fe52 	bl	800606c <tcp_recved>
      pbuf_free(p);
 80043c8:	4628      	mov	r0, r5
 80043ca:	f001 fc14 	bl	8005bf6 <pbuf_free>
 80043ce:	e7f4      	b.n	80043ba <recv_tcp+0x20>
  if (err != ERR_OK) {
 80043d0:	b127      	cbz	r7, 80043dc <recv_tcp+0x42>
    NETCONN_SET_SAFE_ERR(conn, err);
 80043d2:	f996 3008 	ldrsb.w	r3, [r6, #8]
 80043d6:	330b      	adds	r3, #11
 80043d8:	bfa8      	it	ge
 80043da:	7237      	strbge	r7, [r6, #8]
  if (p != NULL) {
 80043dc:	b175      	cbz	r5, 80043fc <recv_tcp+0x62>
    len = p->tot_len;
 80043de:	892f      	ldrh	r7, [r5, #8]
  if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
 80043e0:	4629      	mov	r1, r5
 80043e2:	4640      	mov	r0, r8
 80043e4:	f004 fe2d 	bl	8009042 <sys_mbox_trypost>
 80043e8:	4604      	mov	r4, r0
 80043ea:	b960      	cbnz	r0, 8004406 <recv_tcp+0x6c>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 80043ec:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 80043ee:	2b00      	cmp	r3, #0
 80043f0:	d0e2      	beq.n	80043b8 <recv_tcp+0x1e>
 80043f2:	4601      	mov	r1, r0
 80043f4:	463a      	mov	r2, r7
 80043f6:	4630      	mov	r0, r6
 80043f8:	4798      	blx	r3
 80043fa:	e7de      	b.n	80043ba <recv_tcp+0x20>
    len = 0;
 80043fc:	462f      	mov	r7, r5
 80043fe:	e7ef      	b.n	80043e0 <recv_tcp+0x46>
    return ERR_VAL;
 8004400:	f06f 0405 	mvn.w	r4, #5
 8004404:	e7d9      	b.n	80043ba <recv_tcp+0x20>
    return ERR_MEM;
 8004406:	f04f 34ff 	mov.w	r4, #4294967295
 800440a:	e7d6      	b.n	80043ba <recv_tcp+0x20>

0800440c <lwip_netconn_do_newconn>:
{
 800440c:	b538      	push	{r3, r4, r5, lr}
  msg->err = ERR_OK;
 800440e:	2300      	movs	r3, #0
  if (msg->conn->pcb.tcp == NULL) {
 8004410:	6805      	ldr	r5, [r0, #0]
{
 8004412:	4604      	mov	r4, r0
  msg->err = ERR_OK;
 8004414:	7103      	strb	r3, [r0, #4]
  if (msg->conn->pcb.tcp == NULL) {
 8004416:	686b      	ldr	r3, [r5, #4]
 8004418:	bb2b      	cbnz	r3, 8004466 <lwip_netconn_do_newconn+0x5a>
  switch(NETCONNTYPE_GROUP(msg->conn->type)) {
 800441a:	782b      	ldrb	r3, [r5, #0]
 800441c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8004420:	2b10      	cmp	r3, #16
 8004422:	d014      	beq.n	800444e <lwip_netconn_do_newconn+0x42>
 8004424:	2b20      	cmp	r3, #32
 8004426:	d11c      	bne.n	8004462 <lwip_netconn_do_newconn+0x56>
    msg->conn->pcb.udp = udp_new();
 8004428:	f004 fa98 	bl	800895c <udp_new>
 800442c:	6068      	str	r0, [r5, #4]
    if (msg->conn->pcb.udp != NULL) {
 800442e:	6822      	ldr	r2, [r4, #0]
 8004430:	6850      	ldr	r0, [r2, #4]
 8004432:	b150      	cbz	r0, 800444a <lwip_netconn_do_newconn+0x3e>
      if (NETCONNTYPE_ISUDPNOCHKSUM(msg->conn->type)) {
 8004434:	7813      	ldrb	r3, [r2, #0]
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
 8004436:	4912      	ldr	r1, [pc, #72]	; (8004480 <lwip_netconn_do_newconn+0x74>)
      if (NETCONNTYPE_ISUDPNOCHKSUM(msg->conn->type)) {
 8004438:	2b22      	cmp	r3, #34	; 0x22
        udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
 800443a:	bf04      	itt	eq
 800443c:	2301      	moveq	r3, #1
 800443e:	7403      	strbeq	r3, [r0, #16]
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
 8004440:	f004 fa70 	bl	8008924 <udp_recv>
  if (msg->conn->pcb.ip == NULL) {
 8004444:	6823      	ldr	r3, [r4, #0]
 8004446:	685b      	ldr	r3, [r3, #4]
 8004448:	b96b      	cbnz	r3, 8004466 <lwip_netconn_do_newconn+0x5a>
    msg->err = ERR_MEM;
 800444a:	23ff      	movs	r3, #255	; 0xff
 800444c:	e00a      	b.n	8004464 <lwip_netconn_do_newconn+0x58>
    msg->conn->pcb.tcp = tcp_new();
 800444e:	f002 facf 	bl	80069f0 <tcp_new>
 8004452:	6068      	str	r0, [r5, #4]
    if (msg->conn->pcb.tcp != NULL) {
 8004454:	6820      	ldr	r0, [r4, #0]
 8004456:	6843      	ldr	r3, [r0, #4]
 8004458:	2b00      	cmp	r3, #0
 800445a:	d0f6      	beq.n	800444a <lwip_netconn_do_newconn+0x3e>
      setup_tcp(msg->conn);
 800445c:	f7ff fd68 	bl	8003f30 <setup_tcp>
 8004460:	e7f0      	b.n	8004444 <lwip_netconn_do_newconn+0x38>
    msg->err = ERR_VAL;
 8004462:	23fa      	movs	r3, #250	; 0xfa
    msg->err = ERR_MEM;
 8004464:	7123      	strb	r3, [r4, #4]
  TCPIP_APIMSG_ACK(msg);
 8004466:	6820      	ldr	r0, [r4, #0]
 8004468:	b128      	cbz	r0, 8004476 <lwip_netconn_do_newconn+0x6a>
 800446a:	f990 3008 	ldrsb.w	r3, [r0, #8]
 800446e:	330b      	adds	r3, #11
 8004470:	bfa4      	itt	ge
 8004472:	7923      	ldrbge	r3, [r4, #4]
 8004474:	7203      	strbge	r3, [r0, #8]
 8004476:	300c      	adds	r0, #12
}
 8004478:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  TCPIP_APIMSG_ACK(msg);
 800447c:	f004 be93 	b.w	80091a6 <sys_sem_signal>
 8004480:	08003ec7 	.word	0x08003ec7

08004484 <netconn_alloc>:
{
 8004484:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004486:	4605      	mov	r5, r0
  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
 8004488:	2007      	movs	r0, #7
{
 800448a:	460f      	mov	r7, r1
  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
 800448c:	f001 fa8c 	bl	80059a8 <memp_malloc>
  if (conn == NULL) {
 8004490:	4604      	mov	r4, r0
 8004492:	b360      	cbz	r0, 80044ee <netconn_alloc+0x6a>
  conn->type = t;
 8004494:	7005      	strb	r5, [r0, #0]
  switch(NETCONNTYPE_GROUP(t)) {
 8004496:	f005 05f0 	and.w	r5, r5, #240	; 0xf0
  conn->last_err = ERR_OK;
 800449a:	2300      	movs	r3, #0
  switch(NETCONNTYPE_GROUP(t)) {
 800449c:	2d10      	cmp	r5, #16
  conn->last_err = ERR_OK;
 800449e:	7203      	strb	r3, [r0, #8]
  conn->pcb.tcp = NULL;
 80044a0:	6043      	str	r3, [r0, #4]
  switch(NETCONNTYPE_GROUP(t)) {
 80044a2:	d001      	beq.n	80044a8 <netconn_alloc+0x24>
 80044a4:	2d20      	cmp	r5, #32
 80044a6:	d110      	bne.n	80044ca <netconn_alloc+0x46>
  if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
 80044a8:	f104 0610 	add.w	r6, r4, #16
 80044ac:	2100      	movs	r1, #0
 80044ae:	4630      	mov	r0, r6
 80044b0:	f004 fda0 	bl	8008ff4 <sys_mbox_new>
 80044b4:	4601      	mov	r1, r0
 80044b6:	b940      	cbnz	r0, 80044ca <netconn_alloc+0x46>
  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
 80044b8:	f104 000c 	add.w	r0, r4, #12
 80044bc:	f004 fe10 	bl	80090e0 <sys_sem_new>
 80044c0:	4605      	mov	r5, r0
 80044c2:	b140      	cbz	r0, 80044d6 <netconn_alloc+0x52>
    sys_mbox_free(&conn->recvmbox);
 80044c4:	4630      	mov	r0, r6
 80044c6:	f004 fda2 	bl	800900e <sys_mbox_free>
  memp_free(MEMP_NETCONN, conn);
 80044ca:	4621      	mov	r1, r4
 80044cc:	2007      	movs	r0, #7
 80044ce:	f001 fa77 	bl	80059c0 <memp_free>
  return NULL;
 80044d2:	2400      	movs	r4, #0
 80044d4:	e00b      	b.n	80044ee <netconn_alloc+0x6a>
  sys_mbox_set_invalid(&conn->acceptmbox);
 80044d6:	f104 0014 	add.w	r0, r4, #20
 80044da:	f004 fdfe 	bl	80090da <sys_mbox_set_invalid>
  conn->socket       = -1;
 80044de:	f04f 33ff 	mov.w	r3, #4294967295
  conn->state        = NETCONN_NONE;
 80044e2:	7065      	strb	r5, [r4, #1]
  conn->socket       = -1;
 80044e4:	61a3      	str	r3, [r4, #24]
  conn->callback     = callback;
 80044e6:	62a7      	str	r7, [r4, #40]	; 0x28
  conn->current_msg  = NULL;
 80044e8:	6265      	str	r5, [r4, #36]	; 0x24
  conn->write_offset = 0;
 80044ea:	6225      	str	r5, [r4, #32]
  conn->flags = 0;
 80044ec:	7725      	strb	r5, [r4, #28]
}
 80044ee:	4620      	mov	r0, r4
 80044f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080044f2 <netconn_free>:
{
 80044f2:	b538      	push	{r3, r4, r5, lr}
 80044f4:	4604      	mov	r4, r0
  LWIP_ASSERT("recvmbox must be deallocated before calling this function",
 80044f6:	3010      	adds	r0, #16
 80044f8:	f004 fdea 	bl	80090d0 <sys_mbox_valid>
  sys_sem_free(&conn->op_completed);
 80044fc:	f104 050c 	add.w	r5, r4, #12
  LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
 8004500:	f104 0014 	add.w	r0, r4, #20
 8004504:	f004 fde4 	bl	80090d0 <sys_mbox_valid>
  sys_sem_free(&conn->op_completed);
 8004508:	4628      	mov	r0, r5
 800450a:	f004 fe41 	bl	8009190 <sys_sem_free>
  sys_sem_set_invalid(&conn->op_completed);
 800450e:	4628      	mov	r0, r5
 8004510:	f004 fe27 	bl	8009162 <sys_sem_set_invalid>
  memp_free(MEMP_NETCONN, conn);
 8004514:	4621      	mov	r1, r4
 8004516:	2007      	movs	r0, #7
}
 8004518:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  memp_free(MEMP_NETCONN, conn);
 800451c:	f001 ba50 	b.w	80059c0 <memp_free>

08004520 <netconn_drain>:
{
 8004520:	b573      	push	{r0, r1, r4, r5, r6, lr}
  if (sys_mbox_valid(&conn->recvmbox)) {
 8004522:	f100 0510 	add.w	r5, r0, #16
{
 8004526:	4604      	mov	r4, r0
  if (sys_mbox_valid(&conn->recvmbox)) {
 8004528:	4628      	mov	r0, r5
 800452a:	f004 fdd1 	bl	80090d0 <sys_mbox_valid>
 800452e:	b9b0      	cbnz	r0, 800455e <netconn_drain+0x3e>
  if (sys_mbox_valid(&conn->acceptmbox)) {
 8004530:	3414      	adds	r4, #20
 8004532:	4620      	mov	r0, r4
 8004534:	f004 fdcc 	bl	80090d0 <sys_mbox_valid>
 8004538:	2800      	cmp	r0, #0
 800453a:	d13a      	bne.n	80045b2 <netconn_drain+0x92>
}
 800453c:	b002      	add	sp, #8
 800453e:	bd70      	pop	{r4, r5, r6, pc}
      if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP) {
 8004540:	7823      	ldrb	r3, [r4, #0]
 8004542:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8004546:	2b10      	cmp	r3, #16
 8004548:	d116      	bne.n	8004578 <netconn_drain+0x58>
        if (mem != NULL) {
 800454a:	9e01      	ldr	r6, [sp, #4]
 800454c:	b13e      	cbz	r6, 800455e <netconn_drain+0x3e>
          if (conn->pcb.tcp != NULL) {
 800454e:	6860      	ldr	r0, [r4, #4]
 8004550:	b110      	cbz	r0, 8004558 <netconn_drain+0x38>
            tcp_recved(conn->pcb.tcp, p->tot_len);
 8004552:	8931      	ldrh	r1, [r6, #8]
 8004554:	f001 fd8a 	bl	800606c <tcp_recved>
          pbuf_free(p);
 8004558:	4630      	mov	r0, r6
 800455a:	f001 fb4c 	bl	8005bf6 <pbuf_free>
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
 800455e:	a901      	add	r1, sp, #4
 8004560:	4628      	mov	r0, r5
 8004562:	f004 fda5 	bl	80090b0 <sys_arch_mbox_tryfetch>
 8004566:	3001      	adds	r0, #1
 8004568:	d1ea      	bne.n	8004540 <netconn_drain+0x20>
    sys_mbox_free(&conn->recvmbox);
 800456a:	4628      	mov	r0, r5
 800456c:	f004 fd4f 	bl	800900e <sys_mbox_free>
    sys_mbox_set_invalid(&conn->recvmbox);
 8004570:	4628      	mov	r0, r5
 8004572:	f004 fdb2 	bl	80090da <sys_mbox_set_invalid>
 8004576:	e7db      	b.n	8004530 <netconn_drain+0x10>
        netbuf_delete((struct netbuf *)mem);
 8004578:	9801      	ldr	r0, [sp, #4]
 800457a:	f000 fa40 	bl	80049fe <netbuf_delete>
 800457e:	e7ee      	b.n	800455e <netconn_drain+0x3e>
      struct netconn *newconn = (struct netconn *)mem;
 8004580:	9d01      	ldr	r5, [sp, #4]
      netconn_drain(newconn);
 8004582:	4628      	mov	r0, r5
 8004584:	f7ff ffcc 	bl	8004520 <netconn_drain>
      if (newconn->pcb.tcp != NULL) {
 8004588:	6868      	ldr	r0, [r5, #4]
 800458a:	b110      	cbz	r0, 8004592 <netconn_drain+0x72>
        tcp_abort(newconn->pcb.tcp);
 800458c:	f002 f954 	bl	8006838 <tcp_abort>
        newconn->pcb.tcp = NULL;
 8004590:	606e      	str	r6, [r5, #4]
      netconn_free(newconn);
 8004592:	4628      	mov	r0, r5
 8004594:	f7ff ffad 	bl	80044f2 <netconn_free>
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
 8004598:	a901      	add	r1, sp, #4
 800459a:	4620      	mov	r0, r4
 800459c:	f004 fd88 	bl	80090b0 <sys_arch_mbox_tryfetch>
 80045a0:	3001      	adds	r0, #1
 80045a2:	d1ed      	bne.n	8004580 <netconn_drain+0x60>
    sys_mbox_free(&conn->acceptmbox);
 80045a4:	4620      	mov	r0, r4
 80045a6:	f004 fd32 	bl	800900e <sys_mbox_free>
    sys_mbox_set_invalid(&conn->acceptmbox);
 80045aa:	4620      	mov	r0, r4
 80045ac:	f004 fd95 	bl	80090da <sys_mbox_set_invalid>
}
 80045b0:	e7c4      	b.n	800453c <netconn_drain+0x1c>
        newconn->pcb.tcp = NULL;
 80045b2:	2600      	movs	r6, #0
 80045b4:	e7f0      	b.n	8004598 <netconn_drain+0x78>

080045b6 <accept_function>:
{
 80045b6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (!sys_mbox_valid(&conn->acceptmbox)) {
 80045ba:	f100 0414 	add.w	r4, r0, #20
{
 80045be:	4606      	mov	r6, r0
 80045c0:	4688      	mov	r8, r1
 80045c2:	4617      	mov	r7, r2
  if (!sys_mbox_valid(&conn->acceptmbox)) {
 80045c4:	4620      	mov	r0, r4
 80045c6:	f004 fd83 	bl	80090d0 <sys_mbox_valid>
 80045ca:	2800      	cmp	r0, #0
 80045cc:	d03f      	beq.n	800464e <accept_function+0x98>
  newconn = netconn_alloc(conn->type, conn->callback);
 80045ce:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 80045d0:	7830      	ldrb	r0, [r6, #0]
 80045d2:	f7ff ff57 	bl	8004484 <netconn_alloc>
  if (newconn == NULL) {
 80045d6:	4605      	mov	r5, r0
 80045d8:	b368      	cbz	r0, 8004636 <accept_function+0x80>
  newconn->pcb.tcp = newpcb;
 80045da:	f8c0 8004 	str.w	r8, [r0, #4]
  setup_tcp(newconn);
 80045de:	f7ff fca7 	bl	8003f30 <setup_tcp>
  if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
 80045e2:	4620      	mov	r0, r4
  newconn->last_err = err;
 80045e4:	722f      	strb	r7, [r5, #8]
  if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
 80045e6:	4629      	mov	r1, r5
 80045e8:	f004 fd2b 	bl	8009042 <sys_mbox_trypost>
 80045ec:	4604      	mov	r4, r0
 80045ee:	b328      	cbz	r0, 800463c <accept_function+0x86>
    struct tcp_pcb* pcb = newconn->pcb.tcp;
 80045f0:	686c      	ldr	r4, [r5, #4]
    tcp_arg(pcb, NULL);
 80045f2:	2100      	movs	r1, #0
 80045f4:	4620      	mov	r0, r4
 80045f6:	f001 fd89 	bl	800610c <tcp_arg>
    tcp_recv(pcb, NULL);
 80045fa:	4620      	mov	r0, r4
 80045fc:	2100      	movs	r1, #0
 80045fe:	f001 fd87 	bl	8006110 <tcp_recv>
    tcp_sent(pcb, NULL);
 8004602:	4620      	mov	r0, r4
 8004604:	2100      	movs	r1, #0
 8004606:	f001 fd86 	bl	8006116 <tcp_sent>
    tcp_poll(pcb, NULL, 0);
 800460a:	2200      	movs	r2, #0
 800460c:	4620      	mov	r0, r4
 800460e:	4611      	mov	r1, r2
 8004610:	f001 fd88 	bl	8006124 <tcp_poll>
    tcp_err(pcb, NULL);
 8004614:	2100      	movs	r1, #0
 8004616:	4620      	mov	r0, r4
    sys_mbox_free(&newconn->recvmbox);
 8004618:	f105 0410 	add.w	r4, r5, #16
    tcp_err(pcb, NULL);
 800461c:	f001 fd7d 	bl	800611a <tcp_err>
    newconn->pcb.tcp = NULL;
 8004620:	2300      	movs	r3, #0
    sys_mbox_free(&newconn->recvmbox);
 8004622:	4620      	mov	r0, r4
    newconn->pcb.tcp = NULL;
 8004624:	606b      	str	r3, [r5, #4]
    sys_mbox_free(&newconn->recvmbox);
 8004626:	f004 fcf2 	bl	800900e <sys_mbox_free>
    sys_mbox_set_invalid(&newconn->recvmbox);
 800462a:	4620      	mov	r0, r4
 800462c:	f004 fd55 	bl	80090da <sys_mbox_set_invalid>
    netconn_free(newconn);
 8004630:	4628      	mov	r0, r5
 8004632:	f7ff ff5e 	bl	80044f2 <netconn_free>
    return ERR_MEM;
 8004636:	f04f 34ff 	mov.w	r4, #4294967295
 800463a:	e005      	b.n	8004648 <accept_function+0x92>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 800463c:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 800463e:	b11b      	cbz	r3, 8004648 <accept_function+0x92>
 8004640:	4602      	mov	r2, r0
 8004642:	4601      	mov	r1, r0
 8004644:	4630      	mov	r0, r6
 8004646:	4798      	blx	r3
}
 8004648:	4620      	mov	r0, r4
 800464a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return ERR_VAL;
 800464e:	f06f 0405 	mvn.w	r4, #5
 8004652:	e7f9      	b.n	8004648 <accept_function+0x92>

08004654 <lwip_netconn_do_delconn>:
{
 8004654:	b538      	push	{r3, r4, r5, lr}
 8004656:	4604      	mov	r4, r0
  enum netconn_state state = msg->conn->state;
 8004658:	6800      	ldr	r0, [r0, #0]
 800465a:	7843      	ldrb	r3, [r0, #1]
  if (((state != NETCONN_NONE) &&
 800465c:	f013 0ffd 	tst.w	r3, #253	; 0xfd
 8004660:	d019      	beq.n	8004696 <lwip_netconn_do_delconn+0x42>
       (state != NETCONN_LISTEN) &&
 8004662:	2b03      	cmp	r3, #3
 8004664:	d102      	bne.n	800466c <lwip_netconn_do_delconn+0x18>
      ((state == NETCONN_CONNECT) && !IN_NONBLOCKING_CONNECT(msg->conn))) {
 8004666:	7f03      	ldrb	r3, [r0, #28]
 8004668:	075b      	lsls	r3, r3, #29
 800466a:	d414      	bmi.n	8004696 <lwip_netconn_do_delconn+0x42>
    msg->err = ERR_INPROGRESS;
 800466c:	23fb      	movs	r3, #251	; 0xfb
 800466e:	7123      	strb	r3, [r4, #4]
  if (sys_sem_valid(LWIP_API_MSG_SEM(msg))) {
 8004670:	6820      	ldr	r0, [r4, #0]
 8004672:	300c      	adds	r0, #12
 8004674:	f004 fd70 	bl	8009158 <sys_sem_valid>
 8004678:	2800      	cmp	r0, #0
 800467a:	d038      	beq.n	80046ee <lwip_netconn_do_delconn+0x9a>
    TCPIP_APIMSG_ACK(msg);
 800467c:	6820      	ldr	r0, [r4, #0]
 800467e:	b128      	cbz	r0, 800468c <lwip_netconn_do_delconn+0x38>
 8004680:	f990 3008 	ldrsb.w	r3, [r0, #8]
 8004684:	330b      	adds	r3, #11
 8004686:	bfa4      	itt	ge
 8004688:	7923      	ldrbge	r3, [r4, #4]
 800468a:	7203      	strbge	r3, [r0, #8]
 800468c:	300c      	adds	r0, #12
}
 800468e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    TCPIP_APIMSG_ACK(msg);
 8004692:	f004 bd88 	b.w	80091a6 <sys_sem_signal>
    msg->err = ERR_OK;
 8004696:	2500      	movs	r5, #0
 8004698:	7125      	strb	r5, [r4, #4]
    netconn_drain(msg->conn);
 800469a:	f7ff ff41 	bl	8004520 <netconn_drain>
    if (msg->conn->pcb.tcp != NULL) {
 800469e:	6823      	ldr	r3, [r4, #0]
 80046a0:	6858      	ldr	r0, [r3, #4]
 80046a2:	b160      	cbz	r0, 80046be <lwip_netconn_do_delconn+0x6a>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 80046a4:	781a      	ldrb	r2, [r3, #0]
 80046a6:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 80046aa:	2a10      	cmp	r2, #16
 80046ac:	d015      	beq.n	80046da <lwip_netconn_do_delconn+0x86>
 80046ae:	2a20      	cmp	r2, #32
 80046b0:	d102      	bne.n	80046b8 <lwip_netconn_do_delconn+0x64>
        msg->conn->pcb.udp->recv_arg = NULL;
 80046b2:	61c5      	str	r5, [r0, #28]
        udp_remove(msg->conn->pcb.udp);
 80046b4:	f004 f93a 	bl	800892c <udp_remove>
      msg->conn->pcb.tcp = NULL;
 80046b8:	6823      	ldr	r3, [r4, #0]
 80046ba:	2200      	movs	r2, #0
 80046bc:	605a      	str	r2, [r3, #4]
    API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
 80046be:	6820      	ldr	r0, [r4, #0]
 80046c0:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80046c2:	b113      	cbz	r3, 80046ca <lwip_netconn_do_delconn+0x76>
 80046c4:	2200      	movs	r2, #0
 80046c6:	4611      	mov	r1, r2
 80046c8:	4798      	blx	r3
    API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
 80046ca:	6820      	ldr	r0, [r4, #0]
 80046cc:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80046ce:	2b00      	cmp	r3, #0
 80046d0:	d0ce      	beq.n	8004670 <lwip_netconn_do_delconn+0x1c>
 80046d2:	2200      	movs	r2, #0
 80046d4:	2102      	movs	r1, #2
 80046d6:	4798      	blx	r3
 80046d8:	e7ca      	b.n	8004670 <lwip_netconn_do_delconn+0x1c>
        msg->conn->state = NETCONN_CLOSE;
 80046da:	2204      	movs	r2, #4
        lwip_netconn_do_close_internal(msg->conn);
 80046dc:	4618      	mov	r0, r3
        msg->conn->state = NETCONN_CLOSE;
 80046de:	705a      	strb	r2, [r3, #1]
        msg->msg.sd.shut = NETCONN_SHUT_RDWR;
 80046e0:	2203      	movs	r2, #3
 80046e2:	7222      	strb	r2, [r4, #8]
        msg->conn->current_msg = msg;
 80046e4:	625c      	str	r4, [r3, #36]	; 0x24
}
 80046e6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        lwip_netconn_do_close_internal(msg->conn);
 80046ea:	f7ff bd55 	b.w	8004198 <lwip_netconn_do_close_internal>
 80046ee:	bd38      	pop	{r3, r4, r5, pc}

080046f0 <lwip_netconn_do_bind>:
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 80046f0:	6803      	ldr	r3, [r0, #0]
{
 80046f2:	b510      	push	{r4, lr}
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 80046f4:	f993 2008 	ldrsb.w	r2, [r3, #8]
{
 80046f8:	4604      	mov	r4, r0
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 80046fa:	f112 0f0b 	cmn.w	r2, #11
 80046fe:	da0d      	bge.n	800471c <lwip_netconn_do_bind+0x2c>
    msg->err = msg->conn->last_err;
 8004700:	7102      	strb	r2, [r0, #4]
  TCPIP_APIMSG_ACK(msg);
 8004702:	6820      	ldr	r0, [r4, #0]
 8004704:	b128      	cbz	r0, 8004712 <lwip_netconn_do_bind+0x22>
 8004706:	f990 3008 	ldrsb.w	r3, [r0, #8]
 800470a:	330b      	adds	r3, #11
 800470c:	bfa4      	itt	ge
 800470e:	7923      	ldrbge	r3, [r4, #4]
 8004710:	7203      	strbge	r3, [r0, #8]
 8004712:	300c      	adds	r0, #12
}
 8004714:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  TCPIP_APIMSG_ACK(msg);
 8004718:	f004 bd45 	b.w	80091a6 <sys_sem_signal>
    msg->err = ERR_VAL;
 800471c:	22fa      	movs	r2, #250	; 0xfa
 800471e:	7102      	strb	r2, [r0, #4]
    if (msg->conn->pcb.tcp != NULL) {
 8004720:	6858      	ldr	r0, [r3, #4]
 8004722:	2800      	cmp	r0, #0
 8004724:	d0ed      	beq.n	8004702 <lwip_netconn_do_bind+0x12>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 8004726:	781b      	ldrb	r3, [r3, #0]
 8004728:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800472c:	2b10      	cmp	r3, #16
 800472e:	d007      	beq.n	8004740 <lwip_netconn_do_bind+0x50>
 8004730:	2b20      	cmp	r3, #32
 8004732:	d1e6      	bne.n	8004702 <lwip_netconn_do_bind+0x12>
        msg->err = udp_bind(msg->conn->pcb.udp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
 8004734:	89a2      	ldrh	r2, [r4, #12]
 8004736:	68a1      	ldr	r1, [r4, #8]
 8004738:	f003 ffee 	bl	8008718 <udp_bind>
        msg->err = tcp_bind(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
 800473c:	7120      	strb	r0, [r4, #4]
        break;
 800473e:	e7e0      	b.n	8004702 <lwip_netconn_do_bind+0x12>
        msg->err = tcp_bind(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
 8004740:	89a2      	ldrh	r2, [r4, #12]
 8004742:	68a1      	ldr	r1, [r4, #8]
 8004744:	f001 fbfc 	bl	8005f40 <tcp_bind>
 8004748:	e7f8      	b.n	800473c <lwip_netconn_do_bind+0x4c>
	...

0800474c <lwip_netconn_do_connect>:
  if (msg->conn->pcb.tcp == NULL) {
 800474c:	6803      	ldr	r3, [r0, #0]
{
 800474e:	b510      	push	{r4, lr}
 8004750:	4604      	mov	r4, r0
  if (msg->conn->pcb.tcp == NULL) {
 8004752:	6858      	ldr	r0, [r3, #4]
 8004754:	b910      	cbnz	r0, 800475c <lwip_netconn_do_connect+0x10>
    msg->err = ERR_CLSD;
 8004756:	23f2      	movs	r3, #242	; 0xf2
      LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
 8004758:	7123      	strb	r3, [r4, #4]
      break;
 800475a:	e00b      	b.n	8004774 <lwip_netconn_do_connect+0x28>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 800475c:	781a      	ldrb	r2, [r3, #0]
 800475e:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8004762:	2a10      	cmp	r2, #16
 8004764:	d013      	beq.n	800478e <lwip_netconn_do_connect+0x42>
 8004766:	2a20      	cmp	r2, #32
 8004768:	d136      	bne.n	80047d8 <lwip_netconn_do_connect+0x8c>
      msg->err = udp_connect(msg->conn->pcb.udp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
 800476a:	89a2      	ldrh	r2, [r4, #12]
 800476c:	68a1      	ldr	r1, [r4, #8]
 800476e:	f004 f8b1 	bl	80088d4 <udp_connect>
 8004772:	7120      	strb	r0, [r4, #4]
  TCPIP_APIMSG_ACK(msg);
 8004774:	6820      	ldr	r0, [r4, #0]
 8004776:	b128      	cbz	r0, 8004784 <lwip_netconn_do_connect+0x38>
 8004778:	f990 3008 	ldrsb.w	r3, [r0, #8]
 800477c:	330b      	adds	r3, #11
 800477e:	bfa4      	itt	ge
 8004780:	7923      	ldrbge	r3, [r4, #4]
 8004782:	7203      	strbge	r3, [r0, #8]
 8004784:	300c      	adds	r0, #12
}
 8004786:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  TCPIP_APIMSG_ACK(msg);
 800478a:	f004 bd0c 	b.w	80091a6 <sys_sem_signal>
      if (msg->conn->state == NETCONN_CONNECT) {
 800478e:	785a      	ldrb	r2, [r3, #1]
 8004790:	2a03      	cmp	r2, #3
 8004792:	d101      	bne.n	8004798 <lwip_netconn_do_connect+0x4c>
        msg->err = ERR_ALREADY;
 8004794:	23f7      	movs	r3, #247	; 0xf7
 8004796:	e7df      	b.n	8004758 <lwip_netconn_do_connect+0xc>
      } else if (msg->conn->state != NETCONN_NONE) {
 8004798:	b10a      	cbz	r2, 800479e <lwip_netconn_do_connect+0x52>
        msg->err = ERR_ISCONN;
 800479a:	23f6      	movs	r3, #246	; 0xf6
 800479c:	e7dc      	b.n	8004758 <lwip_netconn_do_connect+0xc>
        setup_tcp(msg->conn);
 800479e:	4618      	mov	r0, r3
 80047a0:	f7ff fbc6 	bl	8003f30 <setup_tcp>
        msg->err = tcp_connect(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr),
 80047a4:	6820      	ldr	r0, [r4, #0]
 80047a6:	4b0d      	ldr	r3, [pc, #52]	; (80047dc <lwip_netconn_do_connect+0x90>)
 80047a8:	89a2      	ldrh	r2, [r4, #12]
 80047aa:	68a1      	ldr	r1, [r4, #8]
 80047ac:	6840      	ldr	r0, [r0, #4]
 80047ae:	f002 f931 	bl	8006a14 <tcp_connect>
 80047b2:	7120      	strb	r0, [r4, #4]
        if (msg->err == ERR_OK) {
 80047b4:	2800      	cmp	r0, #0
 80047b6:	d1dd      	bne.n	8004774 <lwip_netconn_do_connect+0x28>
          u8_t non_blocking = netconn_is_nonblocking(msg->conn);
 80047b8:	6822      	ldr	r2, [r4, #0]
          msg->conn->state = NETCONN_CONNECT;
 80047ba:	2103      	movs	r1, #3
          u8_t non_blocking = netconn_is_nonblocking(msg->conn);
 80047bc:	7f13      	ldrb	r3, [r2, #28]
          msg->conn->state = NETCONN_CONNECT;
 80047be:	7051      	strb	r1, [r2, #1]
          SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
 80047c0:	0799      	lsls	r1, r3, #30
 80047c2:	d504      	bpl.n	80047ce <lwip_netconn_do_connect+0x82>
 80047c4:	f043 0304 	orr.w	r3, r3, #4
 80047c8:	7713      	strb	r3, [r2, #28]
            msg->err = ERR_INPROGRESS;
 80047ca:	23fb      	movs	r3, #251	; 0xfb
 80047cc:	e7c4      	b.n	8004758 <lwip_netconn_do_connect+0xc>
          SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
 80047ce:	f023 0304 	bic.w	r3, r3, #4
            msg->conn->current_msg = msg;
 80047d2:	6254      	str	r4, [r2, #36]	; 0x24
          SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
 80047d4:	7713      	strb	r3, [r2, #28]
            return;
 80047d6:	bd10      	pop	{r4, pc}
      LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
 80047d8:	23fa      	movs	r3, #250	; 0xfa
 80047da:	e7bd      	b.n	8004758 <lwip_netconn_do_connect+0xc>
 80047dc:	08003f75 	.word	0x08003f75

080047e0 <lwip_netconn_do_listen>:
{
 80047e0:	b538      	push	{r3, r4, r5, lr}
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 80047e2:	6803      	ldr	r3, [r0, #0]
{
 80047e4:	4604      	mov	r4, r0
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 80047e6:	f993 2008 	ldrsb.w	r2, [r3, #8]
 80047ea:	f112 0f0b 	cmn.w	r2, #11
 80047ee:	da0d      	bge.n	800480c <lwip_netconn_do_listen+0x2c>
    msg->err = msg->conn->last_err;
 80047f0:	7102      	strb	r2, [r0, #4]
  TCPIP_APIMSG_ACK(msg);
 80047f2:	6820      	ldr	r0, [r4, #0]
 80047f4:	b128      	cbz	r0, 8004802 <lwip_netconn_do_listen+0x22>
 80047f6:	f990 3008 	ldrsb.w	r3, [r0, #8]
 80047fa:	330b      	adds	r3, #11
 80047fc:	bfa4      	itt	ge
 80047fe:	7923      	ldrbge	r3, [r4, #4]
 8004800:	7203      	strbge	r3, [r0, #8]
 8004802:	300c      	adds	r0, #12
}
 8004804:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  TCPIP_APIMSG_ACK(msg);
 8004808:	f004 bccd 	b.w	80091a6 <sys_sem_signal>
    msg->err = ERR_CONN;
 800480c:	22f5      	movs	r2, #245	; 0xf5
 800480e:	7102      	strb	r2, [r0, #4]
    if (msg->conn->pcb.tcp != NULL) {
 8004810:	6858      	ldr	r0, [r3, #4]
 8004812:	2800      	cmp	r0, #0
 8004814:	d0ed      	beq.n	80047f2 <lwip_netconn_do_listen+0x12>
      if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
 8004816:	781a      	ldrb	r2, [r3, #0]
 8004818:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 800481c:	2a10      	cmp	r2, #16
 800481e:	d13f      	bne.n	80048a0 <lwip_netconn_do_listen+0xc0>
        if (msg->conn->state == NETCONN_NONE) {
 8004820:	785b      	ldrb	r3, [r3, #1]
 8004822:	2b00      	cmp	r3, #0
 8004824:	d1e5      	bne.n	80047f2 <lwip_netconn_do_listen+0x12>
          if (msg->conn->pcb.tcp->state != CLOSED) {
 8004826:	7e03      	ldrb	r3, [r0, #24]
 8004828:	b113      	cbz	r3, 8004830 <lwip_netconn_do_listen+0x50>
            msg->err = ERR_VAL;
 800482a:	23fa      	movs	r3, #250	; 0xfa
        msg->err = ERR_ARG;
 800482c:	7123      	strb	r3, [r4, #4]
 800482e:	e7e0      	b.n	80047f2 <lwip_netconn_do_listen+0x12>
              lpcb = tcp_listen(msg->conn->pcb.tcp);
 8004830:	21ff      	movs	r1, #255	; 0xff
 8004832:	f001 fbbf 	bl	8005fb4 <tcp_listen_with_backlog>
            if (lpcb == NULL) {
 8004836:	4605      	mov	r5, r0
 8004838:	b908      	cbnz	r0, 800483e <lwip_netconn_do_listen+0x5e>
              msg->err = ERR_MEM;
 800483a:	23ff      	movs	r3, #255	; 0xff
 800483c:	e7f6      	b.n	800482c <lwip_netconn_do_listen+0x4c>
              if (sys_mbox_valid(&msg->conn->recvmbox)) {
 800483e:	6820      	ldr	r0, [r4, #0]
 8004840:	3010      	adds	r0, #16
 8004842:	f004 fc45 	bl	80090d0 <sys_mbox_valid>
 8004846:	b138      	cbz	r0, 8004858 <lwip_netconn_do_listen+0x78>
                sys_mbox_free(&msg->conn->recvmbox);
 8004848:	6820      	ldr	r0, [r4, #0]
 800484a:	3010      	adds	r0, #16
 800484c:	f004 fbdf 	bl	800900e <sys_mbox_free>
                sys_mbox_set_invalid(&msg->conn->recvmbox);
 8004850:	6820      	ldr	r0, [r4, #0]
 8004852:	3010      	adds	r0, #16
 8004854:	f004 fc41 	bl	80090da <sys_mbox_set_invalid>
              msg->err = ERR_OK;
 8004858:	2300      	movs	r3, #0
              if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
 800485a:	6820      	ldr	r0, [r4, #0]
              msg->err = ERR_OK;
 800485c:	7123      	strb	r3, [r4, #4]
              if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
 800485e:	3014      	adds	r0, #20
 8004860:	f004 fc36 	bl	80090d0 <sys_mbox_valid>
 8004864:	4601      	mov	r1, r0
 8004866:	b920      	cbnz	r0, 8004872 <lwip_netconn_do_listen+0x92>
                msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
 8004868:	6820      	ldr	r0, [r4, #0]
 800486a:	3014      	adds	r0, #20
 800486c:	f004 fbc2 	bl	8008ff4 <sys_mbox_new>
 8004870:	7120      	strb	r0, [r4, #4]
              if (msg->err == ERR_OK) {
 8004872:	f994 3004 	ldrsb.w	r3, [r4, #4]
 8004876:	b963      	cbnz	r3, 8004892 <lwip_netconn_do_listen+0xb2>
                msg->conn->state = NETCONN_LISTEN;
 8004878:	6821      	ldr	r1, [r4, #0]
 800487a:	2302      	movs	r3, #2
                tcp_arg(msg->conn->pcb.tcp, msg->conn);
 800487c:	4628      	mov	r0, r5
                msg->conn->state = NETCONN_LISTEN;
 800487e:	704b      	strb	r3, [r1, #1]
                msg->conn->pcb.tcp = lpcb;
 8004880:	604d      	str	r5, [r1, #4]
                tcp_arg(msg->conn->pcb.tcp, msg->conn);
 8004882:	f001 fc43 	bl	800610c <tcp_arg>
                tcp_accept(msg->conn->pcb.tcp, accept_function);
 8004886:	6823      	ldr	r3, [r4, #0]
 8004888:	4906      	ldr	r1, [pc, #24]	; (80048a4 <lwip_netconn_do_listen+0xc4>)
 800488a:	6858      	ldr	r0, [r3, #4]
 800488c:	f001 fc48 	bl	8006120 <tcp_accept>
 8004890:	e7af      	b.n	80047f2 <lwip_netconn_do_listen+0x12>
                tcp_close(lpcb);
 8004892:	4628      	mov	r0, r5
 8004894:	f001 fea6 	bl	80065e4 <tcp_close>
                msg->conn->pcb.tcp = NULL;
 8004898:	6823      	ldr	r3, [r4, #0]
 800489a:	2200      	movs	r2, #0
 800489c:	605a      	str	r2, [r3, #4]
 800489e:	e7a8      	b.n	80047f2 <lwip_netconn_do_listen+0x12>
        msg->err = ERR_ARG;
 80048a0:	23f1      	movs	r3, #241	; 0xf1
 80048a2:	e7c3      	b.n	800482c <lwip_netconn_do_listen+0x4c>
 80048a4:	080045b7 	.word	0x080045b7

080048a8 <lwip_netconn_do_send>:
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 80048a8:	6803      	ldr	r3, [r0, #0]
{
 80048aa:	b510      	push	{r4, lr}
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 80048ac:	f993 2008 	ldrsb.w	r2, [r3, #8]
{
 80048b0:	4604      	mov	r4, r0
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 80048b2:	f112 0f0b 	cmn.w	r2, #11
 80048b6:	da0d      	bge.n	80048d4 <lwip_netconn_do_send+0x2c>
    msg->err = msg->conn->last_err;
 80048b8:	7102      	strb	r2, [r0, #4]
  TCPIP_APIMSG_ACK(msg);
 80048ba:	6820      	ldr	r0, [r4, #0]
 80048bc:	b128      	cbz	r0, 80048ca <lwip_netconn_do_send+0x22>
 80048be:	f990 3008 	ldrsb.w	r3, [r0, #8]
 80048c2:	330b      	adds	r3, #11
 80048c4:	bfa4      	itt	ge
 80048c6:	7923      	ldrbge	r3, [r4, #4]
 80048c8:	7203      	strbge	r3, [r0, #8]
 80048ca:	300c      	adds	r0, #12
}
 80048cc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  TCPIP_APIMSG_ACK(msg);
 80048d0:	f004 bc69 	b.w	80091a6 <sys_sem_signal>
    msg->err = ERR_CONN;
 80048d4:	22f5      	movs	r2, #245	; 0xf5
 80048d6:	7102      	strb	r2, [r0, #4]
    if (msg->conn->pcb.tcp != NULL) {
 80048d8:	6858      	ldr	r0, [r3, #4]
 80048da:	2800      	cmp	r0, #0
 80048dc:	d0ed      	beq.n	80048ba <lwip_netconn_do_send+0x12>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 80048de:	781b      	ldrb	r3, [r3, #0]
 80048e0:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80048e4:	2b20      	cmp	r3, #32
 80048e6:	d1e8      	bne.n	80048ba <lwip_netconn_do_send+0x12>
        if (ip_addr_isany_val(msg->msg.b->addr)) {
 80048e8:	68a1      	ldr	r1, [r4, #8]
 80048ea:	688b      	ldr	r3, [r1, #8]
 80048ec:	b923      	cbnz	r3, 80048f8 <lwip_netconn_do_send+0x50>
          msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
 80048ee:	6809      	ldr	r1, [r1, #0]
 80048f0:	f003 ffeb 	bl	80088ca <udp_send>
          msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
 80048f4:	7120      	strb	r0, [r4, #4]
 80048f6:	e7e0      	b.n	80048ba <lwip_netconn_do_send+0x12>
 80048f8:	898b      	ldrh	r3, [r1, #12]
 80048fa:	f101 0208 	add.w	r2, r1, #8
 80048fe:	6809      	ldr	r1, [r1, #0]
 8004900:	f003 ffca 	bl	8008898 <udp_sendto>
 8004904:	e7f6      	b.n	80048f4 <lwip_netconn_do_send+0x4c>

08004906 <lwip_netconn_do_recv>:
{
 8004906:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  msg->err = ERR_OK;
 8004908:	2300      	movs	r3, #0
{
 800490a:	4604      	mov	r4, r0
  msg->err = ERR_OK;
 800490c:	7103      	strb	r3, [r0, #4]
  if (msg->conn->pcb.tcp != NULL) {
 800490e:	6803      	ldr	r3, [r0, #0]
 8004910:	685a      	ldr	r2, [r3, #4]
 8004912:	b932      	cbnz	r2, 8004922 <lwip_netconn_do_recv+0x1c>
  TCPIP_APIMSG_ACK(msg);
 8004914:	6820      	ldr	r0, [r4, #0]
 8004916:	b9c0      	cbnz	r0, 800494a <lwip_netconn_do_recv+0x44>
 8004918:	300c      	adds	r0, #12
}
 800491a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  TCPIP_APIMSG_ACK(msg);
 800491e:	f004 bc42 	b.w	80091a6 <sys_sem_signal>
    if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
 8004922:	781b      	ldrb	r3, [r3, #0]
 8004924:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8004928:	2b10      	cmp	r3, #16
 800492a:	d1f3      	bne.n	8004914 <lwip_netconn_do_recv+0xe>
        u32_t remaining = msg->msg.r.len;
 800492c:	6885      	ldr	r5, [r0, #8]
 800492e:	f64f 77ff 	movw	r7, #65535	; 0xffff
 8004932:	42bd      	cmp	r5, r7
 8004934:	462e      	mov	r6, r5
          tcp_recved(msg->conn->pcb.tcp, recved);
 8004936:	6823      	ldr	r3, [r4, #0]
 8004938:	bf28      	it	cs
 800493a:	463e      	movcs	r6, r7
 800493c:	6858      	ldr	r0, [r3, #4]
 800493e:	b2b1      	uxth	r1, r6
 8004940:	f001 fb94 	bl	800606c <tcp_recved>
        } while (remaining != 0);
 8004944:	1bad      	subs	r5, r5, r6
 8004946:	d1f4      	bne.n	8004932 <lwip_netconn_do_recv+0x2c>
 8004948:	e7e4      	b.n	8004914 <lwip_netconn_do_recv+0xe>
  TCPIP_APIMSG_ACK(msg);
 800494a:	f990 3008 	ldrsb.w	r3, [r0, #8]
 800494e:	330b      	adds	r3, #11
 8004950:	bfa4      	itt	ge
 8004952:	7923      	ldrbge	r3, [r4, #4]
 8004954:	7203      	strbge	r3, [r0, #8]
 8004956:	e7df      	b.n	8004918 <lwip_netconn_do_recv+0x12>

08004958 <lwip_netconn_do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
lwip_netconn_do_write(struct api_msg_msg *msg)
{
 8004958:	4603      	mov	r3, r0
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 800495a:	6800      	ldr	r0, [r0, #0]
 800495c:	f990 2008 	ldrsb.w	r2, [r0, #8]
 8004960:	f112 0f0b 	cmn.w	r2, #11
 8004964:	da03      	bge.n	800496e <lwip_netconn_do_write+0x16>
    msg->err = msg->conn->last_err;
 8004966:	711a      	strb	r2, [r3, #4]
    } else {
      msg->err = ERR_VAL;
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
 8004968:	300c      	adds	r0, #12
 800496a:	f004 bc1c 	b.w	80091a6 <sys_sem_signal>
    if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
 800496e:	7802      	ldrb	r2, [r0, #0]
 8004970:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8004974:	2a10      	cmp	r2, #16
 8004976:	d110      	bne.n	800499a <lwip_netconn_do_write+0x42>
      if (msg->conn->state != NETCONN_NONE) {
 8004978:	7842      	ldrb	r2, [r0, #1]
 800497a:	b122      	cbz	r2, 8004986 <lwip_netconn_do_write+0x2e>
        msg->err = ERR_INPROGRESS;
 800497c:	22fb      	movs	r2, #251	; 0xfb
        msg->err = ERR_CONN;
 800497e:	711a      	strb	r2, [r3, #4]
  TCPIP_APIMSG_ACK(msg);
 8004980:	791b      	ldrb	r3, [r3, #4]
 8004982:	7203      	strb	r3, [r0, #8]
 8004984:	e7f0      	b.n	8004968 <lwip_netconn_do_write+0x10>
      } else if (msg->conn->pcb.tcp != NULL) {
 8004986:	6841      	ldr	r1, [r0, #4]
 8004988:	b129      	cbz	r1, 8004996 <lwip_netconn_do_write+0x3e>
        msg->conn->state = NETCONN_WRITE;
 800498a:	2101      	movs	r1, #1
        msg->conn->current_msg = msg;
 800498c:	6243      	str	r3, [r0, #36]	; 0x24
        msg->conn->write_offset = 0;
 800498e:	6202      	str	r2, [r0, #32]
        msg->conn->state = NETCONN_WRITE;
 8004990:	7041      	strb	r1, [r0, #1]
        lwip_netconn_do_writemore(msg->conn);
 8004992:	f7ff bb69 	b.w	8004068 <lwip_netconn_do_writemore>
        msg->err = ERR_CONN;
 8004996:	22f5      	movs	r2, #245	; 0xf5
 8004998:	e7f1      	b.n	800497e <lwip_netconn_do_write+0x26>
      msg->err = ERR_VAL;
 800499a:	22fa      	movs	r2, #250	; 0xfa
 800499c:	e7ef      	b.n	800497e <lwip_netconn_do_write+0x26>

0800499e <lwip_netconn_do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
lwip_netconn_do_close(struct api_msg_msg *msg)
{
 800499e:	b510      	push	{r4, lr}
 80049a0:	4604      	mov	r4, r0
#if LWIP_TCP
  enum netconn_state state = msg->conn->state;
 80049a2:	6800      	ldr	r0, [r0, #0]
  /* First check if this is a TCP netconn and if it is in a correct state
      (LISTEN doesn't support half shutdown) */
  if ((msg->conn->pcb.tcp != NULL) &&
 80049a4:	6843      	ldr	r3, [r0, #4]
 80049a6:	b163      	cbz	r3, 80049c2 <lwip_netconn_do_close+0x24>
 80049a8:	7803      	ldrb	r3, [r0, #0]
 80049aa:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80049ae:	2b10      	cmp	r3, #16
 80049b0:	d107      	bne.n	80049c2 <lwip_netconn_do_close+0x24>
      (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) &&
      ((msg->msg.sd.shut == NETCONN_SHUT_RDWR) || (state != NETCONN_LISTEN))) {
 80049b2:	7a22      	ldrb	r2, [r4, #8]
  enum netconn_state state = msg->conn->state;
 80049b4:	7843      	ldrb	r3, [r0, #1]
      (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) &&
 80049b6:	2a03      	cmp	r2, #3
 80049b8:	d001      	beq.n	80049be <lwip_netconn_do_close+0x20>
      ((msg->msg.sd.shut == NETCONN_SHUT_RDWR) || (state != NETCONN_LISTEN))) {
 80049ba:	2b02      	cmp	r3, #2
 80049bc:	d001      	beq.n	80049c2 <lwip_netconn_do_close+0x24>
    /* Check if we are in a connected state */
    if (state == NETCONN_CONNECT) {
 80049be:	2b03      	cmp	r3, #3
 80049c0:	d10d      	bne.n	80049de <lwip_netconn_do_close+0x40>
      /* TCP connect in progress: cannot shutdown */
      msg->err = ERR_CONN;
 80049c2:	23f5      	movs	r3, #245	; 0xf5
        /* In this case, let the write continue and do not interfere with
           conn->current_msg or conn->state! */
        msg->err = tcp_shutdown(msg->conn->pcb.tcp, 1, 0);
      }
#else /* LWIP_NETCONN_FULLDUPLEX */
      msg->err = ERR_INPROGRESS;
 80049c4:	7123      	strb	r3, [r4, #4]
  } else
#endif /* LWIP_TCP */
  {
    msg->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
 80049c6:	300c      	adds	r0, #12
 80049c8:	f910 3c04 	ldrsb.w	r3, [r0, #-4]
 80049cc:	330b      	adds	r3, #11
 80049ce:	bfa4      	itt	ge
 80049d0:	7923      	ldrbge	r3, [r4, #4]
 80049d2:	f800 3c04 	strbge.w	r3, [r0, #-4]
}
 80049d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  TCPIP_APIMSG_ACK(msg);
 80049da:	f004 bbe4 	b.w	80091a6 <sys_sem_signal>
    } else if (state == NETCONN_WRITE) {
 80049de:	2b01      	cmp	r3, #1
 80049e0:	d101      	bne.n	80049e6 <lwip_netconn_do_close+0x48>
      msg->err = ERR_INPROGRESS;
 80049e2:	23fb      	movs	r3, #251	; 0xfb
 80049e4:	e7ee      	b.n	80049c4 <lwip_netconn_do_close+0x26>
      if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
 80049e6:	07d3      	lsls	r3, r2, #31
 80049e8:	d501      	bpl.n	80049ee <lwip_netconn_do_close+0x50>
        netconn_drain(msg->conn);
 80049ea:	f7ff fd99 	bl	8004520 <netconn_drain>
      LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 80049ee:	6820      	ldr	r0, [r4, #0]
      msg->conn->state = NETCONN_CLOSE;
 80049f0:	2304      	movs	r3, #4
      msg->conn->current_msg = msg;
 80049f2:	6244      	str	r4, [r0, #36]	; 0x24
      msg->conn->state = NETCONN_CLOSE;
 80049f4:	7043      	strb	r3, [r0, #1]
}
 80049f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      lwip_netconn_do_close_internal(msg->conn);
 80049fa:	f7ff bbcd 	b.w	8004198 <lwip_netconn_do_close_internal>

080049fe <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
 80049fe:	b510      	push	{r4, lr}
  if (buf != NULL) {
 8004a00:	4604      	mov	r4, r0
 8004a02:	b160      	cbz	r0, 8004a1e <netbuf_delete+0x20>
    if (buf->p != NULL) {
 8004a04:	6800      	ldr	r0, [r0, #0]
 8004a06:	b120      	cbz	r0, 8004a12 <netbuf_delete+0x14>
      pbuf_free(buf->p);
 8004a08:	f001 f8f5 	bl	8005bf6 <pbuf_free>
      buf->p = buf->ptr = NULL;
 8004a0c:	2300      	movs	r3, #0
 8004a0e:	6063      	str	r3, [r4, #4]
 8004a10:	6023      	str	r3, [r4, #0]
    }
    memp_free(MEMP_NETBUF, buf);
 8004a12:	4621      	mov	r1, r4
 8004a14:	2006      	movs	r0, #6
  }
}
 8004a16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    memp_free(MEMP_NETBUF, buf);
 8004a1a:	f000 bfd1 	b.w	80059c0 <memp_free>
 8004a1e:	bd10      	pop	{r4, pc}

08004a20 <netbuf_data>:
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
 8004a20:	b150      	cbz	r0, 8004a38 <netbuf_data+0x18>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 8004a22:	b149      	cbz	r1, 8004a38 <netbuf_data+0x18>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
 8004a24:	b142      	cbz	r2, 8004a38 <netbuf_data+0x18>

  if (buf->ptr == NULL) {
 8004a26:	6843      	ldr	r3, [r0, #4]
 8004a28:	b14b      	cbz	r3, 8004a3e <netbuf_data+0x1e>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
 8004a2a:	685b      	ldr	r3, [r3, #4]
 8004a2c:	600b      	str	r3, [r1, #0]
  *len = buf->ptr->len;
 8004a2e:	6843      	ldr	r3, [r0, #4]
  return ERR_OK;
 8004a30:	2000      	movs	r0, #0
  *len = buf->ptr->len;
 8004a32:	895b      	ldrh	r3, [r3, #10]
 8004a34:	8013      	strh	r3, [r2, #0]
  return ERR_OK;
 8004a36:	4770      	bx	lr
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
 8004a38:	f06f 000e 	mvn.w	r0, #14
 8004a3c:	4770      	bx	lr
    return ERR_BUF;
 8004a3e:	f06f 0001 	mvn.w	r0, #1
}
 8004a42:	4770      	bx	lr

08004a44 <netbuf_next>:
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
 8004a44:	b140      	cbz	r0, 8004a58 <netbuf_next+0x14>
  if (buf->ptr->next == NULL) {
 8004a46:	6843      	ldr	r3, [r0, #4]
 8004a48:	681b      	ldr	r3, [r3, #0]
 8004a4a:	b12b      	cbz	r3, 8004a58 <netbuf_next+0x14>
    return -1;
  }
  buf->ptr = buf->ptr->next;
 8004a4c:	6043      	str	r3, [r0, #4]
  if (buf->ptr->next == NULL) {
 8004a4e:	6818      	ldr	r0, [r3, #0]
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
 8004a50:	fab0 f080 	clz	r0, r0
 8004a54:	0940      	lsrs	r0, r0, #5
 8004a56:	4770      	bx	lr
 8004a58:	f04f 30ff 	mov.w	r0, #4294967295
    return 1;
  }
  return 0;
}
 8004a5c:	4770      	bx	lr
	...

08004a60 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
 8004a60:	b507      	push	{r0, r1, r2, lr}
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

  if (tcpip_init_done != NULL) {
 8004a62:	4a1a      	ldr	r2, [pc, #104]	; (8004acc <tcpip_thread+0x6c>)
 8004a64:	6813      	ldr	r3, [r2, #0]
 8004a66:	b10b      	cbz	r3, 8004a6c <tcpip_thread+0xc>
    tcpip_init_done(tcpip_init_done_arg);
 8004a68:	6850      	ldr	r0, [r2, #4]
 8004a6a:	4798      	blx	r3
  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    UNLOCK_TCPIP_CORE();
    LWIP_TCPIP_THREAD_ALIVE();
    /* wait for a message, timeouts are processed while waiting */
    sys_timeouts_mbox_fetch(&mbox, (void **)&msg);
 8004a6c:	4c18      	ldr	r4, [pc, #96]	; (8004ad0 <tcpip_thread+0x70>)
 8004a6e:	a901      	add	r1, sp, #4
 8004a70:	4620      	mov	r0, r4
 8004a72:	f000 fe13 	bl	800569c <sys_timeouts_mbox_fetch>
    LOCK_TCPIP_CORE();
    if (msg == NULL) {
 8004a76:	9b01      	ldr	r3, [sp, #4]
 8004a78:	2b00      	cmp	r3, #0
 8004a7a:	d0f8      	beq.n	8004a6e <tcpip_thread+0xe>
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: NULL\n"));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
      continue;
    }
    switch (msg->type) {
 8004a7c:	781a      	ldrb	r2, [r3, #0]
 8004a7e:	2a03      	cmp	r2, #3
 8004a80:	d8f5      	bhi.n	8004a6e <tcpip_thread+0xe>
 8004a82:	e8df f002 	tbb	[pc, r2]
 8004a86:	0702      	.short	0x0702
 8004a88:	1e18      	.short	0x1e18
#if LWIP_NETCONN || LWIP_SOCKET
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
 8004a8a:	6898      	ldr	r0, [r3, #8]
 8004a8c:	6803      	ldr	r3, [r0, #0]
 8004a8e:	3004      	adds	r0, #4
 8004a90:	4798      	blx	r3
      break;
 8004a92:	e7ec      	b.n	8004a6e <tcpip_thread+0xe>

#if !LWIP_TCPIP_CORE_LOCKING_INPUT
    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ETHERNET
      if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
 8004a94:	68d9      	ldr	r1, [r3, #12]
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
 8004a96:	6898      	ldr	r0, [r3, #8]
      if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
 8004a98:	f891 202b 	ldrb.w	r2, [r1, #43]	; 0x2b
 8004a9c:	f012 0f18 	tst.w	r2, #24
 8004aa0:	d006      	beq.n	8004ab0 <tcpip_thread+0x50>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
 8004aa2:	f004 f9cf 	bl	8008e44 <ethernet_input>
      } else
#endif /* LWIP_ETHERNET */
      ip_input(msg->msg.inp.p, msg->msg.inp.netif);
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 8004aa6:	9901      	ldr	r1, [sp, #4]
 8004aa8:	2009      	movs	r0, #9
#endif /* LWIP_TCPIP_TIMEOUT */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
      memp_free(MEMP_TCPIP_MSG_API, msg);
 8004aaa:	f000 ff89 	bl	80059c0 <memp_free>
      break;
 8004aae:	e7de      	b.n	8004a6e <tcpip_thread+0xe>
      ip_input(msg->msg.inp.p, msg->msg.inp.netif);
 8004ab0:	f000 fa44 	bl	8004f3c <ip_input>
 8004ab4:	e7f7      	b.n	8004aa6 <tcpip_thread+0x46>
      msg->msg.cb.function(msg->msg.cb.ctx);
 8004ab6:	68d8      	ldr	r0, [r3, #12]
 8004ab8:	689a      	ldr	r2, [r3, #8]
 8004aba:	4790      	blx	r2
      memp_free(MEMP_TCPIP_MSG_API, msg);
 8004abc:	9901      	ldr	r1, [sp, #4]
 8004abe:	2008      	movs	r0, #8
 8004ac0:	e7f3      	b.n	8004aaa <tcpip_thread+0x4a>

    case TCPIP_MSG_CALLBACK_STATIC:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK_STATIC %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
 8004ac2:	689a      	ldr	r2, [r3, #8]
 8004ac4:	68d8      	ldr	r0, [r3, #12]
 8004ac6:	4790      	blx	r2
      break;
 8004ac8:	e7d1      	b.n	8004a6e <tcpip_thread+0xe>
 8004aca:	bf00      	nop
 8004acc:	20003dac 	.word	0x20003dac
 8004ad0:	20003db4 	.word	0x20003db4

08004ad4 <tcpip_input>:
 *          NETIF_FLAG_ETHERNET flags)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
 8004ad4:	b570      	push	{r4, r5, r6, lr}
 8004ad6:	4606      	mov	r6, r0
  UNLOCK_TCPIP_CORE();
  return ret;
#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
  struct tcpip_msg *msg;

  if (!sys_mbox_valid_val(mbox)) {
 8004ad8:	480e      	ldr	r0, [pc, #56]	; (8004b14 <tcpip_input+0x40>)
{
 8004ada:	460d      	mov	r5, r1
  if (!sys_mbox_valid_val(mbox)) {
 8004adc:	f004 faf8 	bl	80090d0 <sys_mbox_valid>
 8004ae0:	b1a0      	cbz	r0, 8004b0c <tcpip_input+0x38>
    return ERR_VAL;
  }
  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
 8004ae2:	2009      	movs	r0, #9
 8004ae4:	f000 ff60 	bl	80059a8 <memp_malloc>
  if (msg == NULL) {
 8004ae8:	4604      	mov	r4, r0
 8004aea:	b160      	cbz	r0, 8004b06 <tcpip_input+0x32>
    return ERR_MEM;
  }

  msg->type = TCPIP_MSG_INPKT;
 8004aec:	2301      	movs	r3, #1
  msg->msg.inp.p = p;
 8004aee:	6086      	str	r6, [r0, #8]
  msg->msg.inp.netif = inp;
 8004af0:	60c5      	str	r5, [r0, #12]
  if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
 8004af2:	4601      	mov	r1, r0
  msg->type = TCPIP_MSG_INPKT;
 8004af4:	7003      	strb	r3, [r0, #0]
  if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
 8004af6:	4807      	ldr	r0, [pc, #28]	; (8004b14 <tcpip_input+0x40>)
 8004af8:	f004 faa3 	bl	8009042 <sys_mbox_trypost>
 8004afc:	b128      	cbz	r0, 8004b0a <tcpip_input+0x36>
    memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 8004afe:	4621      	mov	r1, r4
 8004b00:	2009      	movs	r0, #9
 8004b02:	f000 ff5d 	bl	80059c0 <memp_free>
    return ERR_MEM;
 8004b06:	f04f 30ff 	mov.w	r0, #4294967295
    return ERR_MEM;
  }
  return ERR_OK;
#endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
}
 8004b0a:	bd70      	pop	{r4, r5, r6, pc}
    return ERR_VAL;
 8004b0c:	f06f 0005 	mvn.w	r0, #5
 8004b10:	bd70      	pop	{r4, r5, r6, pc}
 8004b12:	bf00      	nop
 8004b14:	20003db4 	.word	0x20003db4

08004b18 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)
{
 8004b18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004b1a:	4607      	mov	r7, r0
  struct tcpip_msg *msg;

  if (sys_mbox_valid_val(mbox)) {
 8004b1c:	4811      	ldr	r0, [pc, #68]	; (8004b64 <tcpip_callback_with_block+0x4c>)
{
 8004b1e:	460e      	mov	r6, r1
 8004b20:	4615      	mov	r5, r2
  if (sys_mbox_valid_val(mbox)) {
 8004b22:	f004 fad5 	bl	80090d0 <sys_mbox_valid>
 8004b26:	b1c8      	cbz	r0, 8004b5c <tcpip_callback_with_block+0x44>
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 8004b28:	2008      	movs	r0, #8
 8004b2a:	f000 ff3d 	bl	80059a8 <memp_malloc>
    if (msg == NULL) {
 8004b2e:	4604      	mov	r4, r0
 8004b30:	b188      	cbz	r0, 8004b56 <tcpip_callback_with_block+0x3e>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
 8004b32:	2302      	movs	r3, #2
    msg->msg.cb.function = function;
 8004b34:	6087      	str	r7, [r0, #8]
    msg->msg.cb.ctx = ctx;
 8004b36:	60c6      	str	r6, [r0, #12]
    if (block) {
      sys_mbox_post(&mbox, msg);
 8004b38:	4601      	mov	r1, r0
    msg->type = TCPIP_MSG_CALLBACK;
 8004b3a:	7003      	strb	r3, [r0, #0]
      sys_mbox_post(&mbox, msg);
 8004b3c:	4809      	ldr	r0, [pc, #36]	; (8004b64 <tcpip_callback_with_block+0x4c>)
    if (block) {
 8004b3e:	b11d      	cbz	r5, 8004b48 <tcpip_callback_with_block+0x30>
      sys_mbox_post(&mbox, msg);
 8004b40:	f004 fa6f 	bl	8009022 <sys_mbox_post>
      if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
 8004b44:	2000      	movs	r0, #0
 8004b46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
 8004b48:	f004 fa7b 	bl	8009042 <sys_mbox_trypost>
 8004b4c:	b128      	cbz	r0, 8004b5a <tcpip_callback_with_block+0x42>
        memp_free(MEMP_TCPIP_MSG_API, msg);
 8004b4e:	4621      	mov	r1, r4
 8004b50:	2008      	movs	r0, #8
 8004b52:	f000 ff35 	bl	80059c0 <memp_free>
      return ERR_MEM;
 8004b56:	f04f 30ff 	mov.w	r0, #4294967295
  }
  return ERR_VAL;
}
 8004b5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return ERR_VAL;
 8004b5c:	f06f 0005 	mvn.w	r0, #5
 8004b60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004b62:	bf00      	nop
 8004b64:	20003db4 	.word	0x20003db4

08004b68 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
 8004b68:	b530      	push	{r4, r5, lr}
 8004b6a:	4604      	mov	r4, r0
 8004b6c:	b085      	sub	sp, #20
#ifdef LWIP_DEBUG
  /* catch functions that don't set err */
  apimsg->msg.err = ERR_VAL;
#endif

  if (sys_mbox_valid_val(mbox)) {
 8004b6e:	480c      	ldr	r0, [pc, #48]	; (8004ba0 <tcpip_apimsg+0x38>)
 8004b70:	f004 faae 	bl	80090d0 <sys_mbox_valid>
 8004b74:	b180      	cbz	r0, 8004b98 <tcpip_apimsg+0x30>
    TCPIP_MSG_VAR_ALLOC(msg);
    TCPIP_MSG_VAR_REF(msg).type = TCPIP_MSG_API;
 8004b76:	2500      	movs	r5, #0
#if LWIP_NETCONN_SEM_PER_THREAD
    apimsg->msg.op_completed_sem = LWIP_NETCONN_THREAD_SEM_GET();
    LWIP_ASSERT("netconn semaphore not initialized",
      sys_sem_valid(apimsg->msg.op_completed_sem));
#endif
    sys_mbox_post(&mbox, &TCPIP_MSG_VAR_REF(msg));
 8004b78:	4669      	mov	r1, sp
 8004b7a:	4809      	ldr	r0, [pc, #36]	; (8004ba0 <tcpip_apimsg+0x38>)
    TCPIP_MSG_VAR_REF(msg).type = TCPIP_MSG_API;
 8004b7c:	f88d 5000 	strb.w	r5, [sp]
    TCPIP_MSG_VAR_REF(msg).msg.apimsg = apimsg;
 8004b80:	9402      	str	r4, [sp, #8]
    sys_mbox_post(&mbox, &TCPIP_MSG_VAR_REF(msg));
 8004b82:	f004 fa4e 	bl	8009022 <sys_mbox_post>
    sys_arch_sem_wait(LWIP_API_MSG_SEM(&apimsg->msg), 0);
 8004b86:	6860      	ldr	r0, [r4, #4]
 8004b88:	4629      	mov	r1, r5
 8004b8a:	300c      	adds	r0, #12
 8004b8c:	f004 fac4 	bl	8009118 <sys_arch_sem_wait>
    TCPIP_MSG_VAR_FREE(msg);
    return apimsg->msg.err;
 8004b90:	f994 0008 	ldrsb.w	r0, [r4, #8]
  }
  return ERR_VAL;
}
 8004b94:	b005      	add	sp, #20
 8004b96:	bd30      	pop	{r4, r5, pc}
  return ERR_VAL;
 8004b98:	f06f 0005 	mvn.w	r0, #5
 8004b9c:	e7fa      	b.n	8004b94 <tcpip_apimsg+0x2c>
 8004b9e:	bf00      	nop
 8004ba0:	20003db4 	.word	0x20003db4

08004ba4 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
 8004ba4:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8004ba6:	4605      	mov	r5, r0
 8004ba8:	460c      	mov	r4, r1
  lwip_init();
 8004baa:	f000 f823 	bl	8004bf4 <lwip_init>

  tcpip_init_done = initfunc;
 8004bae:	4809      	ldr	r0, [pc, #36]	; (8004bd4 <tcpip_init+0x30>)
  tcpip_init_done_arg = arg;
  if (sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
 8004bb0:	2100      	movs	r1, #0
  tcpip_init_done = initfunc;
 8004bb2:	6005      	str	r5, [r0, #0]
  if (sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
 8004bb4:	3008      	adds	r0, #8
  tcpip_init_done_arg = arg;
 8004bb6:	f840 4c04 	str.w	r4, [r0, #-4]
  if (sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
 8004bba:	f004 fa1b 	bl	8008ff4 <sys_mbox_new>
  if (sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
    LWIP_ASSERT("failed to create lock_tcpip_core", 0);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
 8004bbe:	2303      	movs	r3, #3
 8004bc0:	2200      	movs	r2, #0
 8004bc2:	4905      	ldr	r1, [pc, #20]	; (8004bd8 <tcpip_init+0x34>)
 8004bc4:	9300      	str	r3, [sp, #0]
 8004bc6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004bca:	4804      	ldr	r0, [pc, #16]	; (8004bdc <tcpip_init+0x38>)
 8004bcc:	f004 faee 	bl	80091ac <sys_thread_new>
}
 8004bd0:	b003      	add	sp, #12
 8004bd2:	bd30      	pop	{r4, r5, pc}
 8004bd4:	20003dac 	.word	0x20003dac
 8004bd8:	08004a61 	.word	0x08004a61
 8004bdc:	08009d99 	.word	0x08009d99

08004be0 <lwip_htons>:
 8004be0:	ba40      	rev16	r0, r0
 8004be2:	b280      	uxth	r0, r0
 8004be4:	4770      	bx	lr

08004be6 <lwip_ntohs>:
 * @return n in host byte order
 */
u16_t
lwip_ntohs(u16_t n)
{
  return lwip_htons(n);
 8004be6:	ba40      	rev16	r0, r0
}
 8004be8:	b280      	uxth	r0, r0
 8004bea:	4770      	bx	lr

08004bec <lwip_htonl>:
{
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
 8004bec:	ba00      	rev	r0, r0
 8004bee:	4770      	bx	lr

08004bf0 <lwip_ntohl>:
 * @return n in host byte order
 */
u32_t
lwip_ntohl(u32_t n)
{
  return lwip_htonl(n);
 8004bf0:	f7ff bffc 	b.w	8004bec <lwip_htonl>

08004bf4 <lwip_init>:
/**
 * Initialize all modules.
 */
void
lwip_init(void)
{
 8004bf4:	b508      	push	{r3, lr}
  /* Modules initialization */
  stats_init();
#if !NO_SYS
  sys_init();
 8004bf6:	f004 fab7 	bl	8009168 <sys_init>
#endif /* !NO_SYS */
  mem_init();
 8004bfa:	f000 fd81 	bl	8005700 <mem_init>
  memp_init();
 8004bfe:	f000 febf 	bl	8005980 <memp_init>
  pbuf_init();
  netif_init();
 8004c02:	f000 fef2 	bl	80059ea <netif_init>
#endif /* LWIP_IPV4 */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
 8004c06:	f003 fcfd 	bl	8008604 <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
 8004c0a:	f001 f997 	bl	8005f3c <tcp_init>
#endif

#if LWIP_TIMERS
  sys_timeouts_init();
#endif /* LWIP_TIMERS */
}
 8004c0e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  sys_timeouts_init();
 8004c12:	f000 bd13 	b.w	800563c <sys_timeouts_init>

08004c16 <icmp_send_response.isra.0>:
 *          p->payload pointing to the IP header
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
 8004c16:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004c18:	4604      	mov	r4, r0
 8004c1a:	b087      	sub	sp, #28
 8004c1c:	460f      	mov	r7, r1
 8004c1e:	4616      	mov	r6, r2

  /* increase number of messages attempted to send */
  MIB2_STATS_INC(mib2.icmpoutmsgs);

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 8004c20:	2124      	movs	r1, #36	; 0x24
 8004c22:	2200      	movs	r2, #0
 8004c24:	2001      	movs	r0, #1
 8004c26:	f001 f80d 	bl	8005c44 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
 8004c2a:	4605      	mov	r5, r0
 8004c2c:	b350      	cbz	r0, 8004c84 <icmp_send_response.isra.0+0x6e>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 8004c2e:	6822      	ldr	r2, [r4, #0]
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  icmphdr->type = type;
  icmphdr->code = code;
  icmphdr->id = 0;
 8004c30:	2300      	movs	r3, #0
  icmphdr = (struct icmp_echo_hdr *)q->payload;
 8004c32:	6844      	ldr	r4, [r0, #4]
  icmphdr->seqno = 0;

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8004c34:	f102 001c 	add.w	r0, r2, #28
  icmphdr->id = 0;
 8004c38:	7123      	strb	r3, [r4, #4]
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8004c3a:	f104 0108 	add.w	r1, r4, #8
  icmphdr->id = 0;
 8004c3e:	7163      	strb	r3, [r4, #5]
  icmphdr->seqno = 0;
 8004c40:	71a3      	strb	r3, [r4, #6]
 8004c42:	71e3      	strb	r3, [r4, #7]
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8004c44:	4613      	mov	r3, r2
  icmphdr->type = type;
 8004c46:	7027      	strb	r7, [r4, #0]
  icmphdr->code = code;
 8004c48:	7066      	strb	r6, [r4, #1]
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8004c4a:	f853 6b04 	ldr.w	r6, [r3], #4
 8004c4e:	4283      	cmp	r3, r0
 8004c50:	f841 6b04 	str.w	r6, [r1], #4
 8004c54:	d1f9      	bne.n	8004c4a <icmp_send_response.isra.0+0x34>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  ip4_addr_copy(iphdr_src, iphdr->src);
 8004c56:	ae06      	add	r6, sp, #24
 8004c58:	68d3      	ldr	r3, [r2, #12]
 8004c5a:	f846 3d04 	str.w	r3, [r6, #-4]!
  netif = ip4_route(&iphdr_src);
 8004c5e:	4630      	mov	r0, r6
 8004c60:	f000 f894 	bl	8004d8c <ip4_route>
  if (netif != NULL) {
 8004c64:	b158      	cbz	r0, 8004c7e <icmp_send_response.isra.0+0x68>
    /* calculate checksum */
    icmphdr->chksum = 0;
 8004c66:	2100      	movs	r1, #0
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP) {
      icmphdr->chksum = inet_chksum(icmphdr, q->len);
    }
#endif
    ICMP_STATS_INC(icmp.xmit);
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
 8004c68:	2301      	movs	r3, #1
 8004c6a:	4632      	mov	r2, r6
    icmphdr->chksum = 0;
 8004c6c:	70a1      	strb	r1, [r4, #2]
 8004c6e:	70e1      	strb	r1, [r4, #3]
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
 8004c70:	9002      	str	r0, [sp, #8]
 8004c72:	4628      	mov	r0, r5
 8004c74:	e88d 000a 	stmia.w	sp, {r1, r3}
 8004c78:	23ff      	movs	r3, #255	; 0xff
 8004c7a:	f000 f9bd 	bl	8004ff8 <ip4_output_if>
  }
  pbuf_free(q);
 8004c7e:	4628      	mov	r0, r5
 8004c80:	f000 ffb9 	bl	8005bf6 <pbuf_free>
}
 8004c84:	b007      	add	sp, #28
 8004c86:	bdf0      	pop	{r4, r5, r6, r7, pc}

08004c88 <icmp_input>:
  if (p->len < sizeof(u16_t)*2) {
 8004c88:	8943      	ldrh	r3, [r0, #10]
 8004c8a:	2b03      	cmp	r3, #3
{
 8004c8c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004c90:	4604      	mov	r4, r0
 8004c92:	b085      	sub	sp, #20
 8004c94:	4688      	mov	r8, r1
  if (p->len < sizeof(u16_t)*2) {
 8004c96:	d935      	bls.n	8004d04 <icmp_input+0x7c>
  type = *((u8_t *)p->payload);
 8004c98:	6843      	ldr	r3, [r0, #4]
  switch (type) {
 8004c9a:	781b      	ldrb	r3, [r3, #0]
 8004c9c:	2b08      	cmp	r3, #8
 8004c9e:	d131      	bne.n	8004d04 <icmp_input+0x7c>
    if (ip_addr_ismulticast(ip_current_dest_addr())) {
 8004ca0:	4b33      	ldr	r3, [pc, #204]	; (8004d70 <icmp_input+0xe8>)
 8004ca2:	6958      	ldr	r0, [r3, #20]
 8004ca4:	461f      	mov	r7, r3
 8004ca6:	f000 02f0 	and.w	r2, r0, #240	; 0xf0
 8004caa:	2ae0      	cmp	r2, #224	; 0xe0
 8004cac:	d02a      	beq.n	8004d04 <icmp_input+0x7c>
  iphdr_in = ip4_current_header();
 8004cae:	f8d3 9008 	ldr.w	r9, [r3, #8]
    if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif())) {
 8004cb2:	6819      	ldr	r1, [r3, #0]
  hlen = IPH_HL(iphdr_in) * 4;
 8004cb4:	f899 5000 	ldrb.w	r5, [r9]
    if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif())) {
 8004cb8:	f000 f9af 	bl	800501a <ip4_addr_isbroadcast_u32>
 8004cbc:	4606      	mov	r6, r0
 8004cbe:	bb08      	cbnz	r0, 8004d04 <icmp_input+0x7c>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 8004cc0:	8923      	ldrh	r3, [r4, #8]
 8004cc2:	2b07      	cmp	r3, #7
 8004cc4:	d91e      	bls.n	8004d04 <icmp_input+0x7c>
  hlen = IPH_HL(iphdr_in) * 4;
 8004cc6:	f005 050f 	and.w	r5, r5, #15
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN))) {
 8004cca:	2122      	movs	r1, #34	; 0x22
 8004ccc:	4620      	mov	r0, r4
  hlen = IPH_HL(iphdr_in) * 4;
 8004cce:	00ad      	lsls	r5, r5, #2
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN))) {
 8004cd0:	f000 ff83 	bl	8005bda <pbuf_header>
 8004cd4:	2800      	cmp	r0, #0
 8004cd6:	d043      	beq.n	8004d60 <icmp_input+0xd8>
      r = pbuf_alloc(PBUF_LINK, p->tot_len + hlen, PBUF_RAM);
 8004cd8:	8921      	ldrh	r1, [r4, #8]
 8004cda:	4632      	mov	r2, r6
 8004cdc:	2002      	movs	r0, #2
 8004cde:	4429      	add	r1, r5
 8004ce0:	b289      	uxth	r1, r1
 8004ce2:	f000 ffaf 	bl	8005c44 <pbuf_alloc>
      if (r == NULL) {
 8004ce6:	4606      	mov	r6, r0
 8004ce8:	b160      	cbz	r0, 8004d04 <icmp_input+0x7c>
      MEMCPY(r->payload, iphdr_in, hlen);
 8004cea:	4649      	mov	r1, r9
 8004cec:	462a      	mov	r2, r5
 8004cee:	6840      	ldr	r0, [r0, #4]
 8004cf0:	f004 ff87 	bl	8009c02 <memcpy>
      if (pbuf_header(r, -hlen)) {
 8004cf4:	4269      	negs	r1, r5
 8004cf6:	4630      	mov	r0, r6
 8004cf8:	f000 ff6f 	bl	8005bda <pbuf_header>
 8004cfc:	b140      	cbz	r0, 8004d10 <icmp_input+0x88>
        pbuf_free(r);
 8004cfe:	4630      	mov	r0, r6
 8004d00:	f000 ff79 	bl	8005bf6 <pbuf_free>
  pbuf_free(p);
 8004d04:	4620      	mov	r0, r4
}
 8004d06:	b005      	add	sp, #20
 8004d08:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  pbuf_free(p);
 8004d0c:	f000 bf73 	b.w	8005bf6 <pbuf_free>
      if (pbuf_copy(r, p) != ERR_OK) {
 8004d10:	4621      	mov	r1, r4
 8004d12:	4630      	mov	r0, r6
 8004d14:	f001 f86a 	bl	8005dec <pbuf_copy>
 8004d18:	2800      	cmp	r0, #0
 8004d1a:	d1f0      	bne.n	8004cfe <icmp_input+0x76>
      pbuf_free(p);
 8004d1c:	4620      	mov	r0, r4
 8004d1e:	4634      	mov	r4, r6
 8004d20:	f000 ff69 	bl	8005bf6 <pbuf_free>
    if (pbuf_header(p, hlen)) {
 8004d24:	4629      	mov	r1, r5
 8004d26:	4620      	mov	r0, r4
    iecho = (struct icmp_echo_hdr *)p->payload;
 8004d28:	6866      	ldr	r6, [r4, #4]
    if (pbuf_header(p, hlen)) {
 8004d2a:	f000 ff56 	bl	8005bda <pbuf_header>
 8004d2e:	4602      	mov	r2, r0
 8004d30:	2800      	cmp	r0, #0
 8004d32:	d1e7      	bne.n	8004d04 <icmp_input+0x7c>
      struct ip_hdr *iphdr = (struct ip_hdr*)p->payload;
 8004d34:	6861      	ldr	r1, [r4, #4]
      ip4_addr_copy(iphdr->src, *src);
 8004d36:	697b      	ldr	r3, [r7, #20]
 8004d38:	60cb      	str	r3, [r1, #12]
      ip4_addr_copy(iphdr->dest, *ip4_current_src_addr());
 8004d3a:	693b      	ldr	r3, [r7, #16]
 8004d3c:	610b      	str	r3, [r1, #16]
      IPH_TTL_SET(iphdr, ICMP_TTL);
 8004d3e:	23ff      	movs	r3, #255	; 0xff
      ICMPH_TYPE_SET(iecho, ICMP_ER);
 8004d40:	7030      	strb	r0, [r6, #0]
      iecho->chksum = 0;
 8004d42:	70b0      	strb	r0, [r6, #2]
 8004d44:	70f0      	strb	r0, [r6, #3]
      IPH_TTL_SET(iphdr, ICMP_TTL);
 8004d46:	720b      	strb	r3, [r1, #8]
      IPH_CHKSUM_SET(iphdr, 0);
 8004d48:	7288      	strb	r0, [r1, #10]
 8004d4a:	72c8      	strb	r0, [r1, #11]
      ret = ip4_output_if(p, src, IP_HDRINCL,
 8004d4c:	2101      	movs	r1, #1
 8004d4e:	9000      	str	r0, [sp, #0]
 8004d50:	4620      	mov	r0, r4
 8004d52:	9101      	str	r1, [sp, #4]
 8004d54:	f8cd 8008 	str.w	r8, [sp, #8]
 8004d58:	4906      	ldr	r1, [pc, #24]	; (8004d74 <icmp_input+0xec>)
 8004d5a:	f000 f94d 	bl	8004ff8 <ip4_output_if>
 8004d5e:	e7d1      	b.n	8004d04 <icmp_input+0x7c>
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN))) {
 8004d60:	f06f 0121 	mvn.w	r1, #33	; 0x21
 8004d64:	4620      	mov	r0, r4
 8004d66:	f000 ff38 	bl	8005bda <pbuf_header>
 8004d6a:	2800      	cmp	r0, #0
 8004d6c:	d1ca      	bne.n	8004d04 <icmp_input+0x7c>
 8004d6e:	e7d9      	b.n	8004d24 <icmp_input+0x9c>
 8004d70:	20003f8c 	.word	0x20003f8c
 8004d74:	20003fa0 	.word	0x20003fa0

08004d78 <icmp_dest_unreach>:
  icmp_send_response(p, ICMP_DUR, t);
 8004d78:	460a      	mov	r2, r1
 8004d7a:	3004      	adds	r0, #4
 8004d7c:	2103      	movs	r1, #3
 8004d7e:	f7ff bf4a 	b.w	8004c16 <icmp_send_response.isra.0>

08004d82 <icmp_time_exceeded>:
  icmp_send_response(p, ICMP_TE, t);
 8004d82:	460a      	mov	r2, r1
 8004d84:	3004      	adds	r0, #4
 8004d86:	210b      	movs	r1, #11
 8004d88:	f7ff bf45 	b.w	8004c16 <icmp_send_response.isra.0>

08004d8c <ip4_route>:
    return ip4_default_multicast_netif;
  }
#endif /* LWIP_MULTICAST_TX_OPTIONS */

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 8004d8c:	4b13      	ldr	r3, [pc, #76]	; (8004ddc <ip4_route+0x50>)
{
 8004d8e:	b530      	push	{r4, r5, lr}
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 8004d90:	681b      	ldr	r3, [r3, #0]
 8004d92:	b96b      	cbnz	r3, 8004db0 <ip4_route+0x24>
    }
    return NULL;
  }
#endif /* LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF */

  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 8004d94:	4a12      	ldr	r2, [pc, #72]	; (8004de0 <ip4_route+0x54>)
 8004d96:	6812      	ldr	r2, [r2, #0]
 8004d98:	b1ea      	cbz	r2, 8004dd6 <ip4_route+0x4a>
 8004d9a:	f892 102b 	ldrb.w	r1, [r2, #43]	; 0x2b
 8004d9e:	f001 0105 	and.w	r1, r1, #5
 8004da2:	2905      	cmp	r1, #5
 8004da4:	d117      	bne.n	8004dd6 <ip4_route+0x4a>
 8004da6:	6851      	ldr	r1, [r2, #4]
 8004da8:	2900      	cmp	r1, #0
 8004daa:	bf18      	it	ne
 8004dac:	4613      	movne	r3, r2
 8004dae:	e012      	b.n	8004dd6 <ip4_route+0x4a>
    if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 8004db0:	f893 402b 	ldrb.w	r4, [r3, #43]	; 0x2b
 8004db4:	f004 0205 	and.w	r2, r4, #5
 8004db8:	2a05      	cmp	r2, #5
 8004dba:	d1e9      	bne.n	8004d90 <ip4_route+0x4>
 8004dbc:	685a      	ldr	r2, [r3, #4]
 8004dbe:	2a00      	cmp	r2, #0
 8004dc0:	d0e6      	beq.n	8004d90 <ip4_route+0x4>
      if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
 8004dc2:	6801      	ldr	r1, [r0, #0]
 8004dc4:	689d      	ldr	r5, [r3, #8]
 8004dc6:	404a      	eors	r2, r1
 8004dc8:	422a      	tst	r2, r5
 8004dca:	d004      	beq.n	8004dd6 <ip4_route+0x4a>
      if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
 8004dcc:	07a2      	lsls	r2, r4, #30
 8004dce:	d4df      	bmi.n	8004d90 <ip4_route+0x4>
 8004dd0:	68da      	ldr	r2, [r3, #12]
 8004dd2:	4291      	cmp	r1, r2
 8004dd4:	d1dc      	bne.n	8004d90 <ip4_route+0x4>
    MIB2_STATS_INC(mib2.ipoutnoroutes);
    return NULL;
  }

  return netif_default;
}
 8004dd6:	4618      	mov	r0, r3
 8004dd8:	bd30      	pop	{r4, r5, pc}
 8004dda:	bf00      	nop
 8004ddc:	20007658 	.word	0x20007658
 8004de0:	2000765c 	.word	0x2000765c

08004de4 <ip4_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip4_input(struct pbuf *p, struct netif *inp)
{
 8004de4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

  IP_STATS_INC(ip.recv);
  MIB2_STATS_INC(mib2.ipinreceives);

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 8004de8:	6847      	ldr	r7, [r0, #4]
{
 8004dea:	4605      	mov	r5, r0
 8004dec:	4689      	mov	r9, r1
  if (IPH_V(iphdr) != 4) {
 8004dee:	f897 8000 	ldrb.w	r8, [r7]
 8004df2:	ea4f 1318 	mov.w	r3, r8, lsr #4
 8004df6:	2b04      	cmp	r3, #4
 8004df8:	d005      	beq.n	8004e06 <ip4_input+0x22>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip4_debug_print(p);
    pbuf_free(p);
 8004dfa:	4628      	mov	r0, r5
 8004dfc:	f000 fefb 	bl	8005bf6 <pbuf_free>
  ip_data.current_ip_header_tot_len = 0;
  ip4_addr_set_any(ip4_current_src_addr());
  ip4_addr_set_any(ip4_current_dest_addr());

  return ERR_OK;
}
 8004e00:	2000      	movs	r0, #0
 8004e02:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  iphdr_len = ntohs(IPH_LEN(iphdr));
 8004e06:	8878      	ldrh	r0, [r7, #2]
  iphdr_hlen = IPH_HL(iphdr);
 8004e08:	f008 080f 	and.w	r8, r8, #15
  iphdr_len = ntohs(IPH_LEN(iphdr));
 8004e0c:	f7ff feeb 	bl	8004be6 <lwip_ntohs>
  if (iphdr_len < p->tot_len) {
 8004e10:	892b      	ldrh	r3, [r5, #8]
  iphdr_hlen *= 4;
 8004e12:	ea4f 0888 	mov.w	r8, r8, lsl #2
  iphdr_len = ntohs(IPH_LEN(iphdr));
 8004e16:	4604      	mov	r4, r0
  if (iphdr_len < p->tot_len) {
 8004e18:	4283      	cmp	r3, r0
 8004e1a:	d903      	bls.n	8004e24 <ip4_input+0x40>
    pbuf_realloc(p, iphdr_len);
 8004e1c:	4601      	mov	r1, r0
 8004e1e:	4628      	mov	r0, r5
 8004e20:	f000 ff98 	bl	8005d54 <pbuf_realloc>
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
 8004e24:	896b      	ldrh	r3, [r5, #10]
 8004e26:	4543      	cmp	r3, r8
 8004e28:	d3e7      	bcc.n	8004dfa <ip4_input+0x16>
 8004e2a:	892b      	ldrh	r3, [r5, #8]
 8004e2c:	42a3      	cmp	r3, r4
 8004e2e:	d3e4      	bcc.n	8004dfa <ip4_input+0x16>
  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
 8004e30:	693b      	ldr	r3, [r7, #16]
  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
 8004e32:	464e      	mov	r6, r9
  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
 8004e34:	4c3f      	ldr	r4, [pc, #252]	; (8004f34 <ip4_input+0x150>)
    int first = 1;
 8004e36:	f04f 0a01 	mov.w	sl, #1
        netif = netif_list;
 8004e3a:	f8df b0fc 	ldr.w	fp, [pc, #252]	; 8004f38 <ip4_input+0x154>
  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
 8004e3e:	6163      	str	r3, [r4, #20]
  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
 8004e40:	68fb      	ldr	r3, [r7, #12]
 8004e42:	6123      	str	r3, [r4, #16]
      if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
 8004e44:	f896 302b 	ldrb.w	r3, [r6, #43]	; 0x2b
 8004e48:	07db      	lsls	r3, r3, #31
 8004e4a:	d404      	bmi.n	8004e56 <ip4_input+0x72>
      if (first) {
 8004e4c:	f1ba 0f00 	cmp.w	sl, #0
 8004e50:	d13d      	bne.n	8004ece <ip4_input+0xea>
        netif = netif->next;
 8004e52:	6836      	ldr	r6, [r6, #0]
 8004e54:	e03d      	b.n	8004ed2 <ip4_input+0xee>
      if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
 8004e56:	6873      	ldr	r3, [r6, #4]
 8004e58:	2b00      	cmp	r3, #0
 8004e5a:	d0f7      	beq.n	8004e4c <ip4_input+0x68>
        if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 8004e5c:	6960      	ldr	r0, [r4, #20]
 8004e5e:	4283      	cmp	r3, r0
 8004e60:	d004      	beq.n	8004e6c <ip4_input+0x88>
            ip_addr_isbroadcast(ip_current_dest_addr(), netif)
 8004e62:	4631      	mov	r1, r6
 8004e64:	f000 f8d9 	bl	800501a <ip4_addr_isbroadcast_u32>
        if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 8004e68:	2800      	cmp	r0, #0
 8004e6a:	d0ef      	beq.n	8004e4c <ip4_input+0x68>
    if ((ip_addr_isbroadcast(ip_current_src_addr(), inp)) ||
 8004e6c:	4649      	mov	r1, r9
 8004e6e:	6920      	ldr	r0, [r4, #16]
 8004e70:	f000 f8d3 	bl	800501a <ip4_addr_isbroadcast_u32>
 8004e74:	2800      	cmp	r0, #0
 8004e76:	d1c0      	bne.n	8004dfa <ip4_input+0x16>
        (ip_addr_ismulticast(ip_current_src_addr()))) {
 8004e78:	6923      	ldr	r3, [r4, #16]
 8004e7a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    if ((ip_addr_isbroadcast(ip_current_src_addr(), inp)) ||
 8004e7e:	2be0      	cmp	r3, #224	; 0xe0
 8004e80:	d0bb      	beq.n	8004dfa <ip4_input+0x16>
  if (netif == NULL) {
 8004e82:	2e00      	cmp	r6, #0
 8004e84:	d0b9      	beq.n	8004dfa <ip4_input+0x16>
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 8004e86:	88fb      	ldrh	r3, [r7, #6]
 8004e88:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8004e8c:	b133      	cbz	r3, 8004e9c <ip4_input+0xb8>
    p = ip4_reass(p);
 8004e8e:	4628      	mov	r0, r5
 8004e90:	f000 f97c 	bl	800518c <ip4_reass>
    if (p == NULL) {
 8004e94:	4605      	mov	r5, r0
 8004e96:	2800      	cmp	r0, #0
 8004e98:	d0b2      	beq.n	8004e00 <ip4_input+0x1c>
    iphdr = (struct ip_hdr *)p->payload;
 8004e9a:	6847      	ldr	r7, [r0, #4]
  ip_data.current_ip4_header = iphdr;
 8004e9c:	60a7      	str	r7, [r4, #8]
    pbuf_header(p, -(s16_t)iphdr_hlen); /* Move to payload, no check necessary. */
 8004e9e:	f1c8 0100 	rsb	r1, r8, #0
 8004ea2:	4628      	mov	r0, r5
  ip_data.current_input_netif = inp;
 8004ea4:	e884 0240 	stmia.w	r4, {r6, r9}
  ip_data.current_ip_header_tot_len = IPH_HL(iphdr) * 4;
 8004ea8:	783b      	ldrb	r3, [r7, #0]
 8004eaa:	f003 030f 	and.w	r3, r3, #15
 8004eae:	009b      	lsls	r3, r3, #2
 8004eb0:	81a3      	strh	r3, [r4, #12]
    pbuf_header(p, -(s16_t)iphdr_hlen); /* Move to payload, no check necessary. */
 8004eb2:	f000 fe92 	bl	8005bda <pbuf_header>
    switch (IPH_PROTO(iphdr)) {
 8004eb6:	7a7b      	ldrb	r3, [r7, #9]
 8004eb8:	2b06      	cmp	r3, #6
 8004eba:	d01e      	beq.n	8004efa <ip4_input+0x116>
 8004ebc:	2b11      	cmp	r3, #17
 8004ebe:	d010      	beq.n	8004ee2 <ip4_input+0xfe>
 8004ec0:	2b01      	cmp	r3, #1
 8004ec2:	d11f      	bne.n	8004f04 <ip4_input+0x120>
      icmp_input(p, inp);
 8004ec4:	4649      	mov	r1, r9
 8004ec6:	4628      	mov	r0, r5
 8004ec8:	f7ff fede 	bl	8004c88 <icmp_input>
      break;
 8004ecc:	e00d      	b.n	8004eea <ip4_input+0x106>
        netif = netif_list;
 8004ece:	f8db 6000 	ldr.w	r6, [fp]
      if (netif == inp) {
 8004ed2:	454e      	cmp	r6, r9
 8004ed4:	f04f 0a00 	mov.w	sl, #0
        netif = netif->next;
 8004ed8:	bf08      	it	eq
 8004eda:	6836      	ldreq	r6, [r6, #0]
    } while (netif != NULL);
 8004edc:	2e00      	cmp	r6, #0
 8004ede:	d1b1      	bne.n	8004e44 <ip4_input+0x60>
 8004ee0:	e7c4      	b.n	8004e6c <ip4_input+0x88>
      udp_input(p, inp);
 8004ee2:	4649      	mov	r1, r9
 8004ee4:	4628      	mov	r0, r5
 8004ee6:	f003 fb8f 	bl	8008608 <udp_input>
  ip_data.current_netif = NULL;
 8004eea:	2300      	movs	r3, #0
 8004eec:	6023      	str	r3, [r4, #0]
  ip_data.current_input_netif = NULL;
 8004eee:	6063      	str	r3, [r4, #4]
  ip_data.current_ip4_header = NULL;
 8004ef0:	60a3      	str	r3, [r4, #8]
  ip_data.current_ip_header_tot_len = 0;
 8004ef2:	81a3      	strh	r3, [r4, #12]
  ip4_addr_set_any(ip4_current_src_addr());
 8004ef4:	6123      	str	r3, [r4, #16]
  ip4_addr_set_any(ip4_current_dest_addr());
 8004ef6:	6163      	str	r3, [r4, #20]
  return ERR_OK;
 8004ef8:	e782      	b.n	8004e00 <ip4_input+0x1c>
      tcp_input(p, inp);
 8004efa:	4649      	mov	r1, r9
 8004efc:	4628      	mov	r0, r5
 8004efe:	f002 fa61 	bl	80073c4 <tcp_input>
      break;
 8004f02:	e7f2      	b.n	8004eea <ip4_input+0x106>
      if (!ip_addr_isbroadcast(ip_current_dest_addr(), netif) &&
 8004f04:	4631      	mov	r1, r6
 8004f06:	6960      	ldr	r0, [r4, #20]
 8004f08:	f000 f887 	bl	800501a <ip4_addr_isbroadcast_u32>
 8004f0c:	b968      	cbnz	r0, 8004f2a <ip4_input+0x146>
          !ip_addr_ismulticast(ip_current_dest_addr())) {
 8004f0e:	6963      	ldr	r3, [r4, #20]
 8004f10:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      if (!ip_addr_isbroadcast(ip_current_dest_addr(), netif) &&
 8004f14:	2be0      	cmp	r3, #224	; 0xe0
 8004f16:	d008      	beq.n	8004f2a <ip4_input+0x146>
        pbuf_header_force(p, iphdr_hlen); /* Move to ip header, no check necessary. */
 8004f18:	4641      	mov	r1, r8
 8004f1a:	4628      	mov	r0, r5
 8004f1c:	f000 fe64 	bl	8005be8 <pbuf_header_force>
        p->payload = iphdr;
 8004f20:	606f      	str	r7, [r5, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
 8004f22:	2102      	movs	r1, #2
 8004f24:	4628      	mov	r0, r5
 8004f26:	f7ff ff27 	bl	8004d78 <icmp_dest_unreach>
      pbuf_free(p);
 8004f2a:	4628      	mov	r0, r5
 8004f2c:	f000 fe63 	bl	8005bf6 <pbuf_free>
 8004f30:	e7db      	b.n	8004eea <ip4_input+0x106>
 8004f32:	bf00      	nop
 8004f34:	20003f8c 	.word	0x20003f8c
 8004f38:	20007658 	.word	0x20007658

08004f3c <ip_input>:
  return ip4_input(p, inp);
 8004f3c:	f7ff bf52 	b.w	8004de4 <ip4_input>

08004f40 <ip4_output_if_src>:
 */
err_t
ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 8004f40:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 8004f44:	9f0c      	ldr	r7, [sp, #48]	; 0x30
 8004f46:	4606      	mov	r6, r0
 8004f48:	4689      	mov	r9, r1
 8004f4a:	469a      	mov	sl, r3
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);

  MIB2_STATS_INC(mib2.ipoutrequests);

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
 8004f4c:	4615      	mov	r5, r2
 8004f4e:	2a00      	cmp	r2, #0
 8004f50:	d03f      	beq.n	8004fd2 <ip4_output_if_src+0x92>
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
 8004f52:	2114      	movs	r1, #20
 8004f54:	f000 fe41 	bl	8005bda <pbuf_header>
 8004f58:	4680      	mov	r8, r0
 8004f5a:	2800      	cmp	r0, #0
 8004f5c:	d145      	bne.n	8004fea <ip4_output_if_src+0xaa>
      IP_STATS_INC(ip.err);
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
 8004f5e:	6874      	ldr	r4, [r6, #4]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
    IPH_PROTO_SET(iphdr, proto);
 8004f60:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    IPH_TTL_SET(iphdr, ttl);
 8004f64:	f884 a008 	strb.w	sl, [r4, #8]
    IPH_PROTO_SET(iphdr, proto);
 8004f68:	7263      	strb	r3, [r4, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip4_addr_copy(iphdr->dest, *dest);
 8004f6a:	682b      	ldr	r3, [r5, #0]
 8004f6c:	6123      	str	r3, [r4, #16]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 8004f6e:	2345      	movs	r3, #69	; 0x45
 8004f70:	7023      	strb	r3, [r4, #0]
    IPH_TOS_SET(iphdr, tos);
 8004f72:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 8004f76:	7063      	strb	r3, [r4, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 8004f78:	8930      	ldrh	r0, [r6, #8]
 8004f7a:	f7ff fe31 	bl	8004be0 <lwip_htons>
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 8004f7e:	f884 8006 	strb.w	r8, [r4, #6]
 8004f82:	f884 8007 	strb.w	r8, [r4, #7]
    IPH_ID_SET(iphdr, htons(ip_id));
 8004f86:	f8df 806c 	ldr.w	r8, [pc, #108]	; 8004ff4 <ip4_output_if_src+0xb4>
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 8004f8a:	8060      	strh	r0, [r4, #2]
    IPH_ID_SET(iphdr, htons(ip_id));
 8004f8c:	f8b8 0000 	ldrh.w	r0, [r8]
 8004f90:	f7ff fe26 	bl	8004be0 <lwip_htons>
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 8004f94:	f8b8 3000 	ldrh.w	r3, [r8]
    IPH_ID_SET(iphdr, htons(ip_id));
 8004f98:	80a0      	strh	r0, [r4, #4]
    ++ip_id;
 8004f9a:	3301      	adds	r3, #1
 8004f9c:	f8a8 3000 	strh.w	r3, [r8]

    if (src == NULL) {
 8004fa0:	f1b9 0f00 	cmp.w	r9, #0
 8004fa4:	d112      	bne.n	8004fcc <ip4_output_if_src+0x8c>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY);
 8004fa6:	4b12      	ldr	r3, [pc, #72]	; (8004ff0 <ip4_output_if_src+0xb0>)
 8004fa8:	681b      	ldr	r3, [r3, #0]
    } else {
      /* src cannot be NULL here */
      ip4_addr_copy(iphdr->src, *src);
 8004faa:	60e3      	str	r3, [r4, #12]
    else {
      IPH_CHKSUM_SET(iphdr, 0);
    }
#endif /* LWIP_CHECKSUM_CTRL_PER_NETIF*/
#else /* CHECKSUM_GEN_IP_INLINE */
    IPH_CHKSUM_SET(iphdr, 0);
 8004fac:	2300      	movs	r3, #0
 8004fae:	72a3      	strb	r3, [r4, #10]
 8004fb0:	72e3      	strb	r3, [r4, #11]
  }
#endif /* LWIP_MULTICAST_TX_OPTIONS */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 8004fb2:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8004fb4:	b19b      	cbz	r3, 8004fde <ip4_output_if_src+0x9e>
 8004fb6:	8932      	ldrh	r2, [r6, #8]
 8004fb8:	429a      	cmp	r2, r3
 8004fba:	d910      	bls.n	8004fde <ip4_output_if_src+0x9e>
    return ip4_frag(p, netif, dest);
 8004fbc:	462a      	mov	r2, r5
 8004fbe:	4639      	mov	r1, r7
 8004fc0:	4630      	mov	r0, r6
 8004fc2:	f000 fa29 	bl	8005418 <ip4_frag>
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
  return netif->output(netif, p, dest);
}
 8004fc6:	b002      	add	sp, #8
 8004fc8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      ip4_addr_copy(iphdr->src, *src);
 8004fcc:	f8d9 3000 	ldr.w	r3, [r9]
 8004fd0:	e7eb      	b.n	8004faa <ip4_output_if_src+0x6a>
    ip4_addr_copy(dest_addr, iphdr->dest);
 8004fd2:	6843      	ldr	r3, [r0, #4]
 8004fd4:	ad02      	add	r5, sp, #8
 8004fd6:	691b      	ldr	r3, [r3, #16]
 8004fd8:	f845 3d04 	str.w	r3, [r5, #-4]!
 8004fdc:	e7e9      	b.n	8004fb2 <ip4_output_if_src+0x72>
  return netif->output(netif, p, dest);
 8004fde:	697b      	ldr	r3, [r7, #20]
 8004fe0:	462a      	mov	r2, r5
 8004fe2:	4631      	mov	r1, r6
 8004fe4:	4638      	mov	r0, r7
 8004fe6:	4798      	blx	r3
 8004fe8:	e7ed      	b.n	8004fc6 <ip4_output_if_src+0x86>
      return ERR_BUF;
 8004fea:	f06f 0001 	mvn.w	r0, #1
 8004fee:	e7ea      	b.n	8004fc6 <ip4_output_if_src+0x86>
 8004ff0:	08009c70 	.word	0x08009c70
 8004ff4:	20003db8 	.word	0x20003db8

08004ff8 <ip4_output_if>:
{
 8004ff8:	b4f0      	push	{r4, r5, r6, r7}
 8004ffa:	9c06      	ldr	r4, [sp, #24]
 8004ffc:	f89d 5010 	ldrb.w	r5, [sp, #16]
 8005000:	f89d 6014 	ldrb.w	r6, [sp, #20]
  if (dest != IP_HDRINCL) {
 8005004:	b11a      	cbz	r2, 800500e <ip4_output_if+0x16>
    if (ip4_addr_isany(src)) {
 8005006:	b109      	cbz	r1, 800500c <ip4_output_if+0x14>
 8005008:	680f      	ldr	r7, [r1, #0]
 800500a:	b907      	cbnz	r7, 800500e <ip4_output_if+0x16>
      src_used = netif_ip4_addr(netif);
 800500c:	1d21      	adds	r1, r4, #4
  return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
 800500e:	9406      	str	r4, [sp, #24]
 8005010:	9605      	str	r6, [sp, #20]
 8005012:	9504      	str	r5, [sp, #16]
}
 8005014:	bcf0      	pop	{r4, r5, r6, r7}
  return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
 8005016:	f7ff bf93 	b.w	8004f40 <ip4_output_if_src>

0800501a <ip4_addr_isbroadcast_u32>:
{
  ip4_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 800501a:	1e43      	subs	r3, r0, #1
 800501c:	3303      	adds	r3, #3
 800501e:	d811      	bhi.n	8005044 <ip4_addr_isbroadcast_u32+0x2a>
      (addr == IPADDR_ANY)) {
    return 1;
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 8005020:	f891 302b 	ldrb.w	r3, [r1, #43]	; 0x2b
 8005024:	f013 0302 	ands.w	r3, r3, #2
 8005028:	d00e      	beq.n	8005048 <ip4_addr_isbroadcast_u32+0x2e>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
 800502a:	684a      	ldr	r2, [r1, #4]
 800502c:	4290      	cmp	r0, r2
 800502e:	d00b      	beq.n	8005048 <ip4_addr_isbroadcast_u32+0x2e>
    return 0;
  /*  on the same (sub) network... */
  } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
 8005030:	688b      	ldr	r3, [r1, #8]
 8005032:	4042      	eors	r2, r0
 8005034:	421a      	tst	r2, r3
 8005036:	d107      	bne.n	8005048 <ip4_addr_isbroadcast_u32+0x2e>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 8005038:	43db      	mvns	r3, r3
 800503a:	4383      	bics	r3, r0
    return 1;
 800503c:	bf0c      	ite	eq
 800503e:	2001      	moveq	r0, #1
 8005040:	2000      	movne	r0, #0
 8005042:	4770      	bx	lr
 8005044:	2001      	movs	r0, #1
 8005046:	4770      	bx	lr
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
    /* => network broadcast address */
    return 1;
  } else {
    return 0;
 8005048:	2000      	movs	r0, #0
  }
}
 800504a:	4770      	bx	lr

0800504c <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
 800504c:	b510      	push	{r4, lr}
 800504e:	4604      	mov	r4, r0
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  if (pcr->original != NULL) {
 8005050:	6940      	ldr	r0, [r0, #20]
 8005052:	b108      	cbz	r0, 8005058 <ipfrag_free_pbuf_custom+0xc>
    pbuf_free(pcr->original);
 8005054:	f000 fdcf 	bl	8005bf6 <pbuf_free>
  memp_free(MEMP_FRAG_PBUF, p);
 8005058:	4621      	mov	r1, r4
 800505a:	2005      	movs	r0, #5
  }
  ip_frag_free_pbuf_custom_ref(pcr);
}
 800505c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  memp_free(MEMP_FRAG_PBUF, p);
 8005060:	f000 bcae 	b.w	80059c0 <memp_free>

08005064 <ip_reass_free_complete_datagram>:
{
 8005064:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 8005068:	6846      	ldr	r6, [r0, #4]
{
 800506a:	4604      	mov	r4, r0
 800506c:	460f      	mov	r7, r1
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 800506e:	6873      	ldr	r3, [r6, #4]
  if (iprh->start == 0) {
 8005070:	889a      	ldrh	r2, [r3, #4]
 8005072:	bb4a      	cbnz	r2, 80050c8 <ip_reass_free_complete_datagram+0x64>
    ipr->p = iprh->next_pbuf;
 8005074:	681a      	ldr	r2, [r3, #0]
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 8005076:	f100 011c 	add.w	r1, r0, #28
    ipr->p = iprh->next_pbuf;
 800507a:	6042      	str	r2, [r0, #4]
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 800507c:	f100 0208 	add.w	r2, r0, #8
 8005080:	f852 0b04 	ldr.w	r0, [r2], #4
 8005084:	428a      	cmp	r2, r1
 8005086:	f843 0b04 	str.w	r0, [r3], #4
 800508a:	d1f9      	bne.n	8005080 <ip_reass_free_complete_datagram+0x1c>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 800508c:	2101      	movs	r1, #1
 800508e:	4630      	mov	r0, r6
 8005090:	f7ff fe77 	bl	8004d82 <icmp_time_exceeded>
    clen = pbuf_clen(p);
 8005094:	4630      	mov	r0, r6
 8005096:	f000 fe86 	bl	8005da6 <pbuf_clen>
    pbufs_freed += clen;
 800509a:	b285      	uxth	r5, r0
    pbuf_free(p);
 800509c:	4630      	mov	r0, r6
 800509e:	f000 fdaa 	bl	8005bf6 <pbuf_free>
  p = ipr->p;
 80050a2:	6866      	ldr	r6, [r4, #4]
  while (p != NULL) {
 80050a4:	b996      	cbnz	r6, 80050cc <ip_reass_free_complete_datagram+0x68>
  if (reassdatagrams == ipr) {
 80050a6:	4e10      	ldr	r6, [pc, #64]	; (80050e8 <ip_reass_free_complete_datagram+0x84>)
  memp_free(MEMP_REASSDATA, ipr);
 80050a8:	4621      	mov	r1, r4
 80050aa:	2004      	movs	r0, #4
  if (reassdatagrams == ipr) {
 80050ac:	6833      	ldr	r3, [r6, #0]
 80050ae:	429c      	cmp	r4, r3
 80050b0:	6823      	ldr	r3, [r4, #0]
    prev->next = ipr->next;
 80050b2:	bf14      	ite	ne
 80050b4:	603b      	strne	r3, [r7, #0]
    reassdatagrams = ipr->next;
 80050b6:	6033      	streq	r3, [r6, #0]
  memp_free(MEMP_REASSDATA, ipr);
 80050b8:	f000 fc82 	bl	80059c0 <memp_free>
  ip_reass_pbufcount -= pbufs_freed;
 80050bc:	88b3      	ldrh	r3, [r6, #4]
}
 80050be:	4628      	mov	r0, r5
  ip_reass_pbufcount -= pbufs_freed;
 80050c0:	1b5b      	subs	r3, r3, r5
 80050c2:	80b3      	strh	r3, [r6, #4]
}
 80050c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  u16_t pbufs_freed = 0;
 80050c8:	2500      	movs	r5, #0
 80050ca:	e7ea      	b.n	80050a2 <ip_reass_free_complete_datagram+0x3e>
    iprh = (struct ip_reass_helper *)p->payload;
 80050cc:	6873      	ldr	r3, [r6, #4]
    clen = pbuf_clen(pcur);
 80050ce:	4630      	mov	r0, r6
    p = iprh->next_pbuf;
 80050d0:	f8d3 8000 	ldr.w	r8, [r3]
    clen = pbuf_clen(pcur);
 80050d4:	f000 fe67 	bl	8005da6 <pbuf_clen>
    pbufs_freed += clen;
 80050d8:	4405      	add	r5, r0
    pbuf_free(pcur);
 80050da:	4630      	mov	r0, r6
 80050dc:	f000 fd8b 	bl	8005bf6 <pbuf_free>
    p = iprh->next_pbuf;
 80050e0:	4646      	mov	r6, r8
    pbufs_freed += clen;
 80050e2:	b2ad      	uxth	r5, r5
 80050e4:	e7de      	b.n	80050a4 <ip_reass_free_complete_datagram+0x40>
 80050e6:	bf00      	nop
 80050e8:	20003dbc 	.word	0x20003dbc

080050ec <ip_reass_remove_oldest_datagram>:
{
 80050ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80050f0:	4606      	mov	r6, r0
 80050f2:	460f      	mov	r7, r1
  int pbufs_freed = 0, pbufs_freed_current;
 80050f4:	2500      	movs	r5, #0
    r = reassdatagrams;
 80050f6:	f8df 8068 	ldr.w	r8, [pc, #104]	; 8005160 <ip_reass_remove_oldest_datagram+0x74>
    other_datagrams = 0;
 80050fa:	2400      	movs	r4, #0
    r = reassdatagrams;
 80050fc:	f8d8 3000 	ldr.w	r3, [r8]
    oldest_prev = NULL;
 8005100:	4621      	mov	r1, r4
    prev = NULL;
 8005102:	46a6      	mov	lr, r4
    oldest = NULL;
 8005104:	4620      	mov	r0, r4
    while (r != NULL) {
 8005106:	b953      	cbnz	r3, 800511e <ip_reass_remove_oldest_datagram+0x32>
    if (oldest != NULL) {
 8005108:	b110      	cbz	r0, 8005110 <ip_reass_remove_oldest_datagram+0x24>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, oldest_prev);
 800510a:	f7ff ffab 	bl	8005064 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
 800510e:	4405      	add	r5, r0
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 8005110:	42bd      	cmp	r5, r7
 8005112:	da01      	bge.n	8005118 <ip_reass_remove_oldest_datagram+0x2c>
 8005114:	2c01      	cmp	r4, #1
 8005116:	dcf0      	bgt.n	80050fa <ip_reass_remove_oldest_datagram+0xe>
}
 8005118:	4628      	mov	r0, r5
 800511a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 800511e:	f8d6 c00c 	ldr.w	ip, [r6, #12]
 8005122:	695a      	ldr	r2, [r3, #20]
 8005124:	4562      	cmp	r2, ip
 8005126:	d109      	bne.n	800513c <ip_reass_remove_oldest_datagram+0x50>
 8005128:	f8d6 c010 	ldr.w	ip, [r6, #16]
 800512c:	699a      	ldr	r2, [r3, #24]
 800512e:	4562      	cmp	r2, ip
 8005130:	d104      	bne.n	800513c <ip_reass_remove_oldest_datagram+0x50>
 8005132:	f8b3 c00c 	ldrh.w	ip, [r3, #12]
 8005136:	88b2      	ldrh	r2, [r6, #4]
 8005138:	4594      	cmp	ip, r2
 800513a:	d008      	beq.n	800514e <ip_reass_remove_oldest_datagram+0x62>
        other_datagrams++;
 800513c:	3401      	adds	r4, #1
        if (oldest == NULL) {
 800513e:	b160      	cbz	r0, 800515a <ip_reass_remove_oldest_datagram+0x6e>
        } else if (r->timer <= oldest->timer) {
 8005140:	7fc2      	ldrb	r2, [r0, #31]
 8005142:	f893 c01f 	ldrb.w	ip, [r3, #31]
          oldest_prev = prev;
 8005146:	4594      	cmp	ip, r2
 8005148:	bf9c      	itt	ls
 800514a:	4671      	movls	r1, lr
 800514c:	4618      	movls	r0, r3
      if (r->next != NULL) {
 800514e:	681a      	ldr	r2, [r3, #0]
 8005150:	2a00      	cmp	r2, #0
 8005152:	bf18      	it	ne
 8005154:	469e      	movne	lr, r3
 8005156:	4613      	mov	r3, r2
 8005158:	e7d5      	b.n	8005106 <ip_reass_remove_oldest_datagram+0x1a>
          oldest_prev = prev;
 800515a:	4671      	mov	r1, lr
 800515c:	4618      	mov	r0, r3
 800515e:	e7f6      	b.n	800514e <ip_reass_remove_oldest_datagram+0x62>
 8005160:	20003dbc 	.word	0x20003dbc

08005164 <ip_reass_tmr>:
{
 8005164:	b538      	push	{r3, r4, r5, lr}
  r = reassdatagrams;
 8005166:	4b08      	ldr	r3, [pc, #32]	; (8005188 <ip_reass_tmr+0x24>)
  struct ip_reassdata *r, *prev = NULL;
 8005168:	2400      	movs	r4, #0
  r = reassdatagrams;
 800516a:	6818      	ldr	r0, [r3, #0]
  while (r != NULL) {
 800516c:	b900      	cbnz	r0, 8005170 <ip_reass_tmr+0xc>
}
 800516e:	bd38      	pop	{r3, r4, r5, pc}
    if (r->timer > 0) {
 8005170:	7fc3      	ldrb	r3, [r0, #31]
 8005172:	6805      	ldr	r5, [r0, #0]
 8005174:	b123      	cbz	r3, 8005180 <ip_reass_tmr+0x1c>
      r->timer--;
 8005176:	3b01      	subs	r3, #1
 8005178:	4604      	mov	r4, r0
 800517a:	77c3      	strb	r3, [r0, #31]
      r = r->next;
 800517c:	4628      	mov	r0, r5
 800517e:	e7f5      	b.n	800516c <ip_reass_tmr+0x8>
      ip_reass_free_complete_datagram(tmp, prev);
 8005180:	4621      	mov	r1, r4
 8005182:	f7ff ff6f 	bl	8005064 <ip_reass_free_complete_datagram>
 8005186:	e7f9      	b.n	800517c <ip_reass_tmr+0x18>
 8005188:	20003dbc 	.word	0x20003dbc

0800518c <ip4_reass>:
{
 800518c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  fraghdr = (struct ip_hdr*)p->payload;
 8005190:	6845      	ldr	r5, [r0, #4]
{
 8005192:	4607      	mov	r7, r0
  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 8005194:	782b      	ldrb	r3, [r5, #0]
 8005196:	f003 030f 	and.w	r3, r3, #15
 800519a:	2b05      	cmp	r3, #5
 800519c:	d17e      	bne.n	800529c <ip4_reass+0x110>
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 800519e:	88e8      	ldrh	r0, [r5, #6]
 80051a0:	f7ff fd21 	bl	8004be6 <lwip_ntohs>
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 80051a4:	4e9b      	ldr	r6, [pc, #620]	; (8005414 <ip4_reass+0x288>)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 80051a6:	4682      	mov	sl, r0
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 80051a8:	8868      	ldrh	r0, [r5, #2]
 80051aa:	f7ff fd1c 	bl	8004be6 <lwip_ntohs>
 80051ae:	4683      	mov	fp, r0
  clen = pbuf_clen(p);
 80051b0:	4638      	mov	r0, r7
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 80051b2:	f895 8000 	ldrb.w	r8, [r5]
  clen = pbuf_clen(p);
 80051b6:	f000 fdf6 	bl	8005da6 <pbuf_clen>
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 80051ba:	88b3      	ldrh	r3, [r6, #4]
  clen = pbuf_clen(p);
 80051bc:	4681      	mov	r9, r0
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 80051be:	4403      	add	r3, r0
 80051c0:	2b0a      	cmp	r3, #10
 80051c2:	dc62      	bgt.n	800528a <ip4_reass+0xfe>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 80051c4:	6834      	ldr	r4, [r6, #0]
 80051c6:	2c00      	cmp	r4, #0
 80051c8:	d16d      	bne.n	80052a6 <ip4_reass+0x11a>
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 80051ca:	2004      	movs	r0, #4
 80051cc:	f000 fbec 	bl	80059a8 <memp_malloc>
  if (ipr == NULL) {
 80051d0:	4604      	mov	r4, r0
 80051d2:	b958      	cbnz	r0, 80051ec <ip4_reass+0x60>
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 80051d4:	4649      	mov	r1, r9
 80051d6:	4628      	mov	r0, r5
 80051d8:	f7ff ff88 	bl	80050ec <ip_reass_remove_oldest_datagram>
 80051dc:	4581      	cmp	r9, r0
 80051de:	dc5d      	bgt.n	800529c <ip4_reass+0x110>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 80051e0:	2004      	movs	r0, #4
 80051e2:	f000 fbe1 	bl	80059a8 <memp_malloc>
    if (ipr == NULL)
 80051e6:	4604      	mov	r4, r0
 80051e8:	2800      	cmp	r0, #0
 80051ea:	d057      	beq.n	800529c <ip4_reass+0x110>
  memset(ipr, 0, sizeof(struct ip_reassdata));
 80051ec:	2220      	movs	r2, #32
 80051ee:	2100      	movs	r1, #0
 80051f0:	4620      	mov	r0, r4
 80051f2:	f004 fd11 	bl	8009c18 <memset>
  ipr->timer = IP_REASS_MAXAGE;
 80051f6:	2303      	movs	r3, #3
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 80051f8:	f104 0208 	add.w	r2, r4, #8
 80051fc:	f105 0114 	add.w	r1, r5, #20
  ipr->timer = IP_REASS_MAXAGE;
 8005200:	77e3      	strb	r3, [r4, #31]
  ipr->next = reassdatagrams;
 8005202:	6833      	ldr	r3, [r6, #0]
  reassdatagrams = ipr;
 8005204:	6034      	str	r4, [r6, #0]
  ipr->next = reassdatagrams;
 8005206:	6023      	str	r3, [r4, #0]
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 8005208:	462b      	mov	r3, r5
 800520a:	f853 0b04 	ldr.w	r0, [r3], #4
 800520e:	428b      	cmp	r3, r1
 8005210:	f842 0b04 	str.w	r0, [r2], #4
 8005214:	d1f9      	bne.n	800520a <ip4_reass+0x7e>
  ip_reass_pbufcount += clen;
 8005216:	88b3      	ldrh	r3, [r6, #4]
 8005218:	4499      	add	r9, r3
 800521a:	f8a6 9004 	strh.w	r9, [r6, #4]
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
 800521e:	88eb      	ldrh	r3, [r5, #6]
 8005220:	069b      	lsls	r3, r3, #26
 8005222:	d40a      	bmi.n	800523a <ip4_reass+0xae>
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 8005224:	f008 000f 	and.w	r0, r8, #15
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 8005228:	7fa3      	ldrb	r3, [r4, #30]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800522a:	ebab 0080 	sub.w	r0, fp, r0, lsl #2
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 800522e:	f043 0301 	orr.w	r3, r3, #1
    ipr->datagram_len = offset + len;
 8005232:	eb00 00ca 	add.w	r0, r0, sl, lsl #3
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 8005236:	77a3      	strb	r3, [r4, #30]
    ipr->datagram_len = offset + len;
 8005238:	83a0      	strh	r0, [r4, #28]
  fraghdr = (struct ip_hdr*)new_p->payload;
 800523a:	f8d7 8004 	ldr.w	r8, [r7, #4]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800523e:	f8b8 0002 	ldrh.w	r0, [r8, #2]
 8005242:	f7ff fcd0 	bl	8004be6 <lwip_ntohs>
 8005246:	f898 5000 	ldrb.w	r5, [r8]
 800524a:	f005 050f 	and.w	r5, r5, #15
 800524e:	eba0 0585 	sub.w	r5, r0, r5, lsl #2
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 8005252:	f8b8 0006 	ldrh.w	r0, [r8, #6]
 8005256:	f7ff fcc6 	bl	8004be6 <lwip_ntohs>
 800525a:	f3c0 000c 	ubfx	r0, r0, #0, #13
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800525e:	b2ad      	uxth	r5, r5
  iprh = (struct ip_reass_helper*)new_p->payload;
 8005260:	6879      	ldr	r1, [r7, #4]
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 8005262:	00c0      	lsls	r0, r0, #3
  iprh->next_pbuf = NULL;
 8005264:	2300      	movs	r3, #0
  for (q = ipr->p; q != NULL;) {
 8005266:	f8d4 e004 	ldr.w	lr, [r4, #4]
  iprh->end = offset + len;
 800526a:	182a      	adds	r2, r5, r0
  int valid = 1;
 800526c:	2501      	movs	r5, #1
  iprh->next_pbuf = NULL;
 800526e:	700b      	strb	r3, [r1, #0]
  iprh->end = offset + len;
 8005270:	b292      	uxth	r2, r2
  iprh->next_pbuf = NULL;
 8005272:	704b      	strb	r3, [r1, #1]
 8005274:	708b      	strb	r3, [r1, #2]
 8005276:	70cb      	strb	r3, [r1, #3]
  iprh->start = offset;
 8005278:	8088      	strh	r0, [r1, #4]
  iprh->end = offset + len;
 800527a:	80ca      	strh	r2, [r1, #6]
  for (q = ipr->p; q != NULL;) {
 800527c:	f1be 0f00 	cmp.w	lr, #0
 8005280:	d120      	bne.n	80052c4 <ip4_reass+0x138>
    if (iprh_prev != NULL) {
 8005282:	2b00      	cmp	r3, #0
 8005284:	d17a      	bne.n	800537c <ip4_reass+0x1f0>
      ipr->p = new_p;
 8005286:	6067      	str	r7, [r4, #4]
 8005288:	e02d      	b.n	80052e6 <ip4_reass+0x15a>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 800528a:	4601      	mov	r1, r0
 800528c:	4628      	mov	r0, r5
 800528e:	f7ff ff2d 	bl	80050ec <ip_reass_remove_oldest_datagram>
 8005292:	b118      	cbz	r0, 800529c <ip4_reass+0x110>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 8005294:	88b3      	ldrh	r3, [r6, #4]
 8005296:	444b      	add	r3, r9
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 8005298:	2b0a      	cmp	r3, #10
 800529a:	dd93      	ble.n	80051c4 <ip4_reass+0x38>
  pbuf_free(p);
 800529c:	4638      	mov	r0, r7
 800529e:	f000 fcaa 	bl	8005bf6 <pbuf_free>
  return NULL;
 80052a2:	2500      	movs	r5, #0
 80052a4:	e059      	b.n	800535a <ip4_reass+0x1ce>
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 80052a6:	68eb      	ldr	r3, [r5, #12]
 80052a8:	6962      	ldr	r2, [r4, #20]
 80052aa:	429a      	cmp	r2, r3
 80052ac:	d108      	bne.n	80052c0 <ip4_reass+0x134>
 80052ae:	692b      	ldr	r3, [r5, #16]
 80052b0:	69a2      	ldr	r2, [r4, #24]
 80052b2:	429a      	cmp	r2, r3
 80052b4:	d104      	bne.n	80052c0 <ip4_reass+0x134>
 80052b6:	89a2      	ldrh	r2, [r4, #12]
 80052b8:	88ab      	ldrh	r3, [r5, #4]
 80052ba:	429a      	cmp	r2, r3
 80052bc:	f000 808a 	beq.w	80053d4 <ip4_reass+0x248>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 80052c0:	6824      	ldr	r4, [r4, #0]
 80052c2:	e780      	b.n	80051c6 <ip4_reass+0x3a>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 80052c4:	f8de c004 	ldr.w	ip, [lr, #4]
    if (iprh->start < iprh_tmp->start) {
 80052c8:	f8bc 8004 	ldrh.w	r8, [ip, #4]
 80052cc:	4540      	cmp	r0, r8
 80052ce:	d247      	bcs.n	8005360 <ip4_reass+0x1d4>
      iprh->next_pbuf = q;
 80052d0:	f8c1 e000 	str.w	lr, [r1]
      if (iprh_prev != NULL) {
 80052d4:	2b00      	cmp	r3, #0
 80052d6:	d0d6      	beq.n	8005286 <ip4_reass+0xfa>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 80052d8:	f8b3 e006 	ldrh.w	lr, [r3, #6]
 80052dc:	4586      	cmp	lr, r0
 80052de:	d85b      	bhi.n	8005398 <ip4_reass+0x20c>
 80052e0:	4542      	cmp	r2, r8
 80052e2:	d859      	bhi.n	8005398 <ip4_reass+0x20c>
        iprh_prev->next_pbuf = new_p;
 80052e4:	601f      	str	r7, [r3, #0]
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 80052e6:	7fa3      	ldrb	r3, [r4, #30]
 80052e8:	f013 0301 	ands.w	r3, r3, #1
 80052ec:	d0d9      	beq.n	80052a2 <ip4_reass+0x116>
    if (valid) {
 80052ee:	2d00      	cmp	r5, #0
 80052f0:	d033      	beq.n	800535a <ip4_reass+0x1ce>
      if ((ipr->p == NULL) || (((struct ip_reass_helper*)ipr->p->payload)->start != 0)) {
 80052f2:	6865      	ldr	r5, [r4, #4]
 80052f4:	2d00      	cmp	r5, #0
 80052f6:	d030      	beq.n	800535a <ip4_reass+0x1ce>
 80052f8:	686d      	ldr	r5, [r5, #4]
 80052fa:	88ab      	ldrh	r3, [r5, #4]
 80052fc:	2b00      	cmp	r3, #0
 80052fe:	d1d0      	bne.n	80052a2 <ip4_reass+0x116>
        q = iprh->next_pbuf;
 8005300:	680b      	ldr	r3, [r1, #0]
        while (q != NULL) {
 8005302:	2b00      	cmp	r3, #0
 8005304:	d140      	bne.n	8005388 <ip4_reass+0x1fc>
    ipr->datagram_len += IP_HLEN;
 8005306:	8ba3      	ldrh	r3, [r4, #28]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 8005308:	462a      	mov	r2, r5
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 800530a:	682f      	ldr	r7, [r5, #0]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 800530c:	f104 011c 	add.w	r1, r4, #28
    ipr->datagram_len += IP_HLEN;
 8005310:	3314      	adds	r3, #20
 8005312:	83a3      	strh	r3, [r4, #28]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 8005314:	f104 0308 	add.w	r3, r4, #8
 8005318:	f853 0b04 	ldr.w	r0, [r3], #4
 800531c:	428b      	cmp	r3, r1
 800531e:	f842 0b04 	str.w	r0, [r2], #4
 8005322:	d1f9      	bne.n	8005318 <ip4_reass+0x18c>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
 8005324:	8ba0      	ldrh	r0, [r4, #28]
 8005326:	f7ff fc5b 	bl	8004be0 <lwip_htons>
    IPH_OFFSET_SET(fraghdr, 0);
 800532a:	2300      	movs	r3, #0
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
 800532c:	8068      	strh	r0, [r5, #2]
    IPH_OFFSET_SET(fraghdr, 0);
 800532e:	71ab      	strb	r3, [r5, #6]
 8005330:	71eb      	strb	r3, [r5, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
 8005332:	72ab      	strb	r3, [r5, #10]
 8005334:	72eb      	strb	r3, [r5, #11]
    p = ipr->p;
 8005336:	6865      	ldr	r5, [r4, #4]
    while (r != NULL) {
 8005338:	2f00      	cmp	r7, #0
 800533a:	d134      	bne.n	80053a6 <ip4_reass+0x21a>
    if (ipr == reassdatagrams) {
 800533c:	6833      	ldr	r3, [r6, #0]
 800533e:	429c      	cmp	r4, r3
 8005340:	d143      	bne.n	80053ca <ip4_reass+0x23e>
    reassdatagrams = ipr->next;
 8005342:	6823      	ldr	r3, [r4, #0]
 8005344:	6033      	str	r3, [r6, #0]
  memp_free(MEMP_REASSDATA, ipr);
 8005346:	4621      	mov	r1, r4
 8005348:	2004      	movs	r0, #4
 800534a:	f000 fb39 	bl	80059c0 <memp_free>
    ip_reass_pbufcount -= pbuf_clen(p);
 800534e:	4628      	mov	r0, r5
 8005350:	f000 fd29 	bl	8005da6 <pbuf_clen>
 8005354:	88b3      	ldrh	r3, [r6, #4]
 8005356:	1a18      	subs	r0, r3, r0
 8005358:	80b0      	strh	r0, [r6, #4]
}
 800535a:	4628      	mov	r0, r5
 800535c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    } else if (iprh->start == iprh_tmp->start) {
 8005360:	d01a      	beq.n	8005398 <ip4_reass+0x20c>
    } else if (iprh->start < iprh_tmp->end) {
 8005362:	f8bc e006 	ldrh.w	lr, [ip, #6]
 8005366:	4586      	cmp	lr, r0
 8005368:	d816      	bhi.n	8005398 <ip4_reass+0x20c>
      if (iprh_prev != NULL) {
 800536a:	b11b      	cbz	r3, 8005374 <ip4_reass+0x1e8>
        if (iprh_prev->end != iprh_tmp->start) {
 800536c:	88db      	ldrh	r3, [r3, #6]
          valid = 0;
 800536e:	4543      	cmp	r3, r8
 8005370:	bf18      	it	ne
 8005372:	2500      	movne	r5, #0
    q = iprh_tmp->next_pbuf;
 8005374:	f8dc e000 	ldr.w	lr, [ip]
 8005378:	4663      	mov	r3, ip
 800537a:	e77f      	b.n	800527c <ip4_reass+0xf0>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 800537c:	88da      	ldrh	r2, [r3, #6]
      iprh_prev->next_pbuf = new_p;
 800537e:	601f      	str	r7, [r3, #0]
        valid = 0;
 8005380:	4290      	cmp	r0, r2
 8005382:	bf18      	it	ne
 8005384:	2500      	movne	r5, #0
 8005386:	e7ae      	b.n	80052e6 <ip4_reass+0x15a>
          iprh = (struct ip_reass_helper*)q->payload;
 8005388:	685a      	ldr	r2, [r3, #4]
          if (iprh_prev->end != iprh->start) {
 800538a:	88c9      	ldrh	r1, [r1, #6]
 800538c:	8893      	ldrh	r3, [r2, #4]
 800538e:	4299      	cmp	r1, r3
 8005390:	d187      	bne.n	80052a2 <ip4_reass+0x116>
          q = iprh->next_pbuf;
 8005392:	6813      	ldr	r3, [r2, #0]
 8005394:	4611      	mov	r1, r2
 8005396:	e7b4      	b.n	8005302 <ip4_reass+0x176>
  ip_reass_pbufcount -= pbuf_clen(new_p);
 8005398:	4638      	mov	r0, r7
 800539a:	f000 fd04 	bl	8005da6 <pbuf_clen>
 800539e:	88b3      	ldrh	r3, [r6, #4]
 80053a0:	1a18      	subs	r0, r3, r0
 80053a2:	80b0      	strh	r0, [r6, #4]
 80053a4:	e77a      	b.n	800529c <ip4_reass+0x110>
      iprh = (struct ip_reass_helper*)r->payload;
 80053a6:	f8d7 8004 	ldr.w	r8, [r7, #4]
      pbuf_header(r, -IP_HLEN);
 80053aa:	f06f 0113 	mvn.w	r1, #19
 80053ae:	4638      	mov	r0, r7
 80053b0:	f000 fc13 	bl	8005bda <pbuf_header>
      pbuf_cat(p, r);
 80053b4:	4639      	mov	r1, r7
 80053b6:	4628      	mov	r0, r5
 80053b8:	f000 fd02 	bl	8005dc0 <pbuf_cat>
      r = iprh->next_pbuf;
 80053bc:	f8d8 7000 	ldr.w	r7, [r8]
 80053c0:	e7ba      	b.n	8005338 <ip4_reass+0x1ac>
        if (ipr_prev->next == ipr) {
 80053c2:	681a      	ldr	r2, [r3, #0]
 80053c4:	4294      	cmp	r4, r2
 80053c6:	d021      	beq.n	800540c <ip4_reass+0x280>
 80053c8:	4613      	mov	r3, r2
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
 80053ca:	2b00      	cmp	r3, #0
 80053cc:	d1f9      	bne.n	80053c2 <ip4_reass+0x236>
    prev->next = ipr->next;
 80053ce:	6822      	ldr	r2, [r4, #0]
 80053d0:	601a      	str	r2, [r3, #0]
 80053d2:	deff      	udf	#255	; 0xff
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
 80053d4:	88e8      	ldrh	r0, [r5, #6]
 80053d6:	f7ff fc06 	bl	8004be6 <lwip_ntohs>
 80053da:	f3c0 000c 	ubfx	r0, r0, #0, #13
 80053de:	2800      	cmp	r0, #0
 80053e0:	f47f af19 	bne.w	8005216 <ip4_reass+0x8a>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 80053e4:	89e0      	ldrh	r0, [r4, #14]
 80053e6:	f7ff fbfe 	bl	8004be6 <lwip_ntohs>
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
 80053ea:	f3c0 000c 	ubfx	r0, r0, #0, #13
 80053ee:	2800      	cmp	r0, #0
 80053f0:	f43f af11 	beq.w	8005216 <ip4_reass+0x8a>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 80053f4:	462b      	mov	r3, r5
 80053f6:	f104 0208 	add.w	r2, r4, #8
 80053fa:	f105 0114 	add.w	r1, r5, #20
 80053fe:	f853 0b04 	ldr.w	r0, [r3], #4
 8005402:	428b      	cmp	r3, r1
 8005404:	f842 0b04 	str.w	r0, [r2], #4
 8005408:	d1f9      	bne.n	80053fe <ip4_reass+0x272>
 800540a:	e704      	b.n	8005216 <ip4_reass+0x8a>
    prev->next = ipr->next;
 800540c:	6822      	ldr	r2, [r4, #0]
 800540e:	601a      	str	r2, [r3, #0]
 8005410:	e799      	b.n	8005346 <ip4_reass+0x1ba>
 8005412:	bf00      	nop
 8005414:	20003dbc 	.word	0x20003dbc

08005418 <ip4_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t
ip4_frag(struct pbuf *p, struct netif *netif, const ip4_addr_t *dest)
{
 8005418:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
#else /* IP_FRAG_USES_STATIC_BUF */
  original_iphdr = (struct ip_hdr *)p->payload;
 800541c:	6843      	ldr	r3, [r0, #4]
{
 800541e:	b08d      	sub	sp, #52	; 0x34
 8005420:	4605      	mov	r5, r0
  u16_t mtu = netif->mtu;
 8005422:	f8b1 8022 	ldrh.w	r8, [r1, #34]	; 0x22
{
 8005426:	9209      	str	r2, [sp, #36]	; 0x24
 8005428:	468b      	mov	fp, r1
  original_iphdr = (struct ip_hdr *)p->payload;
 800542a:	9304      	str	r3, [sp, #16]
  u16_t newpbuflen = 0;
 800542c:	2600      	movs	r6, #0
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
 800542e:	88d8      	ldrh	r0, [r3, #6]
  u16_t poff = IP_HLEN;
 8005430:	2714      	movs	r7, #20
  tmp = ntohs(IPH_OFFSET(iphdr));
 8005432:	f7ff fbd8 	bl	8004be6 <lwip_ntohs>
  ofo = tmp & IP_OFFMASK;
 8005436:	f3c0 030c 	ubfx	r3, r0, #0, #13
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;
 800543a:	2208      	movs	r2, #8
  left = p->tot_len - IP_HLEN;
 800543c:	892c      	ldrh	r4, [r5, #8]
  ofo = tmp & IP_OFFMASK;
 800543e:	9303      	str	r3, [sp, #12]
  omf = tmp & IP_MF;
 8005440:	f400 5300 	and.w	r3, r0, #8192	; 0x2000
  left = p->tot_len - IP_HLEN;
 8005444:	3c14      	subs	r4, #20
  omf = tmp & IP_MF;
 8005446:	9307      	str	r3, [sp, #28]
  nfb = (mtu - IP_HLEN) / 8;
 8005448:	f1a8 0314 	sub.w	r3, r8, #20
  left = p->tot_len - IP_HLEN;
 800544c:	b2a4      	uxth	r4, r4
  nfb = (mtu - IP_HLEN) / 8;
 800544e:	fb93 f3f2 	sdiv	r3, r3, r2
 8005452:	b29b      	uxth	r3, r3
 8005454:	9306      	str	r3, [sp, #24]
    if (!last) {
      tmp = tmp | IP_MF;
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
 8005456:	00db      	lsls	r3, r3, #3
 8005458:	b29b      	uxth	r3, r3
 800545a:	9308      	str	r3, [sp, #32]
    last = (left <= mtu - IP_HLEN);
 800545c:	f1a8 0313 	sub.w	r3, r8, #19
 8005460:	930a      	str	r3, [sp, #40]	; 0x28
  while (left) {
 8005462:	b91c      	cbnz	r4, 800546c <ip4_frag+0x54>
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  MIB2_STATS_INC(mib2.ipfragoks);
  return ERR_OK;
 8005464:	4620      	mov	r0, r4
memerr:
  MIB2_STATS_INC(mib2.ipfragfails);
  return ERR_MEM;
}
 8005466:	b00d      	add	sp, #52	; 0x34
 8005468:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    tmp = omf | (IP_OFFMASK & (ofo));
 800546c:	9b03      	ldr	r3, [sp, #12]
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 800546e:	2114      	movs	r1, #20
    tmp = omf | (IP_OFFMASK & (ofo));
 8005470:	9a07      	ldr	r2, [sp, #28]
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 8005472:	2002      	movs	r0, #2
    tmp = omf | (IP_OFFMASK & (ofo));
 8005474:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8005478:	4313      	orrs	r3, r2
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 800547a:	2200      	movs	r2, #0
    tmp = omf | (IP_OFFMASK & (ofo));
 800547c:	9305      	str	r3, [sp, #20]
    if (!last) {
 800547e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8005480:	42a3      	cmp	r3, r4
      tmp = tmp | IP_MF;
 8005482:	bfd7      	itett	le
 8005484:	9b05      	ldrle	r3, [sp, #20]
 8005486:	46a2      	movgt	sl, r4
    cop = last ? left : nfb * 8;
 8005488:	f8dd a020 	ldrle.w	sl, [sp, #32]
      tmp = tmp | IP_MF;
 800548c:	f443 5300 	orrle.w	r3, r3, #8192	; 0x2000
 8005490:	bfd8      	it	le
 8005492:	9305      	strle	r3, [sp, #20]
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 8005494:	f000 fbd6 	bl	8005c44 <pbuf_alloc>
    if (rambuf == NULL) {
 8005498:	4680      	mov	r8, r0
 800549a:	b320      	cbz	r0, 80054e6 <ip4_frag+0xce>
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
 800549c:	9b04      	ldr	r3, [sp, #16]
 800549e:	6842      	ldr	r2, [r0, #4]
 80054a0:	4619      	mov	r1, r3
 80054a2:	3114      	adds	r1, #20
 80054a4:	f853 0b04 	ldr.w	r0, [r3], #4
 80054a8:	428b      	cmp	r3, r1
 80054aa:	f842 0b04 	str.w	r0, [r2], #4
 80054ae:	d1f9      	bne.n	80054a4 <ip4_frag+0x8c>
    iphdr = (struct ip_hdr *)rambuf->payload;
 80054b0:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80054b4:	9302      	str	r3, [sp, #8]
    p->payload = (u8_t *)p->payload + poff;
 80054b6:	686b      	ldr	r3, [r5, #4]
 80054b8:	443b      	add	r3, r7
 80054ba:	606b      	str	r3, [r5, #4]
    p->len -= poff;
 80054bc:	896b      	ldrh	r3, [r5, #10]
 80054be:	1bdf      	subs	r7, r3, r7
 80054c0:	816f      	strh	r7, [r5, #10]
    left_to_copy = cop;
 80054c2:	4657      	mov	r7, sl
    while (left_to_copy) {
 80054c4:	b397      	cbz	r7, 800552c <ip4_frag+0x114>
      newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
 80054c6:	896e      	ldrh	r6, [r5, #10]
 80054c8:	42be      	cmp	r6, r7
 80054ca:	bf28      	it	cs
 80054cc:	463e      	movcs	r6, r7
 80054ce:	b2b6      	uxth	r6, r6
      if (!newpbuflen) {
 80054d0:	b90e      	cbnz	r6, 80054d6 <ip4_frag+0xbe>
        p = p->next;
 80054d2:	682d      	ldr	r5, [r5, #0]
 80054d4:	e7f6      	b.n	80054c4 <ip4_frag+0xac>
  return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
 80054d6:	2005      	movs	r0, #5
 80054d8:	f000 fa66 	bl	80059a8 <memp_malloc>
      if (pcr == NULL) {
 80054dc:	4681      	mov	r9, r0
 80054de:	b928      	cbnz	r0, 80054ec <ip4_frag+0xd4>
        pbuf_free(rambuf);
 80054e0:	4640      	mov	r0, r8
 80054e2:	f000 fb88 	bl	8005bf6 <pbuf_free>
  return ERR_MEM;
 80054e6:	f04f 30ff 	mov.w	r0, #4294967295
 80054ea:	e7bc      	b.n	8005466 <ip4_frag+0x4e>
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
 80054ec:	9601      	str	r6, [sp, #4]
 80054ee:	2202      	movs	r2, #2
 80054f0:	686b      	ldr	r3, [r5, #4]
 80054f2:	4631      	mov	r1, r6
 80054f4:	9300      	str	r3, [sp, #0]
 80054f6:	4603      	mov	r3, r0
 80054f8:	2004      	movs	r0, #4
 80054fa:	f000 fb43 	bl	8005b84 <pbuf_alloced_custom>
      if (newpbuf == NULL) {
 80054fe:	b920      	cbnz	r0, 800550a <ip4_frag+0xf2>
  memp_free(MEMP_FRAG_PBUF, p);
 8005500:	4649      	mov	r1, r9
 8005502:	2005      	movs	r0, #5
 8005504:	f000 fa5c 	bl	80059c0 <memp_free>
 8005508:	e7ea      	b.n	80054e0 <ip4_frag+0xc8>
 800550a:	900b      	str	r0, [sp, #44]	; 0x2c
      left_to_copy -= newpbuflen;
 800550c:	1bbf      	subs	r7, r7, r6
      pbuf_ref(p);
 800550e:	4628      	mov	r0, r5
 8005510:	f000 fc51 	bl	8005db6 <pbuf_ref>
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 8005514:	4b16      	ldr	r3, [pc, #88]	; (8005570 <ip4_frag+0x158>)
      left_to_copy -= newpbuflen;
 8005516:	b2bf      	uxth	r7, r7
      pcr->original = p;
 8005518:	f8c9 5014 	str.w	r5, [r9, #20]
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 800551c:	f8c9 3010 	str.w	r3, [r9, #16]
      pbuf_cat(rambuf, newpbuf);
 8005520:	4640      	mov	r0, r8
 8005522:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8005524:	f000 fc4c 	bl	8005dc0 <pbuf_cat>
      if (left_to_copy) {
 8005528:	2f00      	cmp	r7, #0
 800552a:	d1d2      	bne.n	80054d2 <ip4_frag+0xba>
    IPH_OFFSET_SET(iphdr, htons(tmp));
 800552c:	9805      	ldr	r0, [sp, #20]
    left -= cop;
 800552e:	eba4 040a 	sub.w	r4, r4, sl
    IPH_OFFSET_SET(iphdr, htons(tmp));
 8005532:	f7ff fb55 	bl	8004be0 <lwip_htons>
 8005536:	9b02      	ldr	r3, [sp, #8]
    left -= cop;
 8005538:	b2a4      	uxth	r4, r4
    IPH_OFFSET_SET(iphdr, htons(tmp));
 800553a:	80d8      	strh	r0, [r3, #6]
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 800553c:	f10a 0014 	add.w	r0, sl, #20
 8005540:	b280      	uxth	r0, r0
 8005542:	f7ff fb4d 	bl	8004be0 <lwip_htons>
 8005546:	9b02      	ldr	r3, [sp, #8]
    netif->output(netif, rambuf, dest);
 8005548:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800554a:	4641      	mov	r1, r8
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 800554c:	8058      	strh	r0, [r3, #2]
    netif->output(netif, rambuf, dest);
 800554e:	4658      	mov	r0, fp
    IPH_CHKSUM_SET(iphdr, 0);
 8005550:	729f      	strb	r7, [r3, #10]
 8005552:	72df      	strb	r7, [r3, #11]
    ofo += nfb;
 8005554:	4637      	mov	r7, r6
    netif->output(netif, rambuf, dest);
 8005556:	f8db 3014 	ldr.w	r3, [fp, #20]
 800555a:	4798      	blx	r3
    pbuf_free(rambuf);
 800555c:	4640      	mov	r0, r8
 800555e:	f000 fb4a 	bl	8005bf6 <pbuf_free>
    ofo += nfb;
 8005562:	9b03      	ldr	r3, [sp, #12]
 8005564:	9a06      	ldr	r2, [sp, #24]
 8005566:	4413      	add	r3, r2
 8005568:	b29b      	uxth	r3, r3
 800556a:	9303      	str	r3, [sp, #12]
 800556c:	e779      	b.n	8005462 <ip4_frag+0x4a>
 800556e:	bf00      	nop
 8005570:	0800504d 	.word	0x0800504d

08005574 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 8005574:	b570      	push	{r4, r5, r6, lr}
 8005576:	4604      	mov	r4, r0
  struct sys_timeo *timeout, *t;
#if NO_SYS
  u32_t now, diff;
#endif

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 8005578:	200a      	movs	r0, #10
{
 800557a:	460e      	mov	r6, r1
 800557c:	4615      	mov	r5, r2
  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 800557e:	f000 fa13 	bl	80059a8 <memp_malloc>
  if (timeout == NULL) {
 8005582:	b308      	cbz	r0, 80055c8 <sys_timeout+0x54>
  } else {
    diff = now - timeouts_last_time;
  }
#endif

  timeout->next = NULL;
 8005584:	2300      	movs	r3, #0
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 8005586:	4911      	ldr	r1, [pc, #68]	; (80055cc <sys_timeout+0x58>)
  timeout->h = handler;
 8005588:	6086      	str	r6, [r0, #8]
  timeout->next = NULL;
 800558a:	6003      	str	r3, [r0, #0]
  if (next_timeout == NULL) {
 800558c:	680b      	ldr	r3, [r1, #0]
  timeout->arg = arg;
 800558e:	60c5      	str	r5, [r0, #12]
  timeout->time = msecs;
 8005590:	6044      	str	r4, [r0, #4]
  if (next_timeout == NULL) {
 8005592:	b90b      	cbnz	r3, 8005598 <sys_timeout+0x24>
  }

  if (next_timeout->time > msecs) {
    next_timeout->time -= msecs;
    timeout->next = next_timeout;
    next_timeout = timeout;
 8005594:	6008      	str	r0, [r1, #0]
 8005596:	bd70      	pop	{r4, r5, r6, pc}
  if (next_timeout->time > msecs) {
 8005598:	685a      	ldr	r2, [r3, #4]
 800559a:	4294      	cmp	r4, r2
 800559c:	d207      	bcs.n	80055ae <sys_timeout+0x3a>
    next_timeout->time -= msecs;
 800559e:	1b12      	subs	r2, r2, r4
 80055a0:	605a      	str	r2, [r3, #4]
    timeout->next = next_timeout;
 80055a2:	6003      	str	r3, [r0, #0]
 80055a4:	e7f6      	b.n	8005594 <sys_timeout+0x20>
  } else {
    for (t = next_timeout; t != NULL; t = t->next) {
      timeout->time -= t->time;
      if (t->next == NULL || t->next->time > timeout->time) {
 80055a6:	6854      	ldr	r4, [r2, #4]
 80055a8:	42a1      	cmp	r1, r4
 80055aa:	d30a      	bcc.n	80055c2 <sys_timeout+0x4e>
 80055ac:	4613      	mov	r3, r2
      timeout->time -= t->time;
 80055ae:	685a      	ldr	r2, [r3, #4]
 80055b0:	6841      	ldr	r1, [r0, #4]
 80055b2:	1a89      	subs	r1, r1, r2
      if (t->next == NULL || t->next->time > timeout->time) {
 80055b4:	681a      	ldr	r2, [r3, #0]
      timeout->time -= t->time;
 80055b6:	6041      	str	r1, [r0, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
 80055b8:	2a00      	cmp	r2, #0
 80055ba:	d1f4      	bne.n	80055a6 <sys_timeout+0x32>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
        }
        timeout->next = t->next;
 80055bc:	6002      	str	r2, [r0, #0]
        t->next = timeout;
 80055be:	6018      	str	r0, [r3, #0]
        break;
 80055c0:	bd70      	pop	{r4, r5, r6, pc}
          t->next->time -= timeout->time;
 80055c2:	1a61      	subs	r1, r4, r1
 80055c4:	6051      	str	r1, [r2, #4]
 80055c6:	e7f9      	b.n	80055bc <sys_timeout+0x48>
 80055c8:	bd70      	pop	{r4, r5, r6, pc}
 80055ca:	bf00      	nop
 80055cc:	20003dc4 	.word	0x20003dc4

080055d0 <tcp_timer_needed>:
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 80055d0:	4b08      	ldr	r3, [pc, #32]	; (80055f4 <tcp_timer_needed+0x24>)
 80055d2:	685a      	ldr	r2, [r3, #4]
 80055d4:	b962      	cbnz	r2, 80055f0 <tcp_timer_needed+0x20>
 80055d6:	4a08      	ldr	r2, [pc, #32]	; (80055f8 <tcp_timer_needed+0x28>)
 80055d8:	6812      	ldr	r2, [r2, #0]
 80055da:	b912      	cbnz	r2, 80055e2 <tcp_timer_needed+0x12>
 80055dc:	4a07      	ldr	r2, [pc, #28]	; (80055fc <tcp_timer_needed+0x2c>)
 80055de:	6812      	ldr	r2, [r2, #0]
 80055e0:	b132      	cbz	r2, 80055f0 <tcp_timer_needed+0x20>
    tcpip_tcp_timer_active = 1;
 80055e2:	2201      	movs	r2, #1
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 80055e4:	4906      	ldr	r1, [pc, #24]	; (8005600 <tcp_timer_needed+0x30>)
 80055e6:	20fa      	movs	r0, #250	; 0xfa
    tcpip_tcp_timer_active = 1;
 80055e8:	605a      	str	r2, [r3, #4]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 80055ea:	2200      	movs	r2, #0
 80055ec:	f7ff bfc2 	b.w	8005574 <sys_timeout>
 80055f0:	4770      	bx	lr
 80055f2:	bf00      	nop
 80055f4:	20003dc4 	.word	0x20003dc4
 80055f8:	20007668 	.word	0x20007668
 80055fc:	20007678 	.word	0x20007678
 8005600:	08005605 	.word	0x08005605

08005604 <tcpip_tcp_timer>:
{
 8005604:	b508      	push	{r3, lr}
  tcp_tmr();
 8005606:	f001 f877 	bl	80066f8 <tcp_tmr>
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 800560a:	4b08      	ldr	r3, [pc, #32]	; (800562c <tcpip_tcp_timer+0x28>)
 800560c:	681b      	ldr	r3, [r3, #0]
 800560e:	b913      	cbnz	r3, 8005616 <tcpip_tcp_timer+0x12>
 8005610:	4b07      	ldr	r3, [pc, #28]	; (8005630 <tcpip_tcp_timer+0x2c>)
 8005612:	681b      	ldr	r3, [r3, #0]
 8005614:	b133      	cbz	r3, 8005624 <tcpip_tcp_timer+0x20>
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 8005616:	2200      	movs	r2, #0
 8005618:	4906      	ldr	r1, [pc, #24]	; (8005634 <tcpip_tcp_timer+0x30>)
 800561a:	20fa      	movs	r0, #250	; 0xfa
}
 800561c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 8005620:	f7ff bfa8 	b.w	8005574 <sys_timeout>
    tcpip_tcp_timer_active = 0;
 8005624:	4a04      	ldr	r2, [pc, #16]	; (8005638 <tcpip_tcp_timer+0x34>)
 8005626:	6053      	str	r3, [r2, #4]
 8005628:	bd08      	pop	{r3, pc}
 800562a:	bf00      	nop
 800562c:	20007668 	.word	0x20007668
 8005630:	20007678 	.word	0x20007678
 8005634:	08005605 	.word	0x08005605
 8005638:	20003dc4 	.word	0x20003dc4

0800563c <sys_timeouts_init>:
{
 800563c:	b508      	push	{r3, lr}
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 800563e:	2200      	movs	r2, #0
 8005640:	4906      	ldr	r1, [pc, #24]	; (800565c <sys_timeouts_init+0x20>)
 8005642:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005646:	f7ff ff95 	bl	8005574 <sys_timeout>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 800564a:	2200      	movs	r2, #0
 800564c:	4904      	ldr	r1, [pc, #16]	; (8005660 <sys_timeouts_init+0x24>)
 800564e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
}
 8005652:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 8005656:	f7ff bf8d 	b.w	8005574 <sys_timeout>
 800565a:	bf00      	nop
 800565c:	08005681 	.word	0x08005681
 8005660:	08005665 	.word	0x08005665

08005664 <arp_timer>:
{
 8005664:	b508      	push	{r3, lr}
  etharp_tmr();
 8005666:	f003 fa99 	bl	8008b9c <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 800566a:	2200      	movs	r2, #0
 800566c:	4903      	ldr	r1, [pc, #12]	; (800567c <arp_timer+0x18>)
 800566e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
}
 8005672:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 8005676:	f7ff bf7d 	b.w	8005574 <sys_timeout>
 800567a:	bf00      	nop
 800567c:	08005665 	.word	0x08005665

08005680 <ip_reass_timer>:
{
 8005680:	b508      	push	{r3, lr}
  ip_reass_tmr();
 8005682:	f7ff fd6f 	bl	8005164 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 8005686:	2200      	movs	r2, #0
 8005688:	4903      	ldr	r1, [pc, #12]	; (8005698 <ip_reass_timer+0x18>)
 800568a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
}
 800568e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 8005692:	f7ff bf6f 	b.w	8005574 <sys_timeout>
 8005696:	bf00      	nop
 8005698:	08005681 	.word	0x08005681

0800569c <sys_timeouts_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
{
 800569c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  struct sys_timeo *tmptimeout;
  sys_timeout_handler handler;
  void *arg;

 again:
  if (!next_timeout) {
 80056a0:	4c16      	ldr	r4, [pc, #88]	; (80056fc <sys_timeouts_mbox_fetch+0x60>)
{
 80056a2:	4606      	mov	r6, r0
 80056a4:	460f      	mov	r7, r1
 80056a6:	46a0      	mov	r8, r4
  if (!next_timeout) {
 80056a8:	6822      	ldr	r2, [r4, #0]
 80056aa:	b92a      	cbnz	r2, 80056b8 <sys_timeouts_mbox_fetch+0x1c>
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
 80056ac:	4639      	mov	r1, r7
 80056ae:	4630      	mov	r0, r6
      } else {
        next_timeout->time = 0;
      }
    }
  }
}
 80056b0:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
 80056b4:	f003 bcd6 	b.w	8009064 <sys_arch_mbox_fetch>
    if (next_timeout->time > 0) {
 80056b8:	6852      	ldr	r2, [r2, #4]
 80056ba:	b97a      	cbnz	r2, 80056dc <sys_timeouts_mbox_fetch+0x40>
      tmptimeout = next_timeout;
 80056bc:	f8d8 1000 	ldr.w	r1, [r8]
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 80056c0:	200a      	movs	r0, #10
      next_timeout = tmptimeout->next;
 80056c2:	680b      	ldr	r3, [r1, #0]
      handler = tmptimeout->h;
 80056c4:	688d      	ldr	r5, [r1, #8]
      next_timeout = tmptimeout->next;
 80056c6:	f8c8 3000 	str.w	r3, [r8]
      arg = tmptimeout->arg;
 80056ca:	f8d1 900c 	ldr.w	r9, [r1, #12]
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 80056ce:	f000 f977 	bl	80059c0 <memp_free>
      if (handler != NULL) {
 80056d2:	2d00      	cmp	r5, #0
 80056d4:	d0e8      	beq.n	80056a8 <sys_timeouts_mbox_fetch+0xc>
        handler(arg);
 80056d6:	4648      	mov	r0, r9
 80056d8:	47a8      	blx	r5
 80056da:	e7e5      	b.n	80056a8 <sys_timeouts_mbox_fetch+0xc>
      time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
 80056dc:	4639      	mov	r1, r7
 80056de:	4630      	mov	r0, r6
 80056e0:	f003 fcc0 	bl	8009064 <sys_arch_mbox_fetch>
    if (time_needed == SYS_ARCH_TIMEOUT) {
 80056e4:	1c43      	adds	r3, r0, #1
 80056e6:	d0e9      	beq.n	80056bc <sys_timeouts_mbox_fetch+0x20>
      if (time_needed < next_timeout->time) {
 80056e8:	6822      	ldr	r2, [r4, #0]
 80056ea:	6853      	ldr	r3, [r2, #4]
 80056ec:	4298      	cmp	r0, r3
        next_timeout->time -= time_needed;
 80056ee:	bf34      	ite	cc
 80056f0:	1a1b      	subcc	r3, r3, r0
        next_timeout->time = 0;
 80056f2:	2300      	movcs	r3, #0
 80056f4:	6053      	str	r3, [r2, #4]
 80056f6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80056fa:	bf00      	nop
 80056fc:	20003dc4 	.word	0x20003dc4

08005700 <mem_init>:

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 8005700:	4b0d      	ldr	r3, [pc, #52]	; (8005738 <mem_init+0x38>)
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
 8005702:	f44f 62c8 	mov.w	r2, #1600	; 0x640
  mem->prev = 0;
 8005706:	2100      	movs	r1, #0
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 8005708:	480c      	ldr	r0, [pc, #48]	; (800573c <mem_init+0x3c>)
 800570a:	f023 0303 	bic.w	r3, r3, #3
  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if (sys_mutex_new(&mem_mutex) != ERR_OK) {
 800570e:	300c      	adds	r0, #12
  mem->prev = 0;
 8005710:	8059      	strh	r1, [r3, #2]
  mem->used = 0;
 8005712:	7119      	strb	r1, [r3, #4]
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 8005714:	1899      	adds	r1, r3, r2
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 8005716:	f840 3c0c 	str.w	r3, [r0, #-12]
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 800571a:	f840 1c08 	str.w	r1, [r0, #-8]
  ram_end->used = 1;
 800571e:	2101      	movs	r1, #1
  lfree = (struct mem *)(void *)ram;
 8005720:	f840 3c04 	str.w	r3, [r0, #-4]
  mem->next = MEM_SIZE_ALIGNED;
 8005724:	801a      	strh	r2, [r3, #0]
  ram_end->used = 1;
 8005726:	f883 1644 	strb.w	r1, [r3, #1604]	; 0x644
  ram_end->next = MEM_SIZE_ALIGNED;
 800572a:	f8a3 2640 	strh.w	r2, [r3, #1600]	; 0x640
  ram_end->prev = MEM_SIZE_ALIGNED;
 800572e:	f8a3 2642 	strh.w	r2, [r3, #1602]	; 0x642
  if (sys_mutex_new(&mem_mutex) != ERR_OK) {
 8005732:	f003 bd1f 	b.w	8009174 <sys_mutex_new>
 8005736:	bf00      	nop
 8005738:	20003fa7 	.word	0x20003fa7
 800573c:	20003dcc 	.word	0x20003dcc

08005740 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 8005740:	b570      	push	{r4, r5, r6, lr}
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 8005742:	4605      	mov	r5, r0
 8005744:	2800      	cmp	r0, #0
 8005746:	d042      	beq.n	80057ce <mem_free+0x8e>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 8005748:	4c21      	ldr	r4, [pc, #132]	; (80057d0 <mem_free+0x90>)
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 800574a:	6823      	ldr	r3, [r4, #0]
 800574c:	4298      	cmp	r0, r3
 800574e:	d33e      	bcc.n	80057ce <mem_free+0x8e>
 8005750:	6863      	ldr	r3, [r4, #4]
 8005752:	4298      	cmp	r0, r3
 8005754:	d23b      	bcs.n	80057ce <mem_free+0x8e>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
 8005756:	f104 000c 	add.w	r0, r4, #12
 800575a:	f003 fd1b 	bl	8009194 <sys_mutex_lock>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
 800575e:	2300      	movs	r3, #0
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 8005760:	f1a5 0208 	sub.w	r2, r5, #8
  nmem = (struct mem *)(void *)&ram[mem->next];
 8005764:	f835 0c08 	ldrh.w	r0, [r5, #-8]
  mem->used = 0;
 8005768:	f805 3c04 	strb.w	r3, [r5, #-4]

  if (mem < lfree) {
 800576c:	68a3      	ldr	r3, [r4, #8]
 800576e:	429a      	cmp	r2, r3
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 8005770:	6823      	ldr	r3, [r4, #0]
  nmem = (struct mem *)(void *)&ram[mem->next];
 8005772:	eb03 0100 	add.w	r1, r3, r0
    /* the newly freed struct is now the lowest */
    lfree = mem;
 8005776:	bf38      	it	cc
 8005778:	60a2      	strcc	r2, [r4, #8]
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 800577a:	428a      	cmp	r2, r1
 800577c:	d010      	beq.n	80057a0 <mem_free+0x60>
 800577e:	790e      	ldrb	r6, [r1, #4]
 8005780:	b976      	cbnz	r6, 80057a0 <mem_free+0x60>
 8005782:	6866      	ldr	r6, [r4, #4]
 8005784:	428e      	cmp	r6, r1
 8005786:	d00b      	beq.n	80057a0 <mem_free+0x60>
    if (lfree == nmem) {
 8005788:	68a6      	ldr	r6, [r4, #8]
 800578a:	42b1      	cmp	r1, r6
    mem->next = nmem->next;
 800578c:	5a19      	ldrh	r1, [r3, r0]
 800578e:	f825 1c08 	strh.w	r1, [r5, #-8]
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 8005792:	5a19      	ldrh	r1, [r3, r0]
 8005794:	eba2 0003 	sub.w	r0, r2, r3
      lfree = mem;
 8005798:	bf08      	it	eq
 800579a:	60a2      	streq	r2, [r4, #8]
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 800579c:	4419      	add	r1, r3
 800579e:	8048      	strh	r0, [r1, #2]
  pmem = (struct mem *)(void *)&ram[mem->prev];
 80057a0:	f835 1c06 	ldrh.w	r1, [r5, #-6]
 80057a4:	1858      	adds	r0, r3, r1
  if (pmem != mem && pmem->used == 0) {
 80057a6:	4282      	cmp	r2, r0
 80057a8:	d00c      	beq.n	80057c4 <mem_free+0x84>
 80057aa:	7906      	ldrb	r6, [r0, #4]
 80057ac:	b956      	cbnz	r6, 80057c4 <mem_free+0x84>
    if (lfree == mem) {
 80057ae:	68a6      	ldr	r6, [r4, #8]
 80057b0:	42b2      	cmp	r2, r6
    pmem->next = mem->next;
 80057b2:	f835 2c08 	ldrh.w	r2, [r5, #-8]
 80057b6:	525a      	strh	r2, [r3, r1]
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
 80057b8:	f835 2c08 	ldrh.w	r2, [r5, #-8]
      lfree = pmem;
 80057bc:	bf08      	it	eq
 80057be:	60a0      	streq	r0, [r4, #8]
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
 80057c0:	4413      	add	r3, r2
 80057c2:	8059      	strh	r1, [r3, #2]
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 80057c4:	4803      	ldr	r0, [pc, #12]	; (80057d4 <mem_free+0x94>)
}
 80057c6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  LWIP_MEM_FREE_UNPROTECT();
 80057ca:	f003 bce6 	b.w	800919a <sys_mutex_unlock>
 80057ce:	bd70      	pop	{r4, r5, r6, pc}
 80057d0:	20003dcc 	.word	0x20003dcc
 80057d4:	20003dd8 	.word	0x20003dd8

080057d8 <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
 80057d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 80057dc:	3103      	adds	r1, #3
 80057de:	f64f 74fc 	movw	r4, #65532	; 0xfffc
{
 80057e2:	4605      	mov	r5, r0
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 80057e4:	400c      	ands	r4, r1

  if (newsize < MIN_SIZE_ALIGNED) {
 80057e6:	2c0b      	cmp	r4, #11
 80057e8:	d904      	bls.n	80057f4 <mem_trim+0x1c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
 80057ea:	f5b4 6fc8 	cmp.w	r4, #1600	; 0x640
 80057ee:	d902      	bls.n	80057f6 <mem_trim+0x1e>
    return NULL;
 80057f0:	2500      	movs	r5, #0
 80057f2:	e047      	b.n	8005884 <mem_trim+0xac>
    newsize = MIN_SIZE_ALIGNED;
 80057f4:	240c      	movs	r4, #12
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 80057f6:	4f25      	ldr	r7, [pc, #148]	; (800588c <mem_trim+0xb4>)
 80057f8:	683b      	ldr	r3, [r7, #0]
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 80057fa:	42ab      	cmp	r3, r5
 80057fc:	d842      	bhi.n	8005884 <mem_trim+0xac>
 80057fe:	687a      	ldr	r2, [r7, #4]
 8005800:	4295      	cmp	r5, r2
 8005802:	d23f      	bcs.n	8005884 <mem_trim+0xac>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 8005804:	f1a5 0608 	sub.w	r6, r5, #8
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 8005808:	f835 8c08 	ldrh.w	r8, [r5, #-8]
  ptr = (mem_size_t)((u8_t *)mem - ram);
 800580c:	1af6      	subs	r6, r6, r3
  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 800580e:	f1a8 0808 	sub.w	r8, r8, #8
  ptr = (mem_size_t)((u8_t *)mem - ram);
 8005812:	b2b6      	uxth	r6, r6
  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 8005814:	eba8 0806 	sub.w	r8, r8, r6
 8005818:	fa1f f888 	uxth.w	r8, r8
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
  if (newsize > size) {
 800581c:	45a0      	cmp	r8, r4
 800581e:	d3e7      	bcc.n	80057f0 <mem_trim+0x18>
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
 8005820:	d030      	beq.n	8005884 <mem_trim+0xac>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
 8005822:	f107 000c 	add.w	r0, r7, #12
 8005826:	f003 fcb5 	bl	8009194 <sys_mutex_lock>

  mem2 = (struct mem *)(void *)&ram[mem->next];
 800582a:	683b      	ldr	r3, [r7, #0]
 800582c:	f835 1c08 	ldrh.w	r1, [r5, #-8]
 8005830:	1858      	adds	r0, r3, r1
  if (mem2->used == 0) {
 8005832:	7902      	ldrb	r2, [r0, #4]
 8005834:	b95a      	cbnz	r2, 800584e <mem_trim+0x76>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8005836:	f106 0208 	add.w	r2, r6, #8
    next = mem2->next;
 800583a:	5a59      	ldrh	r1, [r3, r1]
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 800583c:	4414      	add	r4, r2
    if (lfree == mem2) {
 800583e:	68ba      	ldr	r2, [r7, #8]
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8005840:	b2a4      	uxth	r4, r4
    if (lfree == mem2) {
 8005842:	4290      	cmp	r0, r2
 8005844:	eb03 0204 	add.w	r2, r3, r4
 8005848:	d10d      	bne.n	8005866 <mem_trim+0x8e>
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    mem2 = (struct mem *)(void *)&ram[ptr2];
    if (mem2 < lfree) {
      lfree = mem2;
 800584a:	60ba      	str	r2, [r7, #8]
 800584c:	e00b      	b.n	8005866 <mem_trim+0x8e>
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 800584e:	f104 0214 	add.w	r2, r4, #20
 8005852:	4542      	cmp	r2, r8
 8005854:	d813      	bhi.n	800587e <mem_trim+0xa6>
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8005856:	f106 0208 	add.w	r2, r6, #8
    if (mem2 < lfree) {
 800585a:	68b8      	ldr	r0, [r7, #8]
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 800585c:	4414      	add	r4, r2
 800585e:	b2a4      	uxth	r4, r4
    mem2 = (struct mem *)(void *)&ram[ptr2];
 8005860:	191a      	adds	r2, r3, r4
    if (mem2 < lfree) {
 8005862:	4282      	cmp	r2, r0
 8005864:	d3f1      	bcc.n	800584a <mem_trim+0x72>
    }
    mem2->used = 0;
 8005866:	2000      	movs	r0, #0
 8005868:	7110      	strb	r0, [r2, #4]
    mem2->next = mem->next;
 800586a:	5319      	strh	r1, [r3, r4]
    mem2->prev = ptr;
 800586c:	8056      	strh	r6, [r2, #2]
    mem->next = ptr2;
 800586e:	f825 4c08 	strh.w	r4, [r5, #-8]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8005872:	5b1a      	ldrh	r2, [r3, r4]
 8005874:	f5b2 6fc8 	cmp.w	r2, #1600	; 0x640
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 8005878:	bf1c      	itt	ne
 800587a:	189b      	addne	r3, r3, r2
 800587c:	805c      	strhne	r4, [r3, #2]
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 800587e:	4804      	ldr	r0, [pc, #16]	; (8005890 <mem_trim+0xb8>)
 8005880:	f003 fc8b 	bl	800919a <sys_mutex_unlock>
  return rmem;
}
 8005884:	4628      	mov	r0, r5
 8005886:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800588a:	bf00      	nop
 800588c:	20003dcc 	.word	0x20003dcc
 8005890:	20003dd8 	.word	0x20003dd8

08005894 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
 8005894:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
 8005898:	b148      	cbz	r0, 80058ae <mem_malloc+0x1a>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
 800589a:	3003      	adds	r0, #3
 800589c:	f64f 74fc 	movw	r4, #65532	; 0xfffc
 80058a0:	4004      	ands	r4, r0

  if (size < MIN_SIZE_ALIGNED) {
 80058a2:	2c0b      	cmp	r4, #11
 80058a4:	d905      	bls.n	80058b2 <mem_malloc+0x1e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
 80058a6:	f5b4 6fc8 	cmp.w	r4, #1600	; 0x640
 80058aa:	d903      	bls.n	80058b4 <mem_malloc+0x20>
    return NULL;
 80058ac:	2000      	movs	r0, #0
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
}
 80058ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    size = MIN_SIZE_ALIGNED;
 80058b2:	240c      	movs	r4, #12
  sys_mutex_lock(&mem_mutex);
 80058b4:	4d26      	ldr	r5, [pc, #152]	; (8005950 <mem_malloc+0xbc>)
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 80058b6:	f06f 0807 	mvn.w	r8, #7
  sys_mutex_lock(&mem_mutex);
 80058ba:	f105 000c 	add.w	r0, r5, #12
 80058be:	f003 fc69 	bl	8009194 <sys_mutex_lock>
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 80058c2:	68ae      	ldr	r6, [r5, #8]
 80058c4:	682a      	ldr	r2, [r5, #0]
 80058c6:	4628      	mov	r0, r5
 80058c8:	f5c4 6cc8 	rsb	ip, r4, #1600	; 0x640
 80058cc:	1ab3      	subs	r3, r6, r2
 80058ce:	b29b      	uxth	r3, r3
 80058d0:	4563      	cmp	r3, ip
 80058d2:	d303      	bcc.n	80058dc <mem_malloc+0x48>
  sys_mutex_unlock(&mem_mutex);
 80058d4:	481f      	ldr	r0, [pc, #124]	; (8005954 <mem_malloc+0xc0>)
 80058d6:	f003 fc60 	bl	800919a <sys_mutex_unlock>
 80058da:	e7e7      	b.n	80058ac <mem_malloc+0x18>
      mem = (struct mem *)(void *)&ram[ptr];
 80058dc:	18d5      	adds	r5, r2, r3
 80058de:	5ad7      	ldrh	r7, [r2, r3]
      if ((!mem->used) &&
 80058e0:	f895 e004 	ldrb.w	lr, [r5, #4]
 80058e4:	f1be 0f00 	cmp.w	lr, #0
 80058e8:	d130      	bne.n	800594c <mem_malloc+0xb8>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 80058ea:	eba8 0103 	sub.w	r1, r8, r3
 80058ee:	4439      	add	r1, r7
      if ((!mem->used) &&
 80058f0:	428c      	cmp	r4, r1
 80058f2:	d82b      	bhi.n	800594c <mem_malloc+0xb8>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 80058f4:	f104 0c14 	add.w	ip, r4, #20
 80058f8:	4561      	cmp	r1, ip
 80058fa:	d321      	bcc.n	8005940 <mem_malloc+0xac>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 80058fc:	3408      	adds	r4, #8
 80058fe:	441c      	add	r4, r3
 8005900:	b2a4      	uxth	r4, r4
          mem2 = (struct mem *)(void *)&ram[ptr2];
 8005902:	1911      	adds	r1, r2, r4
          mem2->used = 0;
 8005904:	f881 e004 	strb.w	lr, [r1, #4]
          mem2->next = mem->next;
 8005908:	5317      	strh	r7, [r2, r4]
          mem2->prev = ptr;
 800590a:	804b      	strh	r3, [r1, #2]
          mem->used = 1;
 800590c:	2301      	movs	r3, #1
          mem->next = ptr2;
 800590e:	802c      	strh	r4, [r5, #0]
          mem->used = 1;
 8005910:	712b      	strb	r3, [r5, #4]
          if (mem2->next != MEM_SIZE_ALIGNED) {
 8005912:	5b13      	ldrh	r3, [r2, r4]
 8005914:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 8005918:	d001      	beq.n	800591e <mem_malloc+0x8a>
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 800591a:	441a      	add	r2, r3
 800591c:	8054      	strh	r4, [r2, #2]
        if (mem == lfree) {
 800591e:	42ae      	cmp	r6, r5
 8005920:	d107      	bne.n	8005932 <mem_malloc+0x9e>
            cur = (struct mem *)(void *)&ram[cur->next];
 8005922:	462b      	mov	r3, r5
 8005924:	e890 0006 	ldmia.w	r0, {r1, r2}
          while (cur->used && cur != ram_end) {
 8005928:	791c      	ldrb	r4, [r3, #4]
 800592a:	b10c      	cbz	r4, 8005930 <mem_malloc+0x9c>
 800592c:	4293      	cmp	r3, r2
 800592e:	d10a      	bne.n	8005946 <mem_malloc+0xb2>
          lfree = cur;
 8005930:	6083      	str	r3, [r0, #8]
        sys_mutex_unlock(&mem_mutex);
 8005932:	4808      	ldr	r0, [pc, #32]	; (8005954 <mem_malloc+0xc0>)
 8005934:	f003 fc31 	bl	800919a <sys_mutex_unlock>
        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 8005938:	f105 0008 	add.w	r0, r5, #8
 800593c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          mem->used = 1;
 8005940:	2301      	movs	r3, #1
 8005942:	712b      	strb	r3, [r5, #4]
 8005944:	e7eb      	b.n	800591e <mem_malloc+0x8a>
            cur = (struct mem *)(void *)&ram[cur->next];
 8005946:	881b      	ldrh	r3, [r3, #0]
 8005948:	440b      	add	r3, r1
 800594a:	e7ed      	b.n	8005928 <mem_malloc+0x94>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
 800594c:	463b      	mov	r3, r7
 800594e:	e7bf      	b.n	80058d0 <mem_malloc+0x3c>
 8005950:	20003dcc 	.word	0x20003dcc
 8005954:	20003dd8 	.word	0x20003dd8

08005958 <memp_init_pool>:
{
  int i;
  struct memp *memp;
  
  *desc->tab = NULL;
  memp = (struct memp*)LWIP_MEM_ALIGN(desc->base);
 8005958:	6843      	ldr	r3, [r0, #4]
  *desc->tab = NULL;
 800595a:	2200      	movs	r2, #0
 800595c:	6881      	ldr	r1, [r0, #8]
  memp = (struct memp*)LWIP_MEM_ALIGN(desc->base);
 800595e:	3303      	adds	r3, #3
{
 8005960:	b530      	push	{r4, r5, lr}
  memp = (struct memp*)LWIP_MEM_ALIGN(desc->base);
 8005962:	f023 0303 	bic.w	r3, r3, #3
  /* create a linked list of memp elements */
  for (i = 0; i < desc->num; ++i) {
 8005966:	8844      	ldrh	r4, [r0, #2]
  *desc->tab = NULL;
 8005968:	600a      	str	r2, [r1, #0]
  for (i = 0; i < desc->num; ++i) {
 800596a:	42a2      	cmp	r2, r4
 800596c:	db00      	blt.n	8005970 <memp_init_pool+0x18>
  }  

#if MEMP_OVERFLOW_CHECK
  memp_overflow_init(desc);
#endif /* MEMP_OVERFLOW_CHECK */
}
 800596e:	bd30      	pop	{r4, r5, pc}
    memp->next = *desc->tab;
 8005970:	680d      	ldr	r5, [r1, #0]
  for (i = 0; i < desc->num; ++i) {
 8005972:	3201      	adds	r2, #1
    memp->next = *desc->tab;
 8005974:	601d      	str	r5, [r3, #0]
    memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc->size
 8005976:	8805      	ldrh	r5, [r0, #0]
    *desc->tab = memp;
 8005978:	600b      	str	r3, [r1, #0]
    memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc->size
 800597a:	442b      	add	r3, r5
 800597c:	e7f5      	b.n	800596a <memp_init_pool+0x12>
	...

08005980 <memp_init>:
 *
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
 8005980:	b538      	push	{r3, r4, r5, lr}
 8005982:	2400      	movs	r4, #0
    MEMP_STATS_AVAIL(avail, i, memp_pools[i]->num);
  }

  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_init_pool(memp_pools[i]);
 8005984:	4d04      	ldr	r5, [pc, #16]	; (8005998 <memp_init+0x18>)
 8005986:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 800598a:	3401      	adds	r4, #1
 800598c:	f7ff ffe4 	bl	8005958 <memp_init_pool>
  for (i = 0; i < MEMP_MAX; ++i) {
 8005990:	2c0d      	cmp	r4, #13
 8005992:	d1f8      	bne.n	8005986 <memp_init+0x6>

#if MEMP_OVERFLOW_CHECK
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
 8005994:	bd38      	pop	{r3, r4, r5, pc}
 8005996:	bf00      	nop
 8005998:	20000008 	.word	0x20000008

0800599c <memp_malloc_pool>:
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  SYS_ARCH_PROTECT(old_level);

  memp = *desc->tab;
 800599c:	6883      	ldr	r3, [r0, #8]
 800599e:	6818      	ldr	r0, [r3, #0]
#if MEMP_OVERFLOW_CHECK == 1
  memp_overflow_check_element_overflow(memp, desc);
  memp_overflow_check_element_underflow(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */

  if (memp != NULL) {
 80059a0:	b108      	cbz	r0, 80059a6 <memp_malloc_pool+0xa>
    *desc->tab = memp->next;
 80059a2:	6802      	ldr	r2, [r0, #0]
 80059a4:	601a      	str	r2, [r3, #0]
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
 80059a6:	4770      	bx	lr

080059a8 <memp_malloc>:
#endif
{
  void *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 80059a8:	280c      	cmp	r0, #12
 80059aa:	d804      	bhi.n	80059b6 <memp_malloc+0xe>
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

#if !MEMP_OVERFLOW_CHECK
  memp = memp_malloc_pool(memp_pools[type]);
 80059ac:	4b03      	ldr	r3, [pc, #12]	; (80059bc <memp_malloc+0x14>)
 80059ae:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 80059b2:	f7ff bff3 	b.w	800599c <memp_malloc_pool>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
 80059b6:	2000      	movs	r0, #0
 80059b8:	4770      	bx	lr
 80059ba:	bf00      	nop
 80059bc:	20000008 	.word	0x20000008

080059c0 <memp_free>:
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  struct memp *old_first;
#endif
  SYS_ARCH_DECL_PROTECT(old_level);

  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 80059c0:	280c      	cmp	r0, #12
 80059c2:	d806      	bhi.n	80059d2 <memp_free+0x12>
  MEMP_STATS_DEC(used, type);

#ifdef LWIP_HOOK_MEMP_AVAILABLE
  do_memp_free_pool(memp_pools[type], mem, &old_first);
#else
  do_memp_free_pool(memp_pools[type], mem);
 80059c4:	4b03      	ldr	r3, [pc, #12]	; (80059d4 <memp_free+0x14>)
 80059c6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80059ca:	689b      	ldr	r3, [r3, #8]
  memp->next = *desc->tab;
 80059cc:	681a      	ldr	r2, [r3, #0]
 80059ce:	600a      	str	r2, [r1, #0]
  *desc->tab = memp;
 80059d0:	6019      	str	r1, [r3, #0]
 80059d2:	4770      	bx	lr
 80059d4:	20000008 	.word	0x20000008

080059d8 <netif_issue_reports.part.0>:
#if LWIP_IPV4
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
      !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
#if LWIP_ARP
    /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */
    if (netif->flags & (NETIF_FLAG_ETHARP)) {
 80059d8:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
netif_issue_reports(struct netif* netif, u8_t report_type)
 80059dc:	4601      	mov	r1, r0
    if (netif->flags & (NETIF_FLAG_ETHARP)) {
 80059de:	071b      	lsls	r3, r3, #28
 80059e0:	d502      	bpl.n	80059e8 <netif_issue_reports.part.0+0x10>
      etharp_gratuitous(netif);
 80059e2:	3104      	adds	r1, #4
 80059e4:	f003 b8ca 	b.w	8008b7c <etharp_request>
 80059e8:	4770      	bx	lr

080059ea <netif_init>:
{
 80059ea:	4770      	bx	lr

080059ec <netif_set_ipaddr>:
{
 80059ec:	b570      	push	{r4, r5, r6, lr}
 80059ee:	4605      	mov	r5, r0
  ip4_addr_t new_addr = (ipaddr ? *ipaddr : *IP4_ADDR_ANY);
 80059f0:	460c      	mov	r4, r1
 80059f2:	b1a9      	cbz	r1, 8005a20 <netif_set_ipaddr+0x34>
 80059f4:	680b      	ldr	r3, [r1, #0]
  if (ip4_addr_cmp(&new_addr, netif_ip4_addr(netif)) == 0) {
 80059f6:	686a      	ldr	r2, [r5, #4]
 80059f8:	4293      	cmp	r3, r2
 80059fa:	d014      	beq.n	8005a26 <netif_set_ipaddr+0x3a>
    tcp_netif_ipv4_addr_changed(netif_ip4_addr(netif), ipaddr);
 80059fc:	1d2e      	adds	r6, r5, #4
 80059fe:	4621      	mov	r1, r4
 8005a00:	4630      	mov	r0, r6
 8005a02:	f001 f87b 	bl	8006afc <tcp_netif_ipv4_addr_changed>
    udp_netif_ipv4_addr_changed(netif_ip4_addr(netif), ipaddr);
 8005a06:	4621      	mov	r1, r4
 8005a08:	4630      	mov	r0, r6
 8005a0a:	f002 ffb5 	bl	8008978 <udp_netif_ipv4_addr_changed>
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
 8005a0e:	b104      	cbz	r4, 8005a12 <netif_set_ipaddr+0x26>
 8005a10:	6824      	ldr	r4, [r4, #0]
 8005a12:	606c      	str	r4, [r5, #4]
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
 8005a14:	b13c      	cbz	r4, 8005a26 <netif_set_ipaddr+0x3a>
 8005a16:	4628      	mov	r0, r5
}
 8005a18:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8005a1c:	f7ff bfdc 	b.w	80059d8 <netif_issue_reports.part.0>
  ip4_addr_t new_addr = (ipaddr ? *ipaddr : *IP4_ADDR_ANY);
 8005a20:	4b01      	ldr	r3, [pc, #4]	; (8005a28 <netif_set_ipaddr+0x3c>)
 8005a22:	681b      	ldr	r3, [r3, #0]
 8005a24:	e7e7      	b.n	80059f6 <netif_set_ipaddr+0xa>
 8005a26:	bd70      	pop	{r4, r5, r6, pc}
 8005a28:	08009c70 	.word	0x08009c70

08005a2c <netif_set_addr>:
  ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
 8005a2c:	b102      	cbz	r2, 8005a30 <netif_set_addr+0x4>
 8005a2e:	6812      	ldr	r2, [r2, #0]
 8005a30:	6082      	str	r2, [r0, #8]
  ip4_addr_set(ip_2_ip4(&netif->gw), gw);
 8005a32:	b103      	cbz	r3, 8005a36 <netif_set_addr+0xa>
 8005a34:	681b      	ldr	r3, [r3, #0]
 8005a36:	60c3      	str	r3, [r0, #12]
  netif_set_ipaddr(netif, ipaddr);
 8005a38:	f7ff bfd8 	b.w	80059ec <netif_set_ipaddr>

08005a3c <netif_add>:
{
 8005a3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  netif->rs_count = LWIP_ND6_MAX_MULTICAST_SOLICIT;
 8005a3e:	2603      	movs	r6, #3
  netif->num = netif_num++;
 8005a40:	4f11      	ldr	r7, [pc, #68]	; (8005a88 <netif_add+0x4c>)
  ip_addr_set_zero_ip4(&netif->ip_addr);
 8005a42:	2500      	movs	r5, #0
{
 8005a44:	4604      	mov	r4, r0
  netif->rs_count = LWIP_ND6_MAX_MULTICAST_SOLICIT;
 8005a46:	f880 6020 	strb.w	r6, [r0, #32]
  netif->state = state;
 8005a4a:	9e06      	ldr	r6, [sp, #24]
  ip_addr_set_zero_ip4(&netif->ip_addr);
 8005a4c:	6045      	str	r5, [r0, #4]
  netif->state = state;
 8005a4e:	61c6      	str	r6, [r0, #28]
  netif->num = netif_num++;
 8005a50:	783e      	ldrb	r6, [r7, #0]
  ip_addr_set_zero_ip4(&netif->netmask);
 8005a52:	6085      	str	r5, [r0, #8]
  netif->num = netif_num++;
 8005a54:	f106 0e01 	add.w	lr, r6, #1
 8005a58:	f880 602e 	strb.w	r6, [r0, #46]	; 0x2e
  netif->input = input;
 8005a5c:	9e08      	ldr	r6, [sp, #32]
  ip_addr_set_zero_ip4(&netif->gw);
 8005a5e:	60c5      	str	r5, [r0, #12]
  netif->flags = 0;
 8005a60:	f880 502b 	strb.w	r5, [r0, #43]	; 0x2b
  netif->input = input;
 8005a64:	6106      	str	r6, [r0, #16]
  netif->num = netif_num++;
 8005a66:	f887 e000 	strb.w	lr, [r7]
  netif_set_addr(netif, ipaddr, netmask, gw);
 8005a6a:	f7ff ffdf 	bl	8005a2c <netif_set_addr>
  if (init(netif) != ERR_OK) {
 8005a6e:	4620      	mov	r0, r4
 8005a70:	9b07      	ldr	r3, [sp, #28]
 8005a72:	4798      	blx	r3
 8005a74:	b928      	cbnz	r0, 8005a82 <netif_add+0x46>
  netif->next = netif_list;
 8005a76:	4b05      	ldr	r3, [pc, #20]	; (8005a8c <netif_add+0x50>)
 8005a78:	681a      	ldr	r2, [r3, #0]
 8005a7a:	6022      	str	r2, [r4, #0]
  netif_list = netif;
 8005a7c:	601c      	str	r4, [r3, #0]
}
 8005a7e:	4620      	mov	r0, r4
 8005a80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return NULL;
 8005a82:	462c      	mov	r4, r5
 8005a84:	e7fb      	b.n	8005a7e <netif_add+0x42>
 8005a86:	bf00      	nop
 8005a88:	20003e10 	.word	0x20003e10
 8005a8c:	20007658 	.word	0x20007658

08005a90 <netif_set_default>:
  netif_default = netif;
 8005a90:	4b01      	ldr	r3, [pc, #4]	; (8005a98 <netif_set_default+0x8>)
 8005a92:	6018      	str	r0, [r3, #0]
 8005a94:	4770      	bx	lr
 8005a96:	bf00      	nop
 8005a98:	2000765c 	.word	0x2000765c

08005a9c <netif_set_up>:
  if (!(netif->flags & NETIF_FLAG_UP)) {
 8005a9c:	f890 202b 	ldrb.w	r2, [r0, #43]	; 0x2b
 8005aa0:	07d1      	lsls	r1, r2, #31
 8005aa2:	d409      	bmi.n	8005ab8 <netif_set_up+0x1c>
    netif->flags |= NETIF_FLAG_UP;
 8005aa4:	f042 0101 	orr.w	r1, r2, #1
    if (netif->flags & NETIF_FLAG_LINK_UP) {
 8005aa8:	0752      	lsls	r2, r2, #29
    netif->flags |= NETIF_FLAG_UP;
 8005aaa:	f880 102b 	strb.w	r1, [r0, #43]	; 0x2b
    if (netif->flags & NETIF_FLAG_LINK_UP) {
 8005aae:	d503      	bpl.n	8005ab8 <netif_set_up+0x1c>
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
 8005ab0:	6843      	ldr	r3, [r0, #4]
 8005ab2:	b10b      	cbz	r3, 8005ab8 <netif_set_up+0x1c>
 8005ab4:	f7ff bf90 	b.w	80059d8 <netif_issue_reports.part.0>
 8005ab8:	4770      	bx	lr

08005aba <netif_set_down>:
 * Bring an interface down, disabling any traffic processing.
 */
void
netif_set_down(struct netif *netif)
{
  if (netif->flags & NETIF_FLAG_UP) {
 8005aba:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
 8005abe:	07d9      	lsls	r1, r3, #31
 8005ac0:	d507      	bpl.n	8005ad2 <netif_set_down+0x18>
    netif->flags &= ~NETIF_FLAG_UP;
 8005ac2:	f023 0101 	bic.w	r1, r3, #1
    MIB2_COPY_SYSUPTIME_TO(&netif->ts);

#if LWIP_IPV4 && LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
 8005ac6:	071b      	lsls	r3, r3, #28
    netif->flags &= ~NETIF_FLAG_UP;
 8005ac8:	f880 102b 	strb.w	r1, [r0, #43]	; 0x2b
    if (netif->flags & NETIF_FLAG_ETHARP) {
 8005acc:	d501      	bpl.n	8005ad2 <netif_set_down+0x18>
      etharp_cleanup_netif(netif);
 8005ace:	f003 b841 	b.w	8008b54 <etharp_cleanup_netif>
 8005ad2:	4770      	bx	lr

08005ad4 <pbuf_free_ooseq_callback>:
#endif /* !NO_SYS */
void
pbuf_free_ooseq(void)
{
  struct tcp_pcb* pcb;
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 0);
 8005ad4:	4b08      	ldr	r3, [pc, #32]	; (8005af8 <pbuf_free_ooseq_callback+0x24>)
 8005ad6:	2200      	movs	r2, #0
/**
 * Just a callback function for tcpip_callback() that calls pbuf_free_ooseq().
 */
static void
pbuf_free_ooseq_callback(void *arg)
{
 8005ad8:	b510      	push	{r4, lr}
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 0);
 8005ada:	701a      	strb	r2, [r3, #0]
  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 8005adc:	4b07      	ldr	r3, [pc, #28]	; (8005afc <pbuf_free_ooseq_callback+0x28>)
 8005ade:	681c      	ldr	r4, [r3, #0]
 8005ae0:	b904      	cbnz	r4, 8005ae4 <pbuf_free_ooseq_callback+0x10>
 8005ae2:	bd10      	pop	{r4, pc}
    if (NULL != pcb->ooseq) {
 8005ae4:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8005ae6:	b120      	cbz	r0, 8005af2 <pbuf_free_ooseq_callback+0x1e>
      tcp_segs_free(pcb->ooseq);
 8005ae8:	f000 faf2 	bl	80060d0 <tcp_segs_free>
      pcb->ooseq = NULL;
 8005aec:	2300      	movs	r3, #0
 8005aee:	6763      	str	r3, [r4, #116]	; 0x74
 8005af0:	bd10      	pop	{r4, pc}
  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 8005af2:	68e4      	ldr	r4, [r4, #12]
 8005af4:	e7f4      	b.n	8005ae0 <pbuf_free_ooseq_callback+0xc>
 8005af6:	bf00      	nop
 8005af8:	20007660 	.word	0x20007660
 8005afc:	20007668 	.word	0x20007668

08005b00 <pbuf_header_impl.part.0>:
  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL)) {
    return 0;
  }

  if (header_size_increment < 0) {
 8005b00:	2900      	cmp	r1, #0
pbuf_header_impl(struct pbuf *p, s16_t header_size_increment, u8_t force)
 8005b02:	b530      	push	{r4, r5, lr}
  if (header_size_increment < 0) {
 8005b04:	da06      	bge.n	8005b14 <pbuf_header_impl.part.0+0x14>
    increment_magnitude = -header_size_increment;
 8005b06:	424c      	negs	r4, r1
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 8005b08:	8943      	ldrh	r3, [r0, #10]
    increment_magnitude = -header_size_increment;
 8005b0a:	b2a4      	uxth	r4, r4
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 8005b0c:	42a3      	cmp	r3, r4
 8005b0e:	d202      	bcs.n	8005b16 <pbuf_header_impl.part.0+0x16>
 8005b10:	2001      	movs	r0, #1

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
 8005b12:	bd30      	pop	{r4, r5, pc}
    increment_magnitude = header_size_increment;
 8005b14:	b28c      	uxth	r4, r1
  type = p->type;
 8005b16:	7b05      	ldrb	r5, [r0, #12]
  payload = p->payload;
 8005b18:	6843      	ldr	r3, [r0, #4]
  if (type == PBUF_RAM || type == PBUF_POOL) {
 8005b1a:	b10d      	cbz	r5, 8005b20 <pbuf_header_impl.part.0+0x20>
 8005b1c:	2d03      	cmp	r5, #3
 8005b1e:	d10e      	bne.n	8005b3e <pbuf_header_impl.part.0+0x3e>
    p->payload = (u8_t *)p->payload - header_size_increment;
 8005b20:	1a5b      	subs	r3, r3, r1
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 8005b22:	f100 0210 	add.w	r2, r0, #16
 8005b26:	4293      	cmp	r3, r2
 8005b28:	d3f2      	bcc.n	8005b10 <pbuf_header_impl.part.0+0x10>
      p->payload = (u8_t *)p->payload - header_size_increment;
 8005b2a:	6043      	str	r3, [r0, #4]
  p->len += header_size_increment;
 8005b2c:	b289      	uxth	r1, r1
 8005b2e:	8943      	ldrh	r3, [r0, #10]
 8005b30:	440b      	add	r3, r1
 8005b32:	8143      	strh	r3, [r0, #10]
  p->tot_len += header_size_increment;
 8005b34:	8903      	ldrh	r3, [r0, #8]
 8005b36:	4419      	add	r1, r3
 8005b38:	8101      	strh	r1, [r0, #8]
  return 0;
 8005b3a:	2000      	movs	r0, #0
 8005b3c:	bd30      	pop	{r4, r5, pc}
  } else if (type == PBUF_REF || type == PBUF_ROM) {
 8005b3e:	3d01      	subs	r5, #1
 8005b40:	2d01      	cmp	r5, #1
 8005b42:	d8e5      	bhi.n	8005b10 <pbuf_header_impl.part.0+0x10>
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 8005b44:	2900      	cmp	r1, #0
 8005b46:	da04      	bge.n	8005b52 <pbuf_header_impl.part.0+0x52>
 8005b48:	8942      	ldrh	r2, [r0, #10]
 8005b4a:	42a2      	cmp	r2, r4
 8005b4c:	d3e0      	bcc.n	8005b10 <pbuf_header_impl.part.0+0x10>
      p->payload = (u8_t *)p->payload - header_size_increment;
 8005b4e:	1a5b      	subs	r3, r3, r1
 8005b50:	e7eb      	b.n	8005b2a <pbuf_header_impl.part.0+0x2a>
    } else if ((header_size_increment > 0) && force) {
 8005b52:	d0dd      	beq.n	8005b10 <pbuf_header_impl.part.0+0x10>
 8005b54:	2a00      	cmp	r2, #0
 8005b56:	d1fa      	bne.n	8005b4e <pbuf_header_impl.part.0+0x4e>
 8005b58:	e7da      	b.n	8005b10 <pbuf_header_impl.part.0+0x10>
	...

08005b5c <pbuf_pool_is_empty>:
{
 8005b5c:	b538      	push	{r3, r4, r5, lr}
  queued = pbuf_free_ooseq_pending;
 8005b5e:	4c07      	ldr	r4, [pc, #28]	; (8005b7c <pbuf_pool_is_empty+0x20>)
  pbuf_free_ooseq_pending = 1;
 8005b60:	2201      	movs	r2, #1
  queued = pbuf_free_ooseq_pending;
 8005b62:	7823      	ldrb	r3, [r4, #0]
  pbuf_free_ooseq_pending = 1;
 8005b64:	7022      	strb	r2, [r4, #0]
  if (!queued) {
 8005b66:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 8005b6a:	b933      	cbnz	r3, 8005b7a <pbuf_pool_is_empty+0x1e>
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
 8005b6c:	462a      	mov	r2, r5
 8005b6e:	4629      	mov	r1, r5
 8005b70:	4803      	ldr	r0, [pc, #12]	; (8005b80 <pbuf_pool_is_empty+0x24>)
 8005b72:	f7fe ffd1 	bl	8004b18 <tcpip_callback_with_block>
 8005b76:	b100      	cbz	r0, 8005b7a <pbuf_pool_is_empty+0x1e>
 8005b78:	7025      	strb	r5, [r4, #0]
 8005b7a:	bd38      	pop	{r3, r4, r5, pc}
 8005b7c:	20007660 	.word	0x20007660
 8005b80:	08005ad5 	.word	0x08005ad5

08005b84 <pbuf_alloced_custom>:
{
 8005b84:	b570      	push	{r4, r5, r6, lr}
 8005b86:	9d04      	ldr	r5, [sp, #16]
  switch (l) {
 8005b88:	2804      	cmp	r0, #4
 8005b8a:	d824      	bhi.n	8005bd6 <pbuf_alloced_custom+0x52>
 8005b8c:	e8df f000 	tbb	[pc, r0]
 8005b90:	1d1b031f 	.word	0x1d1b031f
 8005b94:	1d          	.byte	0x1d
 8005b95:	00          	.byte	0x00
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN;
 8005b96:	2422      	movs	r4, #34	; 0x22
  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
 8005b98:	3403      	adds	r4, #3
 8005b9a:	f8bd 0014 	ldrh.w	r0, [sp, #20]
 8005b9e:	f024 0403 	bic.w	r4, r4, #3
 8005ba2:	190e      	adds	r6, r1, r4
 8005ba4:	4286      	cmp	r6, r0
 8005ba6:	f04f 0000 	mov.w	r0, #0
 8005baa:	d815      	bhi.n	8005bd8 <pbuf_alloced_custom+0x54>
  p->pbuf.next = NULL;
 8005bac:	6018      	str	r0, [r3, #0]
  if (payload_mem != NULL) {
 8005bae:	b185      	cbz	r5, 8005bd2 <pbuf_alloced_custom+0x4e>
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
 8005bb0:	442c      	add	r4, r5
 8005bb2:	605c      	str	r4, [r3, #4]
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
 8005bb4:	2002      	movs	r0, #2
  p->pbuf.type = type;
 8005bb6:	731a      	strb	r2, [r3, #12]
  p->pbuf.ref = 1;
 8005bb8:	2201      	movs	r2, #1
  p->pbuf.len = p->pbuf.tot_len = length;
 8005bba:	8119      	strh	r1, [r3, #8]
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
 8005bbc:	7358      	strb	r0, [r3, #13]
  return &p->pbuf;
 8005bbe:	4618      	mov	r0, r3
  p->pbuf.len = p->pbuf.tot_len = length;
 8005bc0:	8159      	strh	r1, [r3, #10]
  p->pbuf.ref = 1;
 8005bc2:	81da      	strh	r2, [r3, #14]
  return &p->pbuf;
 8005bc4:	bd70      	pop	{r4, r5, r6, pc}
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
 8005bc6:	240e      	movs	r4, #14
    break;
 8005bc8:	e7e6      	b.n	8005b98 <pbuf_alloced_custom+0x14>
    offset = 0;
 8005bca:	2400      	movs	r4, #0
    break;
 8005bcc:	e7e4      	b.n	8005b98 <pbuf_alloced_custom+0x14>
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 8005bce:	2436      	movs	r4, #54	; 0x36
 8005bd0:	e7e2      	b.n	8005b98 <pbuf_alloced_custom+0x14>
    p->pbuf.payload = NULL;
 8005bd2:	605d      	str	r5, [r3, #4]
 8005bd4:	e7ee      	b.n	8005bb4 <pbuf_alloced_custom+0x30>
    return NULL;
 8005bd6:	2000      	movs	r0, #0
}
 8005bd8:	bd70      	pop	{r4, r5, r6, pc}

08005bda <pbuf_header>:
  if ((header_size_increment == 0) || (p == NULL)) {
 8005bda:	b119      	cbz	r1, 8005be4 <pbuf_header+0xa>
 8005bdc:	b110      	cbz	r0, 8005be4 <pbuf_header+0xa>
 8005bde:	2200      	movs	r2, #0
 8005be0:	f7ff bf8e 	b.w	8005b00 <pbuf_header_impl.part.0>
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
   return pbuf_header_impl(p, header_size_increment, 0);
}
 8005be4:	2000      	movs	r0, #0
 8005be6:	4770      	bx	lr

08005be8 <pbuf_header_force>:
  if ((header_size_increment == 0) || (p == NULL)) {
 8005be8:	b119      	cbz	r1, 8005bf2 <pbuf_header_force+0xa>
 8005bea:	b110      	cbz	r0, 8005bf2 <pbuf_header_force+0xa>
 8005bec:	2201      	movs	r2, #1
 8005bee:	f7ff bf87 	b.w	8005b00 <pbuf_header_impl.part.0>
 */
u8_t
pbuf_header_force(struct pbuf *p, s16_t header_size_increment)
{
   return pbuf_header_impl(p, header_size_increment, 1);
}
 8005bf2:	2000      	movs	r0, #0
 8005bf4:	4770      	bx	lr

08005bf6 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 8005bf6:	b538      	push	{r3, r4, r5, lr}
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 8005bf8:	4601      	mov	r1, r0
 8005bfa:	b310      	cbz	r0, 8005c42 <pbuf_free+0x4c>
 8005bfc:	2400      	movs	r4, #0
 8005bfe:	b2e0      	uxtb	r0, r4
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 8005c00:	b901      	cbnz	r1, 8005c04 <pbuf_free+0xe>
 8005c02:	bd38      	pop	{r3, r4, r5, pc}
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
 8005c04:	89cb      	ldrh	r3, [r1, #14]
 8005c06:	3b01      	subs	r3, #1
 8005c08:	b29b      	uxth	r3, r3
 8005c0a:	81cb      	strh	r3, [r1, #14]
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 8005c0c:	b9cb      	cbnz	r3, 8005c42 <pbuf_free+0x4c>
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 8005c0e:	7b4b      	ldrb	r3, [r1, #13]
      q = p->next;
 8005c10:	680d      	ldr	r5, [r1, #0]
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 8005c12:	079b      	lsls	r3, r3, #30
 8005c14:	d505      	bpl.n	8005c22 <pbuf_free+0x2c>
        struct pbuf_custom *pc = (struct pbuf_custom*)p;
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
        pc->custom_free_function(p);
 8005c16:	690b      	ldr	r3, [r1, #16]
 8005c18:	4608      	mov	r0, r1
 8005c1a:	4798      	blx	r3
 8005c1c:	3401      	adds	r4, #1
          mem_free(p);
        }
      }
      count++;
      /* proceed to next pbuf */
      p = q;
 8005c1e:	4629      	mov	r1, r5
 8005c20:	e7ed      	b.n	8005bfe <pbuf_free+0x8>
      type = p->type;
 8005c22:	7b0b      	ldrb	r3, [r1, #12]
        if (type == PBUF_POOL) {
 8005c24:	2b03      	cmp	r3, #3
 8005c26:	d103      	bne.n	8005c30 <pbuf_free+0x3a>
          memp_free(MEMP_PBUF_POOL, p);
 8005c28:	200c      	movs	r0, #12
          memp_free(MEMP_PBUF, p);
 8005c2a:	f7ff fec9 	bl	80059c0 <memp_free>
 8005c2e:	e7f5      	b.n	8005c1c <pbuf_free+0x26>
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 8005c30:	3b01      	subs	r3, #1
 8005c32:	2b01      	cmp	r3, #1
 8005c34:	d801      	bhi.n	8005c3a <pbuf_free+0x44>
          memp_free(MEMP_PBUF, p);
 8005c36:	200b      	movs	r0, #11
 8005c38:	e7f7      	b.n	8005c2a <pbuf_free+0x34>
          mem_free(p);
 8005c3a:	4608      	mov	r0, r1
 8005c3c:	f7ff fd80 	bl	8005740 <mem_free>
 8005c40:	e7ec      	b.n	8005c1c <pbuf_free+0x26>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
 8005c42:	bd38      	pop	{r3, r4, r5, pc}

08005c44 <pbuf_alloc>:
{
 8005c44:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005c48:	460e      	mov	r6, r1
 8005c4a:	4617      	mov	r7, r2
  switch (layer) {
 8005c4c:	2804      	cmp	r0, #4
 8005c4e:	d843      	bhi.n	8005cd8 <pbuf_alloc+0x94>
 8005c50:	e8df f000 	tbb	[pc, r0]
 8005c54:	0c0a030e 	.word	0x0c0a030e
 8005c58:	0c          	.byte	0x0c
 8005c59:	00          	.byte	0x00
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN;
 8005c5a:	2522      	movs	r5, #34	; 0x22
  switch (type) {
 8005c5c:	2f03      	cmp	r7, #3
 8005c5e:	d83b      	bhi.n	8005cd8 <pbuf_alloc+0x94>
 8005c60:	e8df f007 	tbb	[pc, r7]
 8005c64:	086b6b52 	.word	0x086b6b52
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
 8005c68:	250e      	movs	r5, #14
    break;
 8005c6a:	e7f7      	b.n	8005c5c <pbuf_alloc+0x18>
    offset = 0;
 8005c6c:	2500      	movs	r5, #0
    break;
 8005c6e:	e7f5      	b.n	8005c5c <pbuf_alloc+0x18>
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 8005c70:	2536      	movs	r5, #54	; 0x36
 8005c72:	e7f3      	b.n	8005c5c <pbuf_alloc+0x18>
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8005c74:	200c      	movs	r0, #12
 8005c76:	f7ff fe97 	bl	80059a8 <memp_malloc>
    if (p == NULL) {
 8005c7a:	4604      	mov	r4, r0
 8005c7c:	b920      	cbnz	r0, 8005c88 <pbuf_alloc+0x44>
      PBUF_POOL_IS_EMPTY();
 8005c7e:	f7ff ff6d 	bl	8005b5c <pbuf_pool_is_empty>
}
 8005c82:	4620      	mov	r0, r4
 8005c84:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    p->type = type;
 8005c88:	2203      	movs	r2, #3
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 8005c8a:	1943      	adds	r3, r0, r5
    p->next = NULL;
 8005c8c:	2700      	movs	r7, #0
    while (rem_len > 0) {
 8005c8e:	4681      	mov	r9, r0
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8005c90:	4415      	add	r5, r2
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 8005c92:	3313      	adds	r3, #19
      q->type = type;
 8005c94:	4690      	mov	r8, r2
    p->type = type;
 8005c96:	7302      	strb	r2, [r0, #12]
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8005c98:	f025 0503 	bic.w	r5, r5, #3
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 8005c9c:	f023 0303 	bic.w	r3, r3, #3
    p->next = NULL;
 8005ca0:	6007      	str	r7, [r0, #0]
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8005ca2:	f5c5 7514 	rsb	r5, r5, #592	; 0x250
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 8005ca6:	6043      	str	r3, [r0, #4]
    p->ref = 1;
 8005ca8:	2301      	movs	r3, #1
    p->tot_len = length;
 8005caa:	8106      	strh	r6, [r0, #8]
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8005cac:	42b5      	cmp	r5, r6
    p->ref = 1;
 8005cae:	81c3      	strh	r3, [r0, #14]
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8005cb0:	bf28      	it	cs
 8005cb2:	4635      	movcs	r5, r6
 8005cb4:	8145      	strh	r5, [r0, #10]
    rem_len = length - p->len;
 8005cb6:	1b75      	subs	r5, r6, r5
    while (rem_len > 0) {
 8005cb8:	2d00      	cmp	r5, #0
 8005cba:	dc04      	bgt.n	8005cc6 <pbuf_alloc+0x82>
  p->ref = 1;
 8005cbc:	2301      	movs	r3, #1
 8005cbe:	81e3      	strh	r3, [r4, #14]
  p->flags = 0;
 8005cc0:	2300      	movs	r3, #0
 8005cc2:	7363      	strb	r3, [r4, #13]
  return p;
 8005cc4:	e7dd      	b.n	8005c82 <pbuf_alloc+0x3e>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8005cc6:	200c      	movs	r0, #12
 8005cc8:	f7ff fe6e 	bl	80059a8 <memp_malloc>
      if (q == NULL) {
 8005ccc:	b930      	cbnz	r0, 8005cdc <pbuf_alloc+0x98>
        PBUF_POOL_IS_EMPTY();
 8005cce:	f7ff ff45 	bl	8005b5c <pbuf_pool_is_empty>
        pbuf_free(p);
 8005cd2:	4620      	mov	r0, r4
 8005cd4:	f7ff ff8f 	bl	8005bf6 <pbuf_free>
    return NULL;
 8005cd8:	2400      	movs	r4, #0
 8005cda:	e7d2      	b.n	8005c82 <pbuf_alloc+0x3e>
      q->tot_len = (u16_t)rem_len;
 8005cdc:	b2ab      	uxth	r3, r5
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 8005cde:	f100 0210 	add.w	r2, r0, #16
      q->type = type;
 8005ce2:	f880 800c 	strb.w	r8, [r0, #12]
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 8005ce6:	f5b3 7f14 	cmp.w	r3, #592	; 0x250
      q->flags = 0;
 8005cea:	7347      	strb	r7, [r0, #13]
      q->next = NULL;
 8005cec:	6007      	str	r7, [r0, #0]
      r->next = q;
 8005cee:	f8c9 0000 	str.w	r0, [r9]
      rem_len -= q->len;
 8005cf2:	4681      	mov	r9, r0
      q->tot_len = (u16_t)rem_len;
 8005cf4:	8103      	strh	r3, [r0, #8]
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 8005cf6:	bf28      	it	cs
 8005cf8:	f44f 7314 	movcs.w	r3, #592	; 0x250
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 8005cfc:	6042      	str	r2, [r0, #4]
      q->ref = 1;
 8005cfe:	2201      	movs	r2, #1
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 8005d00:	8143      	strh	r3, [r0, #10]
      rem_len -= q->len;
 8005d02:	1aed      	subs	r5, r5, r3
      q->ref = 1;
 8005d04:	81c2      	strh	r2, [r0, #14]
 8005d06:	e7d7      	b.n	8005cb8 <pbuf_alloc+0x74>
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
 8005d08:	f105 0013 	add.w	r0, r5, #19
 8005d0c:	1cf3      	adds	r3, r6, #3
 8005d0e:	f020 0003 	bic.w	r0, r0, #3
 8005d12:	f023 0303 	bic.w	r3, r3, #3
 8005d16:	4418      	add	r0, r3
 8005d18:	b280      	uxth	r0, r0
 8005d1a:	f7ff fdbb 	bl	8005894 <mem_malloc>
    if (p == NULL) {
 8005d1e:	4604      	mov	r4, r0
 8005d20:	2800      	cmp	r0, #0
 8005d22:	d0d9      	beq.n	8005cd8 <pbuf_alloc+0x94>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 8005d24:	4405      	add	r5, r0
    p->next = NULL;
 8005d26:	2300      	movs	r3, #0
    p->len = p->tot_len = length;
 8005d28:	8106      	strh	r6, [r0, #8]
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 8005d2a:	3513      	adds	r5, #19
    p->len = p->tot_len = length;
 8005d2c:	8146      	strh	r6, [r0, #10]
    p->next = NULL;
 8005d2e:	6003      	str	r3, [r0, #0]
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 8005d30:	f025 0503 	bic.w	r5, r5, #3
    p->type = type;
 8005d34:	7303      	strb	r3, [r0, #12]
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 8005d36:	6045      	str	r5, [r0, #4]
    break;
 8005d38:	e7c0      	b.n	8005cbc <pbuf_alloc+0x78>
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 8005d3a:	200b      	movs	r0, #11
 8005d3c:	f7ff fe34 	bl	80059a8 <memp_malloc>
    if (p == NULL) {
 8005d40:	4604      	mov	r4, r0
 8005d42:	2800      	cmp	r0, #0
 8005d44:	d0c8      	beq.n	8005cd8 <pbuf_alloc+0x94>
    p->payload = NULL;
 8005d46:	2300      	movs	r3, #0
    p->len = p->tot_len = length;
 8005d48:	8106      	strh	r6, [r0, #8]
 8005d4a:	8146      	strh	r6, [r0, #10]
    p->payload = NULL;
 8005d4c:	6043      	str	r3, [r0, #4]
    p->next = NULL;
 8005d4e:	6003      	str	r3, [r0, #0]
    p->type = type;
 8005d50:	7307      	strb	r7, [r0, #12]
    break;
 8005d52:	e7b3      	b.n	8005cbc <pbuf_alloc+0x78>

08005d54 <pbuf_realloc>:
{
 8005d54:	b538      	push	{r3, r4, r5, lr}
  if (new_len >= p->tot_len) {
 8005d56:	8903      	ldrh	r3, [r0, #8]
{
 8005d58:	4604      	mov	r4, r0
  if (new_len >= p->tot_len) {
 8005d5a:	428b      	cmp	r3, r1
 8005d5c:	d91b      	bls.n	8005d96 <pbuf_realloc+0x42>
 8005d5e:	460d      	mov	r5, r1
    q->tot_len += (u16_t)grow;
 8005d60:	1acb      	subs	r3, r1, r3
  while (rem_len > q->len) {
 8005d62:	8961      	ldrh	r1, [r4, #10]
 8005d64:	428d      	cmp	r5, r1
 8005d66:	d817      	bhi.n	8005d98 <pbuf_realloc+0x44>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)
 8005d68:	7b23      	ldrb	r3, [r4, #12]
 8005d6a:	b963      	cbnz	r3, 8005d86 <pbuf_realloc+0x32>
 8005d6c:	428d      	cmp	r5, r1
 8005d6e:	d00a      	beq.n	8005d86 <pbuf_realloc+0x32>
      && ((q->flags & PBUF_FLAG_IS_CUSTOM) == 0)
 8005d70:	7b63      	ldrb	r3, [r4, #13]
 8005d72:	079b      	lsls	r3, r3, #30
 8005d74:	d407      	bmi.n	8005d86 <pbuf_realloc+0x32>
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
 8005d76:	6861      	ldr	r1, [r4, #4]
 8005d78:	4620      	mov	r0, r4
 8005d7a:	1b09      	subs	r1, r1, r4
 8005d7c:	4429      	add	r1, r5
 8005d7e:	b289      	uxth	r1, r1
 8005d80:	f7ff fd2a 	bl	80057d8 <mem_trim>
 8005d84:	4604      	mov	r4, r0
  if (q->next != NULL) {
 8005d86:	6820      	ldr	r0, [r4, #0]
  q->len = rem_len;
 8005d88:	8165      	strh	r5, [r4, #10]
  q->tot_len = q->len;
 8005d8a:	8125      	strh	r5, [r4, #8]
  if (q->next != NULL) {
 8005d8c:	b108      	cbz	r0, 8005d92 <pbuf_realloc+0x3e>
    pbuf_free(q->next);
 8005d8e:	f7ff ff32 	bl	8005bf6 <pbuf_free>
  q->next = NULL;
 8005d92:	2300      	movs	r3, #0
 8005d94:	6023      	str	r3, [r4, #0]
 8005d96:	bd38      	pop	{r3, r4, r5, pc}
    q->tot_len += (u16_t)grow;
 8005d98:	8922      	ldrh	r2, [r4, #8]
    rem_len -= q->len;
 8005d9a:	1a6d      	subs	r5, r5, r1
    q->tot_len += (u16_t)grow;
 8005d9c:	441a      	add	r2, r3
    rem_len -= q->len;
 8005d9e:	b2ad      	uxth	r5, r5
    q->tot_len += (u16_t)grow;
 8005da0:	8122      	strh	r2, [r4, #8]
    q = q->next;
 8005da2:	6824      	ldr	r4, [r4, #0]
 8005da4:	e7dd      	b.n	8005d62 <pbuf_realloc+0xe>

08005da6 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
 8005da6:	4603      	mov	r3, r0
  u8_t len;

  len = 0;
  while (p != NULL) {
 8005da8:	2200      	movs	r2, #0
 8005daa:	b2d0      	uxtb	r0, r2
 8005dac:	3201      	adds	r2, #1
 8005dae:	b903      	cbnz	r3, 8005db2 <pbuf_clen+0xc>
    ++len;
    p = p->next;
  }
  return len;
}
 8005db0:	4770      	bx	lr
    p = p->next;
 8005db2:	681b      	ldr	r3, [r3, #0]
 8005db4:	e7f9      	b.n	8005daa <pbuf_clen+0x4>

08005db6 <pbuf_ref>:
void
pbuf_ref(struct pbuf *p)
{
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
 8005db6:	b110      	cbz	r0, 8005dbe <pbuf_ref+0x8>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
 8005db8:	89c3      	ldrh	r3, [r0, #14]
 8005dba:	3301      	adds	r3, #1
 8005dbc:	81c3      	strh	r3, [r0, #14]
 8005dbe:	4770      	bx	lr

08005dc0 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 8005dc0:	b510      	push	{r4, lr}
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 8005dc2:	b150      	cbz	r0, 8005dda <pbuf_cat+0x1a>
 8005dc4:	b909      	cbnz	r1, 8005dca <pbuf_cat+0xa>
 8005dc6:	bd10      	pop	{r4, pc}
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 8005dc8:	4620      	mov	r0, r4
 8005dca:	8903      	ldrh	r3, [r0, #8]
 8005dcc:	890a      	ldrh	r2, [r1, #8]
  for (p = h; p->next != NULL; p = p->next) {
 8005dce:	6804      	ldr	r4, [r0, #0]
    p->tot_len += t->tot_len;
 8005dd0:	4413      	add	r3, r2
 8005dd2:	8103      	strh	r3, [r0, #8]
  for (p = h; p->next != NULL; p = p->next) {
 8005dd4:	2c00      	cmp	r4, #0
 8005dd6:	d1f7      	bne.n	8005dc8 <pbuf_cat+0x8>
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 8005dd8:	6001      	str	r1, [r0, #0]
 8005dda:	bd10      	pop	{r4, pc}

08005ddc <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 8005ddc:	b510      	push	{r4, lr}
  pbuf_cat(h, t);
 8005dde:	f7ff ffef 	bl	8005dc0 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
 8005de2:	4608      	mov	r0, r1
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
 8005de4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  pbuf_ref(t);
 8005de8:	f7ff bfe5 	b.w	8005db6 <pbuf_ref>

08005dec <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
 8005dec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005df0:	460c      	mov	r4, r1

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 8005df2:	4605      	mov	r5, r0
 8005df4:	b918      	cbnz	r0, 8005dfe <pbuf_copy+0x12>
 8005df6:	f06f 000e 	mvn.w	r0, #14
 8005dfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005dfe:	2900      	cmp	r1, #0
 8005e00:	d0f9      	beq.n	8005df6 <pbuf_copy+0xa>
 8005e02:	8902      	ldrh	r2, [r0, #8]
 8005e04:	890b      	ldrh	r3, [r1, #8]
 8005e06:	429a      	cmp	r2, r3
 8005e08:	d3f5      	bcc.n	8005df6 <pbuf_copy+0xa>
 8005e0a:	f04f 0800 	mov.w	r8, #0
 8005e0e:	4647      	mov	r7, r8

  /* iterate through pbuf chain */
  do
  {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 8005e10:	8963      	ldrh	r3, [r4, #10]
 8005e12:	896e      	ldrh	r6, [r5, #10]
 8005e14:	eba3 0308 	sub.w	r3, r3, r8
      len = p_from->len - offset_from;
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 8005e18:	6868      	ldr	r0, [r5, #4]
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 8005e1a:	1bf6      	subs	r6, r6, r7
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 8005e1c:	6861      	ldr	r1, [r4, #4]
 8005e1e:	4438      	add	r0, r7
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 8005e20:	429e      	cmp	r6, r3
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 8005e22:	4441      	add	r1, r8
      len = p_from->len - offset_from;
 8005e24:	bfac      	ite	ge
 8005e26:	b29e      	uxthge	r6, r3
      len = p_to->len - offset_to;
 8005e28:	b2b6      	uxthlt	r6, r6
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 8005e2a:	4632      	mov	r2, r6
    offset_to += len;
 8005e2c:	4437      	add	r7, r6
    offset_from += len;
 8005e2e:	4446      	add	r6, r8
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 8005e30:	f003 fee7 	bl	8009c02 <memcpy>
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
 8005e34:	8962      	ldrh	r2, [r4, #10]
    offset_to += len;
 8005e36:	b2bf      	uxth	r7, r7
    offset_from += len;
 8005e38:	fa1f f886 	uxth.w	r8, r6
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 8005e3c:	896b      	ldrh	r3, [r5, #10]
    if (offset_from >= p_from->len) {
 8005e3e:	4542      	cmp	r2, r8
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
 8005e40:	bf9c      	itt	ls
 8005e42:	6824      	ldrls	r4, [r4, #0]
      offset_from = 0;
 8005e44:	f04f 0800 	movls.w	r8, #0
    }
    if (offset_to == p_to->len) {
 8005e48:	429f      	cmp	r7, r3
 8005e4a:	d10b      	bne.n	8005e64 <pbuf_copy+0x78>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
 8005e4c:	682d      	ldr	r5, [r5, #0]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 8005e4e:	b945      	cbnz	r5, 8005e62 <pbuf_copy+0x76>
 8005e50:	2c00      	cmp	r4, #0
 8005e52:	d1d0      	bne.n	8005df6 <pbuf_copy+0xa>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
 8005e54:	4620      	mov	r0, r4
 8005e56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 8005e5a:	f06f 0005 	mvn.w	r0, #5
 8005e5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      offset_to = 0;
 8005e62:	2700      	movs	r7, #0
    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 8005e64:	b134      	cbz	r4, 8005e74 <pbuf_copy+0x88>
 8005e66:	8962      	ldrh	r2, [r4, #10]
 8005e68:	8923      	ldrh	r3, [r4, #8]
 8005e6a:	429a      	cmp	r2, r3
 8005e6c:	d102      	bne.n	8005e74 <pbuf_copy+0x88>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 8005e6e:	6823      	ldr	r3, [r4, #0]
 8005e70:	2b00      	cmp	r3, #0
 8005e72:	d1f2      	bne.n	8005e5a <pbuf_copy+0x6e>
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 8005e74:	896a      	ldrh	r2, [r5, #10]
 8005e76:	892b      	ldrh	r3, [r5, #8]
 8005e78:	429a      	cmp	r2, r3
 8005e7a:	d102      	bne.n	8005e82 <pbuf_copy+0x96>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 8005e7c:	682b      	ldr	r3, [r5, #0]
 8005e7e:	2b00      	cmp	r3, #0
 8005e80:	d1eb      	bne.n	8005e5a <pbuf_copy+0x6e>
  } while (p_from);
 8005e82:	2c00      	cmp	r4, #0
 8005e84:	d1c4      	bne.n	8005e10 <pbuf_copy+0x24>
 8005e86:	e7e5      	b.n	8005e54 <pbuf_copy+0x68>

08005e88 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 8005e88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005e8c:	460f      	mov	r7, r1
 8005e8e:	4690      	mov	r8, r2
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 8005e90:	4606      	mov	r6, r0
 8005e92:	b320      	cbz	r0, 8005ede <pbuf_copy_partial+0x56>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 8005e94:	b329      	cbz	r1, 8005ee2 <pbuf_copy_partial+0x5a>
 8005e96:	2500      	movs	r5, #0
  if ((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 8005e98:	f1b8 0f00 	cmp.w	r8, #0
 8005e9c:	d000      	beq.n	8005ea0 <pbuf_copy_partial+0x18>
 8005e9e:	b916      	cbnz	r6, 8005ea6 <pbuf_copy_partial+0x1e>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
 8005ea0:	4628      	mov	r0, r5
 8005ea2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ((offset != 0) && (offset >= p->len)) {
 8005ea6:	b133      	cbz	r3, 8005eb6 <pbuf_copy_partial+0x2e>
 8005ea8:	8971      	ldrh	r1, [r6, #10]
 8005eaa:	428b      	cmp	r3, r1
 8005eac:	d303      	bcc.n	8005eb6 <pbuf_copy_partial+0x2e>
      offset -= p->len;
 8005eae:	1a5b      	subs	r3, r3, r1
 8005eb0:	b29b      	uxth	r3, r3
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 8005eb2:	6836      	ldr	r6, [r6, #0]
 8005eb4:	e7f0      	b.n	8005e98 <pbuf_copy_partial+0x10>
      buf_copy_len = p->len - offset;
 8005eb6:	8974      	ldrh	r4, [r6, #10]
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 8005eb8:	1978      	adds	r0, r7, r5
 8005eba:	6871      	ldr	r1, [r6, #4]
      buf_copy_len = p->len - offset;
 8005ebc:	1ae4      	subs	r4, r4, r3
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 8005ebe:	4419      	add	r1, r3
      buf_copy_len = p->len - offset;
 8005ec0:	b2a4      	uxth	r4, r4
 8005ec2:	4544      	cmp	r4, r8
 8005ec4:	bf28      	it	cs
 8005ec6:	4644      	movcs	r4, r8
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 8005ec8:	4622      	mov	r2, r4
      copied_total += buf_copy_len;
 8005eca:	4425      	add	r5, r4
      len -= buf_copy_len;
 8005ecc:	eba8 0404 	sub.w	r4, r8, r4
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 8005ed0:	f003 fe97 	bl	8009c02 <memcpy>
      copied_total += buf_copy_len;
 8005ed4:	b2ad      	uxth	r5, r5
      offset = 0;
 8005ed6:	2300      	movs	r3, #0
      len -= buf_copy_len;
 8005ed8:	fa1f f884 	uxth.w	r8, r4
 8005edc:	e7e9      	b.n	8005eb2 <pbuf_copy_partial+0x2a>
  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 8005ede:	4605      	mov	r5, r0
 8005ee0:	e7de      	b.n	8005ea0 <pbuf_copy_partial+0x18>
 8005ee2:	460d      	mov	r5, r1
 8005ee4:	e7dc      	b.n	8005ea0 <pbuf_copy_partial+0x18>
	...

08005ee8 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
 8005ee8:	4a12      	ldr	r2, [pc, #72]	; (8005f34 <tcp_new_port+0x4c>)
 8005eea:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8005eee:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005ef0:	8810      	ldrh	r0, [r2, #0]
  u8_t i;
  u16_t n = 0;
  struct tcp_pcb *pcb;

again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
 8005ef2:	f64f 75ff 	movw	r5, #65535	; 0xffff
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 8005ef6:	4e10      	ldr	r6, [pc, #64]	; (8005f38 <tcp_new_port+0x50>)
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
 8005ef8:	42a8      	cmp	r0, r5
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
 8005efa:	f04f 0100 	mov.w	r1, #0
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
 8005efe:	bf16      	itet	ne
 8005f00:	3001      	addne	r0, #1
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
 8005f02:	f44f 4040 	moveq.w	r0, #49152	; 0xc000
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
 8005f06:	b280      	uxthne	r0, r0
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 8005f08:	f856 4021 	ldr.w	r4, [r6, r1, lsl #2]
 8005f0c:	6824      	ldr	r4, [r4, #0]
 8005f0e:	b924      	cbnz	r4, 8005f1a <tcp_new_port+0x32>
 8005f10:	3101      	adds	r1, #1
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 8005f12:	2904      	cmp	r1, #4
 8005f14:	d1f8      	bne.n	8005f08 <tcp_new_port+0x20>
 8005f16:	8010      	strh	r0, [r2, #0]
        goto again;
      }
    }
  }
  return tcp_port;
}
 8005f18:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (pcb->local_port == tcp_port) {
 8005f1a:	8b67      	ldrh	r7, [r4, #26]
 8005f1c:	4287      	cmp	r7, r0
 8005f1e:	d106      	bne.n	8005f2e <tcp_new_port+0x46>
 8005f20:	3b01      	subs	r3, #1
 8005f22:	b29b      	uxth	r3, r3
        if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
 8005f24:	2b00      	cmp	r3, #0
 8005f26:	d1e7      	bne.n	8005ef8 <tcp_new_port+0x10>
 8005f28:	8010      	strh	r0, [r2, #0]
          return 0;
 8005f2a:	4618      	mov	r0, r3
 8005f2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 8005f2e:	68e4      	ldr	r4, [r4, #12]
 8005f30:	e7ed      	b.n	8005f0e <tcp_new_port+0x26>
 8005f32:	bf00      	nop
 8005f34:	2000003c 	.word	0x2000003c
 8005f38:	08009d10 	.word	0x08009d10

08005f3c <tcp_init>:
{
 8005f3c:	4770      	bx	lr
	...

08005f40 <tcp_bind>:
{
 8005f40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005f42:	460d      	mov	r5, r1
  if ((pcb == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, ipaddr)) {
 8005f44:	4604      	mov	r4, r0
 8005f46:	b350      	cbz	r0, 8005f9e <tcp_bind+0x5e>
  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 8005f48:	7e03      	ldrb	r3, [r0, #24]
 8005f4a:	bb43      	cbnz	r3, 8005f9e <tcp_bind+0x5e>
  if (port == 0) {
 8005f4c:	b932      	cbnz	r2, 8005f5c <tcp_bind+0x1c>
    port = tcp_new_port();
 8005f4e:	f7ff ffcb 	bl	8005ee8 <tcp_new_port>
    if (port == 0) {
 8005f52:	4602      	mov	r2, r0
 8005f54:	b950      	cbnz	r0, 8005f6c <tcp_bind+0x2c>
      return ERR_BUF;
 8005f56:	f06f 0001 	mvn.w	r0, #1
 8005f5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 8005f5c:	4f13      	ldr	r7, [pc, #76]	; (8005fac <tcp_bind+0x6c>)
 8005f5e:	f857 1023 	ldr.w	r1, [r7, r3, lsl #2]
 8005f62:	6808      	ldr	r0, [r1, #0]
 8005f64:	b978      	cbnz	r0, 8005f86 <tcp_bind+0x46>
    for (i = 0; i < max_pcb_list; i++) {
 8005f66:	3301      	adds	r3, #1
 8005f68:	2b04      	cmp	r3, #4
 8005f6a:	d1f8      	bne.n	8005f5e <tcp_bind+0x1e>
  if (!ip_addr_isany(ipaddr)) {
 8005f6c:	b115      	cbz	r5, 8005f74 <tcp_bind+0x34>
 8005f6e:	682b      	ldr	r3, [r5, #0]
 8005f70:	b103      	cbz	r3, 8005f74 <tcp_bind+0x34>
    ip_addr_set(&pcb->local_ip, ipaddr);
 8005f72:	6023      	str	r3, [r4, #0]
  TCP_REG(&tcp_bound_pcbs, pcb);
 8005f74:	4b0e      	ldr	r3, [pc, #56]	; (8005fb0 <tcp_bind+0x70>)
  pcb->local_port = port;
 8005f76:	8362      	strh	r2, [r4, #26]
  TCP_REG(&tcp_bound_pcbs, pcb);
 8005f78:	681a      	ldr	r2, [r3, #0]
 8005f7a:	601c      	str	r4, [r3, #0]
 8005f7c:	60e2      	str	r2, [r4, #12]
 8005f7e:	f7ff fb27 	bl	80055d0 <tcp_timer_needed>
  return ERR_OK;
 8005f82:	2000      	movs	r0, #0
 8005f84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (cpcb->local_port == port) {
 8005f86:	8b41      	ldrh	r1, [r0, #26]
 8005f88:	4291      	cmp	r1, r2
 8005f8a:	d106      	bne.n	8005f9a <tcp_bind+0x5a>
                (ip_addr_isany(&cpcb->local_ip) ||
 8005f8c:	6806      	ldr	r6, [r0, #0]
 8005f8e:	b14e      	cbz	r6, 8005fa4 <tcp_bind+0x64>
 8005f90:	b145      	cbz	r5, 8005fa4 <tcp_bind+0x64>
                ip_addr_isany(ipaddr) ||
 8005f92:	6829      	ldr	r1, [r5, #0]
 8005f94:	b131      	cbz	r1, 8005fa4 <tcp_bind+0x64>
            if (IP_PCB_IPVER_EQ(pcb, cpcb) &&
 8005f96:	428e      	cmp	r6, r1
 8005f98:	d004      	beq.n	8005fa4 <tcp_bind+0x64>
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 8005f9a:	68c0      	ldr	r0, [r0, #12]
 8005f9c:	e7e2      	b.n	8005f64 <tcp_bind+0x24>
    return ERR_VAL;
 8005f9e:	f06f 0005 	mvn.w	r0, #5
 8005fa2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
              return ERR_USE;
 8005fa4:	f06f 0007 	mvn.w	r0, #7
}
 8005fa8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005faa:	bf00      	nop
 8005fac:	08009d10 	.word	0x08009d10
 8005fb0:	20007674 	.word	0x20007674

08005fb4 <tcp_listen_with_backlog>:
{
 8005fb4:	b538      	push	{r3, r4, r5, lr}
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
 8005fb6:	7e03      	ldrb	r3, [r0, #24]
{
 8005fb8:	4605      	mov	r5, r0
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
 8005fba:	b10b      	cbz	r3, 8005fc0 <tcp_listen_with_backlog+0xc>
 8005fbc:	2000      	movs	r0, #0
 8005fbe:	bd38      	pop	{r3, r4, r5, pc}
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
 8005fc0:	2002      	movs	r0, #2
 8005fc2:	f7ff fcf1 	bl	80059a8 <memp_malloc>
  if (lpcb == NULL) {
 8005fc6:	4604      	mov	r4, r0
 8005fc8:	2800      	cmp	r0, #0
 8005fca:	d0f7      	beq.n	8005fbc <tcp_listen_with_backlog+0x8>
  lpcb->callback_arg = pcb->callback_arg;
 8005fcc:	692b      	ldr	r3, [r5, #16]
  lpcb->state = LISTEN;
 8005fce:	2201      	movs	r2, #1
  lpcb->callback_arg = pcb->callback_arg;
 8005fd0:	6103      	str	r3, [r0, #16]
  lpcb->local_port = pcb->local_port;
 8005fd2:	8b6b      	ldrh	r3, [r5, #26]
  lpcb->state = LISTEN;
 8005fd4:	7602      	strb	r2, [r0, #24]
  lpcb->local_port = pcb->local_port;
 8005fd6:	8343      	strh	r3, [r0, #26]
  lpcb->prio = pcb->prio;
 8005fd8:	7e6a      	ldrb	r2, [r5, #25]
 8005fda:	7642      	strb	r2, [r0, #25]
  lpcb->so_options = pcb->so_options;
 8005fdc:	7a2a      	ldrb	r2, [r5, #8]
 8005fde:	7202      	strb	r2, [r0, #8]
  lpcb->ttl = pcb->ttl;
 8005fe0:	7aaa      	ldrb	r2, [r5, #10]
 8005fe2:	7282      	strb	r2, [r0, #10]
  lpcb->tos = pcb->tos;
 8005fe4:	7a6a      	ldrb	r2, [r5, #9]
 8005fe6:	7242      	strb	r2, [r0, #9]
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
 8005fe8:	682a      	ldr	r2, [r5, #0]
 8005fea:	6002      	str	r2, [r0, #0]
  if (pcb->local_port != 0) {
 8005fec:	b13b      	cbz	r3, 8005ffe <tcp_listen_with_backlog+0x4a>
    TCP_RMV(&tcp_bound_pcbs, pcb);
 8005fee:	4a0f      	ldr	r2, [pc, #60]	; (800602c <tcp_listen_with_backlog+0x78>)
 8005ff0:	6813      	ldr	r3, [r2, #0]
 8005ff2:	429d      	cmp	r5, r3
 8005ff4:	d112      	bne.n	800601c <tcp_listen_with_backlog+0x68>
 8005ff6:	68eb      	ldr	r3, [r5, #12]
 8005ff8:	6013      	str	r3, [r2, #0]
 8005ffa:	2300      	movs	r3, #0
 8005ffc:	60eb      	str	r3, [r5, #12]
  memp_free(MEMP_TCP_PCB, pcb);
 8005ffe:	4629      	mov	r1, r5
 8006000:	2001      	movs	r0, #1
 8006002:	f7ff fcdd 	bl	80059c0 <memp_free>
  lpcb->accept = tcp_accept_null;
 8006006:	4b0a      	ldr	r3, [pc, #40]	; (8006030 <tcp_listen_with_backlog+0x7c>)
 8006008:	6163      	str	r3, [r4, #20]
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
 800600a:	4b0a      	ldr	r3, [pc, #40]	; (8006034 <tcp_listen_with_backlog+0x80>)
 800600c:	681a      	ldr	r2, [r3, #0]
 800600e:	601c      	str	r4, [r3, #0]
 8006010:	60e2      	str	r2, [r4, #12]
 8006012:	f7ff fadd 	bl	80055d0 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
 8006016:	4620      	mov	r0, r4
}
 8006018:	bd38      	pop	{r3, r4, r5, pc}
 800601a:	4613      	mov	r3, r2
    TCP_RMV(&tcp_bound_pcbs, pcb);
 800601c:	2b00      	cmp	r3, #0
 800601e:	d0ec      	beq.n	8005ffa <tcp_listen_with_backlog+0x46>
 8006020:	68da      	ldr	r2, [r3, #12]
 8006022:	4295      	cmp	r5, r2
 8006024:	d1f9      	bne.n	800601a <tcp_listen_with_backlog+0x66>
 8006026:	68ea      	ldr	r2, [r5, #12]
 8006028:	60da      	str	r2, [r3, #12]
 800602a:	e7e6      	b.n	8005ffa <tcp_listen_with_backlog+0x46>
 800602c:	20007674 	.word	0x20007674
 8006030:	0800683f 	.word	0x0800683f
 8006034:	20007670 	.word	0x20007670

08006038 <tcp_update_rcv_ann_wnd>:
{
 8006038:	b530      	push	{r4, r5, lr}
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 800603a:	6b01      	ldr	r1, [r0, #48]	; 0x30
{
 800603c:	4602      	mov	r2, r0
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 800603e:	8d85      	ldrh	r5, [r0, #44]	; 0x2c
 8006040:	6a84      	ldr	r4, [r0, #40]	; 0x28
 8006042:	1a6b      	subs	r3, r5, r1
 8006044:	1918      	adds	r0, r3, r4
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 8006046:	8ed3      	ldrh	r3, [r2, #54]	; 0x36
 8006048:	f5b3 6f86 	cmp.w	r3, #1072	; 0x430
 800604c:	bf94      	ite	ls
 800604e:	1ac3      	subls	r3, r0, r3
 8006050:	f5a0 6386 	subhi.w	r3, r0, #1072	; 0x430
 8006054:	2b00      	cmp	r3, #0
 8006056:	db01      	blt.n	800605c <tcp_update_rcv_ann_wnd+0x24>
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 8006058:	85d5      	strh	r5, [r2, #46]	; 0x2e
    return new_right_edge - pcb->rcv_ann_right_edge;
 800605a:	bd30      	pop	{r4, r5, pc}
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 800605c:	1a63      	subs	r3, r4, r1
 800605e:	2000      	movs	r0, #0
 8006060:	2b00      	cmp	r3, #0
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 8006062:	bfd6      	itet	le
 8006064:	1b09      	suble	r1, r1, r4
      pcb->rcv_ann_wnd = 0;
 8006066:	85d0      	strhgt	r0, [r2, #46]	; 0x2e
      pcb->rcv_ann_wnd = (tcpwnd_size_t)new_rcv_ann_wnd;
 8006068:	85d1      	strhle	r1, [r2, #46]	; 0x2e
}
 800606a:	bd30      	pop	{r4, r5, pc}

0800606c <tcp_recved>:
  pcb->rcv_wnd += len;
 800606c:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
 800606e:	4419      	add	r1, r3
 8006070:	b289      	uxth	r1, r1
  if (pcb->rcv_wnd > TCP_WND_MAX(pcb)) {
 8006072:	f5b1 6f06 	cmp.w	r1, #2144	; 0x860
{
 8006076:	b510      	push	{r4, lr}
 8006078:	4604      	mov	r4, r0
  if (pcb->rcv_wnd > TCP_WND_MAX(pcb)) {
 800607a:	d911      	bls.n	80060a0 <tcp_recved+0x34>
    pcb->rcv_wnd = TCP_WND_MAX(pcb);
 800607c:	f44f 6306 	mov.w	r3, #2144	; 0x860
 8006080:	85a3      	strh	r3, [r4, #44]	; 0x2c
  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 8006082:	4620      	mov	r0, r4
 8006084:	f7ff ffd8 	bl	8006038 <tcp_update_rcv_ann_wnd>
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 8006088:	f5b0 7f06 	cmp.w	r0, #536	; 0x218
 800608c:	db11      	blt.n	80060b2 <tcp_recved+0x46>
    tcp_ack_now(pcb);
 800608e:	7fa3      	ldrb	r3, [r4, #30]
    tcp_output(pcb);
 8006090:	4620      	mov	r0, r4
    tcp_ack_now(pcb);
 8006092:	f043 0302 	orr.w	r3, r3, #2
 8006096:	77a3      	strb	r3, [r4, #30]
}
 8006098:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tcp_output(pcb);
 800609c:	f002 b84a 	b.w	8008134 <tcp_output>
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 80060a0:	7e03      	ldrb	r3, [r0, #24]
  } else if (pcb->rcv_wnd == 0) {
 80060a2:	b109      	cbz	r1, 80060a8 <tcp_recved+0x3c>
  pcb->rcv_wnd += len;
 80060a4:	85a1      	strh	r1, [r4, #44]	; 0x2c
 80060a6:	e7ec      	b.n	8006082 <tcp_recved+0x16>
    if ((pcb->state == CLOSE_WAIT) || (pcb->state == LAST_ACK)) {
 80060a8:	2b07      	cmp	r3, #7
 80060aa:	d0e7      	beq.n	800607c <tcp_recved+0x10>
 80060ac:	2b09      	cmp	r3, #9
 80060ae:	d1f9      	bne.n	80060a4 <tcp_recved+0x38>
 80060b0:	e7e4      	b.n	800607c <tcp_recved+0x10>
 80060b2:	bd10      	pop	{r4, pc}

080060b4 <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
 80060b4:	b510      	push	{r4, lr}
  if (seg != NULL) {
 80060b6:	4604      	mov	r4, r0
 80060b8:	b148      	cbz	r0, 80060ce <tcp_seg_free+0x1a>
    if (seg->p != NULL) {
 80060ba:	6840      	ldr	r0, [r0, #4]
 80060bc:	b108      	cbz	r0, 80060c2 <tcp_seg_free+0xe>
      pbuf_free(seg->p);
 80060be:	f7ff fd9a 	bl	8005bf6 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 80060c2:	4621      	mov	r1, r4
 80060c4:	2003      	movs	r0, #3
  }
}
 80060c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    memp_free(MEMP_TCP_SEG, seg);
 80060ca:	f7ff bc79 	b.w	80059c0 <memp_free>
 80060ce:	bd10      	pop	{r4, pc}

080060d0 <tcp_segs_free>:
{
 80060d0:	b510      	push	{r4, lr}
  while (seg != NULL) {
 80060d2:	b900      	cbnz	r0, 80060d6 <tcp_segs_free+0x6>
}
 80060d4:	bd10      	pop	{r4, pc}
    struct tcp_seg *next = seg->next;
 80060d6:	6804      	ldr	r4, [r0, #0]
    tcp_seg_free(seg);
 80060d8:	f7ff ffec 	bl	80060b4 <tcp_seg_free>
    seg = next;
 80060dc:	4620      	mov	r0, r4
 80060de:	e7f8      	b.n	80060d2 <tcp_segs_free+0x2>

080060e0 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
 80060e0:	b538      	push	{r3, r4, r5, lr}
 80060e2:	4604      	mov	r4, r0
  struct tcp_seg *cseg;

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
 80060e4:	2003      	movs	r0, #3
 80060e6:	f7ff fc5f 	bl	80059a8 <memp_malloc>
  if (cseg == NULL) {
 80060ea:	4605      	mov	r5, r0
 80060ec:	b160      	cbz	r0, 8006108 <tcp_seg_copy+0x28>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
 80060ee:	4620      	mov	r0, r4
 80060f0:	462b      	mov	r3, r5
 80060f2:	f104 0210 	add.w	r2, r4, #16
 80060f6:	f850 1b04 	ldr.w	r1, [r0], #4
 80060fa:	4290      	cmp	r0, r2
 80060fc:	f843 1b04 	str.w	r1, [r3], #4
 8006100:	d1f9      	bne.n	80060f6 <tcp_seg_copy+0x16>
  pbuf_ref(cseg->p);
 8006102:	6868      	ldr	r0, [r5, #4]
 8006104:	f7ff fe57 	bl	8005db6 <pbuf_ref>
  return cseg;
}
 8006108:	4628      	mov	r0, r5
 800610a:	bd38      	pop	{r3, r4, r5, pc}

0800610c <tcp_arg>:
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->callback_arg = arg;
 800610c:	6101      	str	r1, [r0, #16]
 800610e:	4770      	bx	lr

08006110 <tcp_recv>:
 */
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
  LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
  pcb->recv = recv;
 8006110:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
 8006114:	4770      	bx	lr

08006116 <tcp_sent>:
 */
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
  LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
  pcb->sent = sent;
 8006116:	67c1      	str	r1, [r0, #124]	; 0x7c
 8006118:	4770      	bx	lr

0800611a <tcp_err>:
 */
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
  LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
  pcb->errf = err;
 800611a:	f8c0 108c 	str.w	r1, [r0, #140]	; 0x8c
 800611e:	4770      	bx	lr

08006120 <tcp_accept>:
void
tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->accept = accept;
 8006120:	6141      	str	r1, [r0, #20]
 8006122:	4770      	bx	lr

08006124 <tcp_poll>:
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
#if LWIP_CALLBACK_API
  pcb->poll = poll;
 8006124:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */
  pcb->pollinterval = interval;
 8006128:	f880 2020 	strb.w	r2, [r0, #32]
 800612c:	4770      	bx	lr

0800612e <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 800612e:	b538      	push	{r3, r4, r5, lr}
  if (pcb->state != CLOSED &&
 8006130:	7e03      	ldrb	r3, [r0, #24]
{
 8006132:	4604      	mov	r4, r0
  if (pcb->state != CLOSED &&
 8006134:	2b01      	cmp	r3, #1
 8006136:	d919      	bls.n	800616c <tcp_pcb_purge+0x3e>
 8006138:	2b0a      	cmp	r3, #10
 800613a:	d017      	beq.n	800616c <tcp_pcb_purge+0x3e>
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
 800613c:	6f80      	ldr	r0, [r0, #120]	; 0x78
 800613e:	b118      	cbz	r0, 8006148 <tcp_pcb_purge+0x1a>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 8006140:	f7ff fd59 	bl	8005bf6 <pbuf_free>
      pcb->refused_data = NULL;
 8006144:	2300      	movs	r3, #0
 8006146:	67a3      	str	r3, [r4, #120]	; 0x78
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
 8006148:	6f60      	ldr	r0, [r4, #116]	; 0x74
    pcb->ooseq = NULL;
 800614a:	2500      	movs	r5, #0
    tcp_segs_free(pcb->ooseq);
 800614c:	f7ff ffc0 	bl	80060d0 <tcp_segs_free>
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 8006150:	f64f 73ff 	movw	r3, #65535	; 0xffff

    tcp_segs_free(pcb->unsent);
 8006154:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    pcb->rtime = -1;
 8006156:	86a3      	strh	r3, [r4, #52]	; 0x34
    pcb->ooseq = NULL;
 8006158:	6765      	str	r5, [r4, #116]	; 0x74
    tcp_segs_free(pcb->unsent);
 800615a:	f7ff ffb9 	bl	80060d0 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 800615e:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8006160:	f7ff ffb6 	bl	80060d0 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 8006164:	66e5      	str	r5, [r4, #108]	; 0x6c
 8006166:	6725      	str	r5, [r4, #112]	; 0x70
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 8006168:	f8a4 506a 	strh.w	r5, [r4, #106]	; 0x6a
 800616c:	bd38      	pop	{r3, r4, r5, pc}
	...

08006170 <tcp_slowtmr>:
{
 8006170:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  ++tcp_ticks;
 8006174:	4db0      	ldr	r5, [pc, #704]	; (8006438 <tcp_slowtmr+0x2c8>)
{
 8006176:	b085      	sub	sp, #20
  ++tcp_timer_ctr;
 8006178:	4fb0      	ldr	r7, [pc, #704]	; (800643c <tcp_slowtmr+0x2cc>)
  ++tcp_ticks;
 800617a:	682b      	ldr	r3, [r5, #0]
      tcp_active_pcbs_changed = 0;
 800617c:	f8df 92cc 	ldr.w	r9, [pc, #716]	; 800644c <tcp_slowtmr+0x2dc>
  ++tcp_ticks;
 8006180:	3301      	adds	r3, #1
 8006182:	9702      	str	r7, [sp, #8]
 8006184:	602b      	str	r3, [r5, #0]
  ++tcp_timer_ctr;
 8006186:	783b      	ldrb	r3, [r7, #0]
 8006188:	3301      	adds	r3, #1
 800618a:	703b      	strb	r3, [r7, #0]
  pcb = tcp_active_pcbs;
 800618c:	4bac      	ldr	r3, [pc, #688]	; (8006440 <tcp_slowtmr+0x2d0>)
  prev = NULL;
 800618e:	2600      	movs	r6, #0
                (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 8006190:	f8df b2bc 	ldr.w	fp, [pc, #700]	; 8006450 <tcp_slowtmr+0x2e0>
  pcb = tcp_active_pcbs;
 8006194:	681c      	ldr	r4, [r3, #0]
 8006196:	4698      	mov	r8, r3
  while (pcb != NULL) {
 8006198:	b93c      	cbnz	r4, 80061aa <tcp_slowtmr+0x3a>
  pcb = tcp_tw_pcbs;
 800619a:	4faa      	ldr	r7, [pc, #680]	; (8006444 <tcp_slowtmr+0x2d4>)
 800619c:	683e      	ldr	r6, [r7, #0]
  while (pcb != NULL) {
 800619e:	2e00      	cmp	r6, #0
 80061a0:	f040 8130 	bne.w	8006404 <tcp_slowtmr+0x294>
}
 80061a4:	b005      	add	sp, #20
 80061a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (pcb->last_timer == tcp_timer_ctr) {
 80061aa:	9b02      	ldr	r3, [sp, #8]
 80061ac:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
 80061b0:	781b      	ldrb	r3, [r3, #0]
 80061b2:	429a      	cmp	r2, r3
 80061b4:	d105      	bne.n	80061c2 <tcp_slowtmr+0x52>
      pcb = pcb->next;
 80061b6:	f8d4 a00c 	ldr.w	sl, [r4, #12]
 80061ba:	4634      	mov	r4, r6
      continue;
 80061bc:	4626      	mov	r6, r4
 80061be:	4654      	mov	r4, sl
 80061c0:	e7ea      	b.n	8006198 <tcp_slowtmr+0x28>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 80061c2:	7e21      	ldrb	r1, [r4, #24]
    pcb->last_timer = tcp_timer_ctr;
 80061c4:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 80061c8:	2902      	cmp	r1, #2
 80061ca:	f894 0046 	ldrb.w	r0, [r4, #70]	; 0x46
 80061ce:	d102      	bne.n	80061d6 <tcp_slowtmr+0x66>
 80061d0:	2806      	cmp	r0, #6
 80061d2:	f000 80d4 	beq.w	800637e <tcp_slowtmr+0x20e>
    else if (pcb->nrtx == TCP_MAXRTX) {
 80061d6:	280c      	cmp	r0, #12
 80061d8:	f000 80d1 	beq.w	800637e <tcp_slowtmr+0x20e>
      if (pcb->persist_backoff > 0) {
 80061dc:	f894 7095 	ldrb.w	r7, [r4, #149]	; 0x95
 80061e0:	2f00      	cmp	r7, #0
 80061e2:	f000 8094 	beq.w	800630e <tcp_slowtmr+0x19e>
        u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff-1];
 80061e6:	4b98      	ldr	r3, [pc, #608]	; (8006448 <tcp_slowtmr+0x2d8>)
 80061e8:	443b      	add	r3, r7
 80061ea:	7bda      	ldrb	r2, [r3, #15]
        if (pcb->persist_cnt < backoff_cnt) {
 80061ec:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
 80061f0:	429a      	cmp	r2, r3
          pcb->persist_cnt++;
 80061f2:	bf84      	itt	hi
 80061f4:	3301      	addhi	r3, #1
 80061f6:	f884 3094 	strbhi.w	r3, [r4, #148]	; 0x94
        if (pcb->persist_cnt >= backoff_cnt) {
 80061fa:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
 80061fe:	4293      	cmp	r3, r2
 8006200:	d275      	bcs.n	80062ee <tcp_slowtmr+0x17e>
    pcb_remove = 0;
 8006202:	2700      	movs	r7, #0
    if (pcb->state == FIN_WAIT_2) {
 8006204:	7e22      	ldrb	r2, [r4, #24]
 8006206:	2a06      	cmp	r2, #6
 8006208:	d109      	bne.n	800621e <tcp_slowtmr+0xae>
      if (pcb->flags & TF_RXCLOSED) {
 800620a:	7fa1      	ldrb	r1, [r4, #30]
 800620c:	06cb      	lsls	r3, r1, #27
 800620e:	d506      	bpl.n	800621e <tcp_slowtmr+0xae>
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 8006210:	6829      	ldr	r1, [r5, #0]
 8006212:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8006214:	1a09      	subs	r1, r1, r0
 8006216:	2928      	cmp	r1, #40	; 0x28
          ++pcb_remove;
 8006218:	bf84      	itt	hi
 800621a:	1c7b      	addhi	r3, r7, #1
 800621c:	b2df      	uxtbhi	r7, r3
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
 800621e:	f894 a008 	ldrb.w	sl, [r4, #8]
 8006222:	f01a 0a08 	ands.w	sl, sl, #8
 8006226:	d018      	beq.n	800625a <tcp_slowtmr+0xea>
 8006228:	2a04      	cmp	r2, #4
 800622a:	d002      	beq.n	8006232 <tcp_slowtmr+0xc2>
       ((pcb->state == ESTABLISHED) ||
 800622c:	2a07      	cmp	r2, #7
 800622e:	f040 80b9 	bne.w	80063a4 <tcp_slowtmr+0x234>
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 8006232:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8006236:	f44f 7efa 	mov.w	lr, #500	; 0x1f4
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800623a:	6828      	ldr	r0, [r5, #0]
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 800623c:	f503 2124 	add.w	r1, r3, #671744	; 0xa4000
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 8006240:	6a62      	ldr	r2, [r4, #36]	; 0x24
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 8006242:	f601 41b8 	addw	r1, r1, #3256	; 0xcb8
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 8006246:	1a80      	subs	r0, r0, r2
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 8006248:	fbb1 f1fe 	udiv	r1, r1, lr
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800624c:	4288      	cmp	r0, r1
 800624e:	f240 8098 	bls.w	8006382 <tcp_slowtmr+0x212>
        ++pcb_remove;
 8006252:	1c7b      	adds	r3, r7, #1
        ++pcb_reset;
 8006254:	f04f 0a01 	mov.w	sl, #1
        ++pcb_remove;
 8006258:	b2df      	uxtb	r7, r3
    if (pcb->ooseq != NULL &&
 800625a:	6f60      	ldr	r0, [r4, #116]	; 0x74
 800625c:	b168      	cbz	r0, 800627a <tcp_slowtmr+0x10a>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
 800625e:	682a      	ldr	r2, [r5, #0]
 8006260:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8006262:	1a51      	subs	r1, r2, r1
 8006264:	f9b4 2044 	ldrsh.w	r2, [r4, #68]	; 0x44
 8006268:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    if (pcb->ooseq != NULL &&
 800626c:	ebb1 0f42 	cmp.w	r1, r2, lsl #1
 8006270:	d303      	bcc.n	800627a <tcp_slowtmr+0x10a>
      tcp_segs_free(pcb->ooseq);
 8006272:	f7ff ff2d 	bl	80060d0 <tcp_segs_free>
      pcb->ooseq = NULL;
 8006276:	2200      	movs	r2, #0
 8006278:	6762      	str	r2, [r4, #116]	; 0x74
    if (pcb->state == SYN_RCVD) {
 800627a:	7e22      	ldrb	r2, [r4, #24]
 800627c:	2a03      	cmp	r2, #3
 800627e:	f040 8094 	bne.w	80063aa <tcp_slowtmr+0x23a>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 8006282:	682a      	ldr	r2, [r5, #0]
 8006284:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8006286:	1a52      	subs	r2, r2, r1
 8006288:	2a28      	cmp	r2, #40	; 0x28
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 800628a:	d802      	bhi.n	8006292 <tcp_slowtmr+0x122>
    if (pcb_remove) {
 800628c:	2f00      	cmp	r7, #0
 800628e:	f000 8097 	beq.w	80063c0 <tcp_slowtmr+0x250>
      tcp_pcb_purge(pcb);
 8006292:	4620      	mov	r0, r4
 8006294:	f7ff ff4b 	bl	800612e <tcp_pcb_purge>
 8006298:	68e3      	ldr	r3, [r4, #12]
      if (prev != NULL) {
 800629a:	2e00      	cmp	r6, #0
 800629c:	f000 808d 	beq.w	80063ba <tcp_slowtmr+0x24a>
        prev->next = pcb->next;
 80062a0:	60f3      	str	r3, [r6, #12]
      if (pcb_reset) {
 80062a2:	f1ba 0f00 	cmp.w	sl, #0
 80062a6:	d009      	beq.n	80062bc <tcp_slowtmr+0x14c>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 80062a8:	8ba3      	ldrh	r3, [r4, #28]
 80062aa:	4622      	mov	r2, r4
 80062ac:	9301      	str	r3, [sp, #4]
 80062ae:	8b63      	ldrh	r3, [r4, #26]
 80062b0:	9300      	str	r3, [sp, #0]
 80062b2:	1d23      	adds	r3, r4, #4
 80062b4:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80062b6:	6d20      	ldr	r0, [r4, #80]	; 0x50
 80062b8:	f002 f876 	bl	80083a8 <tcp_rst>
      err_arg = pcb->callback_arg;
 80062bc:	6922      	ldr	r2, [r4, #16]
      memp_free(MEMP_TCP_PCB, pcb2);
 80062be:	4621      	mov	r1, r4
 80062c0:	2001      	movs	r0, #1
      err_fn = pcb->errf;
 80062c2:	f8d4 708c 	ldr.w	r7, [r4, #140]	; 0x8c
      err_arg = pcb->callback_arg;
 80062c6:	9203      	str	r2, [sp, #12]
      pcb = pcb->next;
 80062c8:	f8d4 a00c 	ldr.w	sl, [r4, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 80062cc:	f7ff fb78 	bl	80059c0 <memp_free>
      tcp_active_pcbs_changed = 0;
 80062d0:	2100      	movs	r1, #0
 80062d2:	f889 1000 	strb.w	r1, [r9]
      TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
 80062d6:	b127      	cbz	r7, 80062e2 <tcp_slowtmr+0x172>
 80062d8:	9a03      	ldr	r2, [sp, #12]
 80062da:	f06f 010b 	mvn.w	r1, #11
 80062de:	4610      	mov	r0, r2
 80062e0:	47b8      	blx	r7
      if (tcp_active_pcbs_changed) {
 80062e2:	f899 3000 	ldrb.w	r3, [r9]
 80062e6:	2b00      	cmp	r3, #0
 80062e8:	f43f af67 	beq.w	80061ba <tcp_slowtmr+0x4a>
 80062ec:	e74e      	b.n	800618c <tcp_slowtmr+0x1c>
          if (tcp_zero_window_probe(pcb) == ERR_OK) {
 80062ee:	4620      	mov	r0, r4
 80062f0:	f002 f935 	bl	800855e <tcp_zero_window_probe>
 80062f4:	2800      	cmp	r0, #0
 80062f6:	d184      	bne.n	8006202 <tcp_slowtmr+0x92>
            if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 80062f8:	f894 2095 	ldrb.w	r2, [r4, #149]	; 0x95
            pcb->persist_cnt = 0;
 80062fc:	f884 0094 	strb.w	r0, [r4, #148]	; 0x94
            if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 8006300:	2a06      	cmp	r2, #6
 8006302:	f63f af7e 	bhi.w	8006202 <tcp_slowtmr+0x92>
              pcb->persist_backoff++;
 8006306:	3201      	adds	r2, #1
 8006308:	f884 2095 	strb.w	r2, [r4, #149]	; 0x95
 800630c:	e779      	b.n	8006202 <tcp_slowtmr+0x92>
        if (pcb->rtime >= 0) {
 800630e:	f9b4 2034 	ldrsh.w	r2, [r4, #52]	; 0x34
 8006312:	2a00      	cmp	r2, #0
          ++pcb->rtime;
 8006314:	bfa4      	itt	ge
 8006316:	3201      	addge	r2, #1
 8006318:	86a2      	strhge	r2, [r4, #52]	; 0x34
        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
 800631a:	6f22      	ldr	r2, [r4, #112]	; 0x70
 800631c:	2a00      	cmp	r2, #0
 800631e:	f43f af70 	beq.w	8006202 <tcp_slowtmr+0x92>
 8006322:	f9b4 e034 	ldrsh.w	lr, [r4, #52]	; 0x34
 8006326:	f9b4 2044 	ldrsh.w	r2, [r4, #68]	; 0x44
 800632a:	4596      	cmp	lr, r2
 800632c:	f6ff af69 	blt.w	8006202 <tcp_slowtmr+0x92>
          if (pcb->state != SYN_SENT) {
 8006330:	2902      	cmp	r1, #2
 8006332:	d00b      	beq.n	800634c <tcp_slowtmr+0x1dc>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
 8006334:	f9b4 1040 	ldrsh.w	r1, [r4, #64]	; 0x40
 8006338:	f9b4 2042 	ldrsh.w	r2, [r4, #66]	; 0x42
 800633c:	eb02 02e1 	add.w	r2, r2, r1, asr #3
 8006340:	4941      	ldr	r1, [pc, #260]	; (8006448 <tcp_slowtmr+0x2d8>)
 8006342:	4401      	add	r1, r0
 8006344:	7dc9      	ldrb	r1, [r1, #23]
 8006346:	408a      	lsls	r2, r1
 8006348:	f8a4 2044 	strh.w	r2, [r4, #68]	; 0x44
          pcb->rtime = 0;
 800634c:	2200      	movs	r2, #0
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 800634e:	f8b4 104c 	ldrh.w	r1, [r4, #76]	; 0x4c
          if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
 8006352:	8ee0      	ldrh	r0, [r4, #54]	; 0x36
          pcb->rtime = 0;
 8006354:	86a2      	strh	r2, [r4, #52]	; 0x34
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 8006356:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
          pcb->cwnd = pcb->mss;
 800635a:	f8a4 004c 	strh.w	r0, [r4, #76]	; 0x4c
          pcb->ssthresh = eff_wnd >> 1;
 800635e:	428a      	cmp	r2, r1
 8006360:	bf28      	it	cs
 8006362:	460a      	movcs	r2, r1
          if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
 8006364:	0041      	lsls	r1, r0, #1
          tcp_rexmit_rto(pcb);
 8006366:	4620      	mov	r0, r4
          pcb->ssthresh = eff_wnd >> 1;
 8006368:	0852      	lsrs	r2, r2, #1
          if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
 800636a:	b289      	uxth	r1, r1
          pcb->ssthresh = eff_wnd >> 1;
 800636c:	f8a4 204e 	strh.w	r2, [r4, #78]	; 0x4e
          if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
 8006370:	428a      	cmp	r2, r1
            pcb->ssthresh = (pcb->mss << 1);
 8006372:	bf38      	it	cc
 8006374:	f8a4 104e 	strhcc.w	r1, [r4, #78]	; 0x4e
          tcp_rexmit_rto(pcb);
 8006378:	f002 f85e 	bl	8008438 <tcp_rexmit_rto>
 800637c:	e742      	b.n	8006204 <tcp_slowtmr+0x94>
      ++pcb_remove;
 800637e:	2701      	movs	r7, #1
 8006380:	e740      	b.n	8006204 <tcp_slowtmr+0x94>
                (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 8006382:	f894 2096 	ldrb.w	r2, [r4, #150]	; 0x96
 8006386:	fb0b 3202 	mla	r2, fp, r2, r3
                / TCP_SLOW_INTERVAL)
 800638a:	fbb2 f2fe 	udiv	r2, r2, lr
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
 800638e:	4290      	cmp	r0, r2
 8006390:	d908      	bls.n	80063a4 <tcp_slowtmr+0x234>
        err = tcp_keepalive(pcb);
 8006392:	4620      	mov	r0, r4
 8006394:	f002 f8b9 	bl	800850a <tcp_keepalive>
        if (err == ERR_OK) {
 8006398:	b920      	cbnz	r0, 80063a4 <tcp_slowtmr+0x234>
          pcb->keep_cnt_sent++;
 800639a:	f894 2096 	ldrb.w	r2, [r4, #150]	; 0x96
 800639e:	3201      	adds	r2, #1
 80063a0:	f884 2096 	strb.w	r2, [r4, #150]	; 0x96
    pcb_reset = 0;
 80063a4:	f04f 0a00 	mov.w	sl, #0
 80063a8:	e757      	b.n	800625a <tcp_slowtmr+0xea>
    if (pcb->state == LAST_ACK) {
 80063aa:	2a09      	cmp	r2, #9
 80063ac:	f47f af6e 	bne.w	800628c <tcp_slowtmr+0x11c>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 80063b0:	682a      	ldr	r2, [r5, #0]
 80063b2:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80063b4:	1a52      	subs	r2, r2, r1
 80063b6:	2af0      	cmp	r2, #240	; 0xf0
 80063b8:	e767      	b.n	800628a <tcp_slowtmr+0x11a>
        tcp_active_pcbs = pcb->next;
 80063ba:	f8c8 3000 	str.w	r3, [r8]
 80063be:	e770      	b.n	80062a2 <tcp_slowtmr+0x132>
      ++prev->polltmr;
 80063c0:	7fe2      	ldrb	r2, [r4, #31]
      if (prev->polltmr >= prev->pollinterval) {
 80063c2:	f894 1020 	ldrb.w	r1, [r4, #32]
      ++prev->polltmr;
 80063c6:	3201      	adds	r2, #1
      pcb = pcb->next;
 80063c8:	f8d4 a00c 	ldr.w	sl, [r4, #12]
      ++prev->polltmr;
 80063cc:	b2d2      	uxtb	r2, r2
      if (prev->polltmr >= prev->pollinterval) {
 80063ce:	4291      	cmp	r1, r2
      ++prev->polltmr;
 80063d0:	77e2      	strb	r2, [r4, #31]
      if (prev->polltmr >= prev->pollinterval) {
 80063d2:	f63f aef3 	bhi.w	80061bc <tcp_slowtmr+0x4c>
        TCP_EVENT_POLL(prev, err);
 80063d6:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
        prev->polltmr = 0;
 80063da:	77e7      	strb	r7, [r4, #31]
        tcp_active_pcbs_changed = 0;
 80063dc:	f889 7000 	strb.w	r7, [r9]
        TCP_EVENT_POLL(prev, err);
 80063e0:	b172      	cbz	r2, 8006400 <tcp_slowtmr+0x290>
 80063e2:	4621      	mov	r1, r4
 80063e4:	6920      	ldr	r0, [r4, #16]
 80063e6:	4790      	blx	r2
        if (tcp_active_pcbs_changed) {
 80063e8:	f899 3000 	ldrb.w	r3, [r9]
 80063ec:	2b00      	cmp	r3, #0
 80063ee:	f47f aecd 	bne.w	800618c <tcp_slowtmr+0x1c>
        if (err == ERR_OK) {
 80063f2:	2800      	cmp	r0, #0
 80063f4:	f47f aee2 	bne.w	80061bc <tcp_slowtmr+0x4c>
          tcp_output(prev);
 80063f8:	4620      	mov	r0, r4
 80063fa:	f001 fe9b 	bl	8008134 <tcp_output>
 80063fe:	e6dd      	b.n	80061bc <tcp_slowtmr+0x4c>
        TCP_EVENT_POLL(prev, err);
 8006400:	4638      	mov	r0, r7
 8006402:	e7f1      	b.n	80063e8 <tcp_slowtmr+0x278>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 8006404:	682b      	ldr	r3, [r5, #0]
 8006406:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8006408:	1a9b      	subs	r3, r3, r2
 800640a:	2bf0      	cmp	r3, #240	; 0xf0
 800640c:	d80b      	bhi.n	8006426 <tcp_slowtmr+0x2b6>
      pcb = pcb->next;
 800640e:	4634      	mov	r4, r6
 8006410:	68f6      	ldr	r6, [r6, #12]
 8006412:	e6c4      	b.n	800619e <tcp_slowtmr+0x2e>
        prev->next = pcb->next;
 8006414:	60e3      	str	r3, [r4, #12]
      pcb = pcb->next;
 8006416:	f8d6 800c 	ldr.w	r8, [r6, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 800641a:	4631      	mov	r1, r6
 800641c:	2001      	movs	r0, #1
 800641e:	f7ff facf 	bl	80059c0 <memp_free>
      pcb = pcb->next;
 8006422:	4646      	mov	r6, r8
 8006424:	e6bb      	b.n	800619e <tcp_slowtmr+0x2e>
      tcp_pcb_purge(pcb);
 8006426:	4630      	mov	r0, r6
 8006428:	f7ff fe81 	bl	800612e <tcp_pcb_purge>
 800642c:	68f3      	ldr	r3, [r6, #12]
      if (prev != NULL) {
 800642e:	2c00      	cmp	r4, #0
 8006430:	d1f0      	bne.n	8006414 <tcp_slowtmr+0x2a4>
        tcp_tw_pcbs = pcb->next;
 8006432:	603b      	str	r3, [r7, #0]
 8006434:	e7ef      	b.n	8006416 <tcp_slowtmr+0x2a6>
 8006436:	bf00      	nop
 8006438:	2000766c 	.word	0x2000766c
 800643c:	20003e11 	.word	0x20003e11
 8006440:	20007668 	.word	0x20007668
 8006444:	20007678 	.word	0x20007678
 8006448:	08009d10 	.word	0x08009d10
 800644c:	20007664 	.word	0x20007664
 8006450:	000124f8 	.word	0x000124f8

08006454 <tcp_pcb_remove>:
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
 8006454:	6803      	ldr	r3, [r0, #0]
 8006456:	428b      	cmp	r3, r1
{
 8006458:	b510      	push	{r4, lr}
 800645a:	460c      	mov	r4, r1
  TCP_RMV(pcblist, pcb);
 800645c:	d119      	bne.n	8006492 <tcp_pcb_remove+0x3e>
 800645e:	68cb      	ldr	r3, [r1, #12]
 8006460:	6003      	str	r3, [r0, #0]
 8006462:	2300      	movs	r3, #0

  tcp_pcb_purge(pcb);
 8006464:	4620      	mov	r0, r4
  TCP_RMV(pcblist, pcb);
 8006466:	60e3      	str	r3, [r4, #12]
  tcp_pcb_purge(pcb);
 8006468:	f7ff fe61 	bl	800612e <tcp_pcb_purge>

  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 800646c:	7e23      	ldrb	r3, [r4, #24]
 800646e:	2b0a      	cmp	r3, #10
 8006470:	d00a      	beq.n	8006488 <tcp_pcb_remove+0x34>
 8006472:	2b01      	cmp	r3, #1
 8006474:	d008      	beq.n	8006488 <tcp_pcb_remove+0x34>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
 8006476:	7fa3      	ldrb	r3, [r4, #30]
     pcb->state != LISTEN &&
 8006478:	07da      	lsls	r2, r3, #31
 800647a:	d505      	bpl.n	8006488 <tcp_pcb_remove+0x34>
    pcb->flags |= TF_ACK_NOW;
 800647c:	f043 0302 	orr.w	r3, r3, #2
    tcp_output(pcb);
 8006480:	4620      	mov	r0, r4
    pcb->flags |= TF_ACK_NOW;
 8006482:	77a3      	strb	r3, [r4, #30]
    tcp_output(pcb);
 8006484:	f001 fe56 	bl	8008134 <tcp_output>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 8006488:	2300      	movs	r3, #0
 800648a:	7623      	strb	r3, [r4, #24]
  /* reset the local port to prevent the pcb from being 'bound' */
  pcb->local_port = 0;
 800648c:	8363      	strh	r3, [r4, #26]
 800648e:	bd10      	pop	{r4, pc}
 8006490:	4613      	mov	r3, r2
  TCP_RMV(pcblist, pcb);
 8006492:	2b00      	cmp	r3, #0
 8006494:	d0e5      	beq.n	8006462 <tcp_pcb_remove+0xe>
 8006496:	68da      	ldr	r2, [r3, #12]
 8006498:	4294      	cmp	r4, r2
 800649a:	d1f9      	bne.n	8006490 <tcp_pcb_remove+0x3c>
 800649c:	68e2      	ldr	r2, [r4, #12]
 800649e:	60da      	str	r2, [r3, #12]
 80064a0:	e7df      	b.n	8006462 <tcp_pcb_remove+0xe>
	...

080064a4 <tcp_close_shutdown>:
{
 80064a4:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80064a6:	7e03      	ldrb	r3, [r0, #24]
 80064a8:	4604      	mov	r4, r0
  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 80064aa:	2900      	cmp	r1, #0
 80064ac:	d03f      	beq.n	800652e <tcp_close_shutdown+0x8a>
 80064ae:	2b04      	cmp	r3, #4
 80064b0:	d001      	beq.n	80064b6 <tcp_close_shutdown+0x12>
 80064b2:	2b07      	cmp	r3, #7
 80064b4:	d13b      	bne.n	800652e <tcp_close_shutdown+0x8a>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
 80064b6:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 80064b8:	b91a      	cbnz	r2, 80064c2 <tcp_close_shutdown+0x1e>
 80064ba:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 80064bc:	f5b2 6f06 	cmp.w	r2, #2144	; 0x860
 80064c0:	d035      	beq.n	800652e <tcp_close_shutdown+0x8a>
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 80064c2:	8ba3      	ldrh	r3, [r4, #28]
 80064c4:	4622      	mov	r2, r4
 80064c6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80064c8:	9301      	str	r3, [sp, #4]
 80064ca:	8b63      	ldrh	r3, [r4, #26]
 80064cc:	6d20      	ldr	r0, [r4, #80]	; 0x50
 80064ce:	9300      	str	r3, [sp, #0]
 80064d0:	1d23      	adds	r3, r4, #4
 80064d2:	f001 ff69 	bl	80083a8 <tcp_rst>
      tcp_pcb_purge(pcb);
 80064d6:	4620      	mov	r0, r4
 80064d8:	f7ff fe29 	bl	800612e <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 80064dc:	4a3b      	ldr	r2, [pc, #236]	; (80065cc <tcp_close_shutdown+0x128>)
 80064de:	6813      	ldr	r3, [r2, #0]
 80064e0:	429c      	cmp	r4, r3
 80064e2:	d115      	bne.n	8006510 <tcp_close_shutdown+0x6c>
 80064e4:	68e3      	ldr	r3, [r4, #12]
 80064e6:	6013      	str	r3, [r2, #0]
 80064e8:	4b39      	ldr	r3, [pc, #228]	; (80065d0 <tcp_close_shutdown+0x12c>)
 80064ea:	2201      	movs	r2, #1
 80064ec:	2500      	movs	r5, #0
 80064ee:	701a      	strb	r2, [r3, #0]
      if (pcb->state == ESTABLISHED) {
 80064f0:	7e23      	ldrb	r3, [r4, #24]
      TCP_RMV_ACTIVE(pcb);
 80064f2:	60e5      	str	r5, [r4, #12]
      if (pcb->state == ESTABLISHED) {
 80064f4:	2b04      	cmp	r3, #4
 80064f6:	d113      	bne.n	8006520 <tcp_close_shutdown+0x7c>
        pcb->state = TIME_WAIT;
 80064f8:	230a      	movs	r3, #10
 80064fa:	7623      	strb	r3, [r4, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 80064fc:	4b35      	ldr	r3, [pc, #212]	; (80065d4 <tcp_close_shutdown+0x130>)
 80064fe:	681a      	ldr	r2, [r3, #0]
 8006500:	601c      	str	r4, [r3, #0]
 8006502:	60e2      	str	r2, [r4, #12]
 8006504:	f7ff f864 	bl	80055d0 <tcp_timer_needed>
    tcp_output(pcb);
 8006508:	2000      	movs	r0, #0
}
 800650a:	b003      	add	sp, #12
 800650c:	bd30      	pop	{r4, r5, pc}
 800650e:	4613      	mov	r3, r2
      TCP_RMV_ACTIVE(pcb);
 8006510:	2b00      	cmp	r3, #0
 8006512:	d0e9      	beq.n	80064e8 <tcp_close_shutdown+0x44>
 8006514:	68da      	ldr	r2, [r3, #12]
 8006516:	4294      	cmp	r4, r2
 8006518:	d1f9      	bne.n	800650e <tcp_close_shutdown+0x6a>
 800651a:	68e2      	ldr	r2, [r4, #12]
 800651c:	60da      	str	r2, [r3, #12]
 800651e:	e7e3      	b.n	80064e8 <tcp_close_shutdown+0x44>
        if (tcp_input_pcb == pcb) {
 8006520:	4b2d      	ldr	r3, [pc, #180]	; (80065d8 <tcp_close_shutdown+0x134>)
 8006522:	681b      	ldr	r3, [r3, #0]
 8006524:	429c      	cmp	r4, r3
 8006526:	d121      	bne.n	800656c <tcp_close_shutdown+0xc8>
          tcp_trigger_input_pcb_close();
 8006528:	f001 fb14 	bl	8007b54 <tcp_trigger_input_pcb_close>
 800652c:	e7ec      	b.n	8006508 <tcp_close_shutdown+0x64>
  switch (pcb->state) {
 800652e:	2b07      	cmp	r3, #7
 8006530:	d8ea      	bhi.n	8006508 <tcp_close_shutdown+0x64>
 8006532:	a201      	add	r2, pc, #4	; (adr r2, 8006538 <tcp_close_shutdown+0x94>)
 8006534:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006538:	08006559 	.word	0x08006559
 800653c:	08006589 	.word	0x08006589
 8006540:	08006597 	.word	0x08006597
 8006544:	080065a9 	.word	0x080065a9
 8006548:	080065a9 	.word	0x080065a9
 800654c:	08006509 	.word	0x08006509
 8006550:	08006509 	.word	0x08006509
 8006554:	080065bf 	.word	0x080065bf
    if (pcb->local_port != 0) {
 8006558:	8b63      	ldrh	r3, [r4, #26]
 800655a:	b13b      	cbz	r3, 800656c <tcp_close_shutdown+0xc8>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 800655c:	4a1f      	ldr	r2, [pc, #124]	; (80065dc <tcp_close_shutdown+0x138>)
 800655e:	6813      	ldr	r3, [r2, #0]
 8006560:	429c      	cmp	r4, r3
 8006562:	d109      	bne.n	8006578 <tcp_close_shutdown+0xd4>
 8006564:	68e3      	ldr	r3, [r4, #12]
 8006566:	6013      	str	r3, [r2, #0]
 8006568:	2300      	movs	r3, #0
 800656a:	60e3      	str	r3, [r4, #12]
          memp_free(MEMP_TCP_PCB, pcb);
 800656c:	4621      	mov	r1, r4
 800656e:	2001      	movs	r0, #1
    memp_free(MEMP_TCP_PCB, pcb);
 8006570:	f7ff fa26 	bl	80059c0 <memp_free>
 8006574:	e7c8      	b.n	8006508 <tcp_close_shutdown+0x64>
 8006576:	4613      	mov	r3, r2
      TCP_RMV(&tcp_bound_pcbs, pcb);
 8006578:	2b00      	cmp	r3, #0
 800657a:	d0f5      	beq.n	8006568 <tcp_close_shutdown+0xc4>
 800657c:	68da      	ldr	r2, [r3, #12]
 800657e:	4294      	cmp	r4, r2
 8006580:	d1f9      	bne.n	8006576 <tcp_close_shutdown+0xd2>
 8006582:	68e2      	ldr	r2, [r4, #12]
 8006584:	60da      	str	r2, [r3, #12]
 8006586:	e7ef      	b.n	8006568 <tcp_close_shutdown+0xc4>
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 8006588:	4621      	mov	r1, r4
 800658a:	4815      	ldr	r0, [pc, #84]	; (80065e0 <tcp_close_shutdown+0x13c>)
 800658c:	f7ff ff62 	bl	8006454 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 8006590:	4621      	mov	r1, r4
 8006592:	2002      	movs	r0, #2
 8006594:	e7ec      	b.n	8006570 <tcp_close_shutdown+0xcc>
    TCP_PCB_REMOVE_ACTIVE(pcb);
 8006596:	4621      	mov	r1, r4
 8006598:	480c      	ldr	r0, [pc, #48]	; (80065cc <tcp_close_shutdown+0x128>)
 800659a:	f7ff ff5b 	bl	8006454 <tcp_pcb_remove>
 800659e:	2001      	movs	r0, #1
 80065a0:	4b0b      	ldr	r3, [pc, #44]	; (80065d0 <tcp_close_shutdown+0x12c>)
    memp_free(MEMP_TCP_PCB, pcb);
 80065a2:	4621      	mov	r1, r4
    TCP_PCB_REMOVE_ACTIVE(pcb);
 80065a4:	7018      	strb	r0, [r3, #0]
 80065a6:	e7e3      	b.n	8006570 <tcp_close_shutdown+0xcc>
    err = tcp_send_fin(pcb);
 80065a8:	4620      	mov	r0, r4
 80065aa:	f001 fd6b 	bl	8008084 <tcp_send_fin>
    if (err == ERR_OK) {
 80065ae:	2800      	cmp	r0, #0
 80065b0:	d1ab      	bne.n	800650a <tcp_close_shutdown+0x66>
      pcb->state = FIN_WAIT_1;
 80065b2:	2305      	movs	r3, #5
      pcb->state = LAST_ACK;
 80065b4:	7623      	strb	r3, [r4, #24]
    tcp_output(pcb);
 80065b6:	4620      	mov	r0, r4
 80065b8:	f001 fdbc 	bl	8008134 <tcp_output>
 80065bc:	e7a4      	b.n	8006508 <tcp_close_shutdown+0x64>
    err = tcp_send_fin(pcb);
 80065be:	4620      	mov	r0, r4
 80065c0:	f001 fd60 	bl	8008084 <tcp_send_fin>
    if (err == ERR_OK) {
 80065c4:	2800      	cmp	r0, #0
 80065c6:	d1a0      	bne.n	800650a <tcp_close_shutdown+0x66>
      pcb->state = LAST_ACK;
 80065c8:	2309      	movs	r3, #9
 80065ca:	e7f3      	b.n	80065b4 <tcp_close_shutdown+0x110>
 80065cc:	20007668 	.word	0x20007668
 80065d0:	20007664 	.word	0x20007664
 80065d4:	20007678 	.word	0x20007678
 80065d8:	2000767c 	.word	0x2000767c
 80065dc:	20007674 	.word	0x20007674
 80065e0:	20007670 	.word	0x20007670

080065e4 <tcp_close>:
  if (pcb->state != LISTEN) {
 80065e4:	7e03      	ldrb	r3, [r0, #24]
  return tcp_close_shutdown(pcb, 1);
 80065e6:	2101      	movs	r1, #1
  if (pcb->state != LISTEN) {
 80065e8:	2b01      	cmp	r3, #1
    pcb->flags |= TF_RXCLOSED;
 80065ea:	bf1e      	ittt	ne
 80065ec:	7f83      	ldrbne	r3, [r0, #30]
 80065ee:	f043 0310 	orrne.w	r3, r3, #16
 80065f2:	7783      	strbne	r3, [r0, #30]
  return tcp_close_shutdown(pcb, 1);
 80065f4:	f7ff bf56 	b.w	80064a4 <tcp_close_shutdown>

080065f8 <tcp_recv_null>:
{
 80065f8:	b510      	push	{r4, lr}
 80065fa:	4608      	mov	r0, r1
  if (p != NULL) {
 80065fc:	4614      	mov	r4, r2
 80065fe:	b13a      	cbz	r2, 8006610 <tcp_recv_null+0x18>
    tcp_recved(pcb, p->tot_len);
 8006600:	8911      	ldrh	r1, [r2, #8]
 8006602:	f7ff fd33 	bl	800606c <tcp_recved>
    pbuf_free(p);
 8006606:	4620      	mov	r0, r4
 8006608:	f7ff faf5 	bl	8005bf6 <pbuf_free>
}
 800660c:	2000      	movs	r0, #0
 800660e:	bd10      	pop	{r4, pc}
  } else if (err == ERR_OK) {
 8006610:	2b00      	cmp	r3, #0
 8006612:	d1fb      	bne.n	800660c <tcp_recv_null+0x14>
}
 8006614:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return tcp_close(pcb);
 8006618:	f7ff bfe4 	b.w	80065e4 <tcp_close>

0800661c <tcp_process_refused_data>:
{
 800661c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    u8_t refused_flags = pcb->refused_data->flags;
 800661e:	6f86      	ldr	r6, [r0, #120]	; 0x78
    pcb->refused_data = NULL;
 8006620:	2300      	movs	r3, #0
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 8006622:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
{
 8006626:	4604      	mov	r4, r0
    u8_t refused_flags = pcb->refused_data->flags;
 8006628:	7b77      	ldrb	r7, [r6, #13]
    pcb->refused_data = NULL;
 800662a:	6783      	str	r3, [r0, #120]	; 0x78
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800662c:	b1dd      	cbz	r5, 8006666 <tcp_process_refused_data+0x4a>
 800662e:	4601      	mov	r1, r0
 8006630:	4632      	mov	r2, r6
 8006632:	6900      	ldr	r0, [r0, #16]
 8006634:	47a8      	blx	r5
 8006636:	4605      	mov	r5, r0
    if (err == ERR_OK) {
 8006638:	b9e0      	cbnz	r0, 8006674 <tcp_process_refused_data+0x58>
      if (refused_flags & PBUF_FLAG_TCP_FIN
 800663a:	06bb      	lsls	r3, r7, #26
 800663c:	d511      	bpl.n	8006662 <tcp_process_refused_data+0x46>
        if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 800663e:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
        TCP_EVENT_CLOSED(pcb, err);
 8006640:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
        if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 8006644:	f5b3 6f06 	cmp.w	r3, #2144	; 0x860
          pcb->rcv_wnd++;
 8006648:	bf1c      	itt	ne
 800664a:	3301      	addne	r3, #1
 800664c:	85a3      	strhne	r3, [r4, #44]	; 0x2c
        TCP_EVENT_CLOSED(pcb, err);
 800664e:	b146      	cbz	r6, 8006662 <tcp_process_refused_data+0x46>
 8006650:	2300      	movs	r3, #0
 8006652:	4621      	mov	r1, r4
 8006654:	6920      	ldr	r0, [r4, #16]
 8006656:	461a      	mov	r2, r3
 8006658:	47b0      	blx	r6
        if (err == ERR_ABRT) {
 800665a:	300c      	adds	r0, #12
 800665c:	d101      	bne.n	8006662 <tcp_process_refused_data+0x46>
          return ERR_ABRT;
 800665e:	f06f 050b 	mvn.w	r5, #11
}
 8006662:	4628      	mov	r0, r5
 8006664:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 8006666:	4601      	mov	r1, r0
 8006668:	462b      	mov	r3, r5
 800666a:	4632      	mov	r2, r6
 800666c:	4628      	mov	r0, r5
 800666e:	f7ff ffc3 	bl	80065f8 <tcp_recv_null>
 8006672:	e7e0      	b.n	8006636 <tcp_process_refused_data+0x1a>
    } else if (err == ERR_ABRT) {
 8006674:	f110 050c 	adds.w	r5, r0, #12
 8006678:	d0f1      	beq.n	800665e <tcp_process_refused_data+0x42>
      pcb->refused_data = refused_data;
 800667a:	67a6      	str	r6, [r4, #120]	; 0x78
      return ERR_INPROGRESS;
 800667c:	f06f 0504 	mvn.w	r5, #4
 8006680:	e7ef      	b.n	8006662 <tcp_process_refused_data+0x46>
	...

08006684 <tcp_fasttmr>:
{
 8006684:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  ++tcp_timer_ctr;
 8006688:	4d18      	ldr	r5, [pc, #96]	; (80066ec <tcp_fasttmr+0x68>)
  pcb = tcp_active_pcbs;
 800668a:	4f19      	ldr	r7, [pc, #100]	; (80066f0 <tcp_fasttmr+0x6c>)
  ++tcp_timer_ctr;
 800668c:	782b      	ldrb	r3, [r5, #0]
        tcp_active_pcbs_changed = 0;
 800668e:	4e19      	ldr	r6, [pc, #100]	; (80066f4 <tcp_fasttmr+0x70>)
  ++tcp_timer_ctr;
 8006690:	3301      	adds	r3, #1
 8006692:	702b      	strb	r3, [r5, #0]
  pcb = tcp_active_pcbs;
 8006694:	683c      	ldr	r4, [r7, #0]
        tcp_active_pcbs_changed = 0;
 8006696:	f04f 0800 	mov.w	r8, #0
  while (pcb != NULL) {
 800669a:	b90c      	cbnz	r4, 80066a0 <tcp_fasttmr+0x1c>
}
 800669c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (pcb->last_timer != tcp_timer_ctr) {
 80066a0:	782b      	ldrb	r3, [r5, #0]
 80066a2:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
 80066a6:	429a      	cmp	r2, r3
 80066a8:	d01c      	beq.n	80066e4 <tcp_fasttmr+0x60>
      pcb->last_timer = tcp_timer_ctr;
 80066aa:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
      if (pcb->flags & TF_ACK_DELAY) {
 80066ae:	7fa3      	ldrb	r3, [r4, #30]
 80066b0:	07da      	lsls	r2, r3, #31
 80066b2:	d509      	bpl.n	80066c8 <tcp_fasttmr+0x44>
        tcp_ack_now(pcb);
 80066b4:	f043 0302 	orr.w	r3, r3, #2
        tcp_output(pcb);
 80066b8:	4620      	mov	r0, r4
        tcp_ack_now(pcb);
 80066ba:	77a3      	strb	r3, [r4, #30]
        tcp_output(pcb);
 80066bc:	f001 fd3a 	bl	8008134 <tcp_output>
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 80066c0:	7fa3      	ldrb	r3, [r4, #30]
 80066c2:	f023 0303 	bic.w	r3, r3, #3
 80066c6:	77a3      	strb	r3, [r4, #30]
      if (pcb->refused_data != NULL) {
 80066c8:	6fa3      	ldr	r3, [r4, #120]	; 0x78
      next = pcb->next;
 80066ca:	f8d4 900c 	ldr.w	r9, [r4, #12]
      if (pcb->refused_data != NULL) {
 80066ce:	b13b      	cbz	r3, 80066e0 <tcp_fasttmr+0x5c>
        tcp_process_refused_data(pcb);
 80066d0:	4620      	mov	r0, r4
        tcp_active_pcbs_changed = 0;
 80066d2:	f886 8000 	strb.w	r8, [r6]
        tcp_process_refused_data(pcb);
 80066d6:	f7ff ffa1 	bl	800661c <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 80066da:	7833      	ldrb	r3, [r6, #0]
 80066dc:	2b00      	cmp	r3, #0
 80066de:	d1d9      	bne.n	8006694 <tcp_fasttmr+0x10>
{
 80066e0:	464c      	mov	r4, r9
 80066e2:	e7da      	b.n	800669a <tcp_fasttmr+0x16>
      pcb = pcb->next;
 80066e4:	f8d4 900c 	ldr.w	r9, [r4, #12]
 80066e8:	e7fa      	b.n	80066e0 <tcp_fasttmr+0x5c>
 80066ea:	bf00      	nop
 80066ec:	20003e11 	.word	0x20003e11
 80066f0:	20007668 	.word	0x20007668
 80066f4:	20007664 	.word	0x20007664

080066f8 <tcp_tmr>:
{
 80066f8:	b508      	push	{r3, lr}
  tcp_fasttmr();
 80066fa:	f7ff ffc3 	bl	8006684 <tcp_fasttmr>
  if (++tcp_timer & 1) {
 80066fe:	4a06      	ldr	r2, [pc, #24]	; (8006718 <tcp_tmr+0x20>)
 8006700:	7853      	ldrb	r3, [r2, #1]
 8006702:	3301      	adds	r3, #1
 8006704:	b2db      	uxtb	r3, r3
 8006706:	7053      	strb	r3, [r2, #1]
 8006708:	07db      	lsls	r3, r3, #31
 800670a:	d503      	bpl.n	8006714 <tcp_tmr+0x1c>
}
 800670c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    tcp_slowtmr();
 8006710:	f7ff bd2e 	b.w	8006170 <tcp_slowtmr>
 8006714:	bd08      	pop	{r3, pc}
 8006716:	bf00      	nop
 8006718:	20003e11 	.word	0x20003e11

0800671c <tcp_shutdown>:
{
 800671c:	b538      	push	{r3, r4, r5, lr}
 800671e:	4614      	mov	r4, r2
  if (pcb->state == LISTEN) {
 8006720:	7e02      	ldrb	r2, [r0, #24]
{
 8006722:	4605      	mov	r5, r0
  if (pcb->state == LISTEN) {
 8006724:	2a01      	cmp	r2, #1
 8006726:	d01b      	beq.n	8006760 <tcp_shutdown+0x44>
  if (shut_rx) {
 8006728:	b189      	cbz	r1, 800674e <tcp_shutdown+0x32>
    pcb->flags |= TF_RXCLOSED;
 800672a:	7f83      	ldrb	r3, [r0, #30]
 800672c:	f043 0310 	orr.w	r3, r3, #16
 8006730:	7783      	strb	r3, [r0, #30]
    if (shut_tx) {
 8006732:	b124      	cbz	r4, 800673e <tcp_shutdown+0x22>
      return tcp_close_shutdown(pcb, 1);
 8006734:	2101      	movs	r1, #1
}
 8006736:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      return tcp_close_shutdown(pcb, (u8_t)shut_rx);
 800673a:	f7ff beb3 	b.w	80064a4 <tcp_close_shutdown>
    if (pcb->refused_data != NULL) {
 800673e:	6f80      	ldr	r0, [r0, #120]	; 0x78
 8006740:	b908      	cbnz	r0, 8006746 <tcp_shutdown+0x2a>
  return ERR_OK;
 8006742:	2000      	movs	r0, #0
 8006744:	bd38      	pop	{r3, r4, r5, pc}
      pbuf_free(pcb->refused_data);
 8006746:	f7ff fa56 	bl	8005bf6 <pbuf_free>
      pcb->refused_data = NULL;
 800674a:	67ac      	str	r4, [r5, #120]	; 0x78
 800674c:	e7f9      	b.n	8006742 <tcp_shutdown+0x26>
  if (shut_tx) {
 800674e:	2c00      	cmp	r4, #0
 8006750:	d0f7      	beq.n	8006742 <tcp_shutdown+0x26>
 8006752:	2a07      	cmp	r2, #7
 8006754:	d804      	bhi.n	8006760 <tcp_shutdown+0x44>
 8006756:	2301      	movs	r3, #1
 8006758:	4093      	lsls	r3, r2
 800675a:	f013 0f98 	tst.w	r3, #152	; 0x98
 800675e:	d1ea      	bne.n	8006736 <tcp_shutdown+0x1a>
    return ERR_CONN;
 8006760:	f06f 000a 	mvn.w	r0, #10
}
 8006764:	bd38      	pop	{r3, r4, r5, pc}
	...

08006768 <tcp_abandon>:
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 8006768:	7e03      	ldrb	r3, [r0, #24]
  if (pcb->state == TIME_WAIT) {
 800676a:	2b0a      	cmp	r3, #10
{
 800676c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 8006770:	4604      	mov	r4, r0
 8006772:	460f      	mov	r7, r1
  if (pcb->state == TIME_WAIT) {
 8006774:	d10a      	bne.n	800678c <tcp_abandon+0x24>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 8006776:	4601      	mov	r1, r0
 8006778:	482b      	ldr	r0, [pc, #172]	; (8006828 <tcp_abandon+0xc0>)
 800677a:	f7ff fe6b 	bl	8006454 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 800677e:	4621      	mov	r1, r4
 8006780:	2001      	movs	r0, #1
}
 8006782:	b002      	add	sp, #8
 8006784:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    memp_free(MEMP_TCP_PCB, pcb);
 8006788:	f7ff b91a 	b.w	80059c0 <memp_free>
    seqno = pcb->snd_nxt;
 800678c:	f8d0 9050 	ldr.w	r9, [r0, #80]	; 0x50
    ackno = pcb->rcv_nxt;
 8006790:	f8d0 a028 	ldr.w	sl, [r0, #40]	; 0x28
    errf = pcb->errf;
 8006794:	f8d0 608c 	ldr.w	r6, [r0, #140]	; 0x8c
    errf_arg = pcb->callback_arg;
 8006798:	f8d0 8010 	ldr.w	r8, [r0, #16]
 800679c:	8b45      	ldrh	r5, [r0, #26]
    if ((pcb->state == CLOSED) && (pcb->local_port != 0)) {
 800679e:	2b00      	cmp	r3, #0
 80067a0:	d136      	bne.n	8006810 <tcp_abandon+0xa8>
 80067a2:	2d00      	cmp	r5, #0
 80067a4:	d034      	beq.n	8006810 <tcp_abandon+0xa8>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 80067a6:	4a21      	ldr	r2, [pc, #132]	; (800682c <tcp_abandon+0xc4>)
 80067a8:	6813      	ldr	r3, [r2, #0]
 80067aa:	4298      	cmp	r0, r3
 80067ac:	d128      	bne.n	8006800 <tcp_abandon+0x98>
 80067ae:	68c3      	ldr	r3, [r0, #12]
 80067b0:	6013      	str	r3, [r2, #0]
 80067b2:	2500      	movs	r5, #0
    int send_rst = 0;
 80067b4:	462f      	mov	r7, r5
      TCP_RMV(&tcp_bound_pcbs, pcb);
 80067b6:	60e5      	str	r5, [r4, #12]
    if (pcb->unacked != NULL) {
 80067b8:	6f20      	ldr	r0, [r4, #112]	; 0x70
 80067ba:	b108      	cbz	r0, 80067c0 <tcp_abandon+0x58>
      tcp_segs_free(pcb->unacked);
 80067bc:	f7ff fc88 	bl	80060d0 <tcp_segs_free>
    if (pcb->unsent != NULL) {
 80067c0:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80067c2:	b108      	cbz	r0, 80067c8 <tcp_abandon+0x60>
      tcp_segs_free(pcb->unsent);
 80067c4:	f7ff fc84 	bl	80060d0 <tcp_segs_free>
    if (pcb->ooseq != NULL) {
 80067c8:	6f60      	ldr	r0, [r4, #116]	; 0x74
 80067ca:	b108      	cbz	r0, 80067d0 <tcp_abandon+0x68>
      tcp_segs_free(pcb->ooseq);
 80067cc:	f7ff fc80 	bl	80060d0 <tcp_segs_free>
    if (send_rst) {
 80067d0:	b147      	cbz	r7, 80067e4 <tcp_abandon+0x7c>
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
 80067d2:	8ba3      	ldrh	r3, [r4, #28]
 80067d4:	4622      	mov	r2, r4
 80067d6:	9500      	str	r5, [sp, #0]
 80067d8:	4651      	mov	r1, sl
 80067da:	9301      	str	r3, [sp, #4]
 80067dc:	4648      	mov	r0, r9
 80067de:	1d23      	adds	r3, r4, #4
 80067e0:	f001 fde2 	bl	80083a8 <tcp_rst>
    memp_free(MEMP_TCP_PCB, pcb);
 80067e4:	4621      	mov	r1, r4
 80067e6:	2001      	movs	r0, #1
 80067e8:	f7ff f8ea 	bl	80059c0 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 80067ec:	b1c6      	cbz	r6, 8006820 <tcp_abandon+0xb8>
 80067ee:	f06f 010b 	mvn.w	r1, #11
 80067f2:	4640      	mov	r0, r8
 80067f4:	4633      	mov	r3, r6
}
 80067f6:	b002      	add	sp, #8
 80067f8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 80067fc:	4718      	bx	r3
 80067fe:	4613      	mov	r3, r2
      TCP_RMV(&tcp_bound_pcbs, pcb);
 8006800:	2b00      	cmp	r3, #0
 8006802:	d0d6      	beq.n	80067b2 <tcp_abandon+0x4a>
 8006804:	68da      	ldr	r2, [r3, #12]
 8006806:	4294      	cmp	r4, r2
 8006808:	d1f9      	bne.n	80067fe <tcp_abandon+0x96>
 800680a:	68e2      	ldr	r2, [r4, #12]
 800680c:	60da      	str	r2, [r3, #12]
 800680e:	e7d0      	b.n	80067b2 <tcp_abandon+0x4a>
      TCP_PCB_REMOVE_ACTIVE(pcb);
 8006810:	4621      	mov	r1, r4
 8006812:	4807      	ldr	r0, [pc, #28]	; (8006830 <tcp_abandon+0xc8>)
 8006814:	f7ff fe1e 	bl	8006454 <tcp_pcb_remove>
 8006818:	2201      	movs	r2, #1
 800681a:	4b06      	ldr	r3, [pc, #24]	; (8006834 <tcp_abandon+0xcc>)
 800681c:	701a      	strb	r2, [r3, #0]
 800681e:	e7cb      	b.n	80067b8 <tcp_abandon+0x50>
}
 8006820:	b002      	add	sp, #8
 8006822:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8006826:	bf00      	nop
 8006828:	20007678 	.word	0x20007678
 800682c:	20007674 	.word	0x20007674
 8006830:	20007668 	.word	0x20007668
 8006834:	20007664 	.word	0x20007664

08006838 <tcp_abort>:
  tcp_abandon(pcb, 1);
 8006838:	2101      	movs	r1, #1
 800683a:	f7ff bf95 	b.w	8006768 <tcp_abandon>

0800683e <tcp_accept_null>:
  tcp_abort(pcb);
 800683e:	4608      	mov	r0, r1
{
 8006840:	b508      	push	{r3, lr}
  tcp_abort(pcb);
 8006842:	f7ff fff9 	bl	8006838 <tcp_abort>
}
 8006846:	f06f 000b 	mvn.w	r0, #11
 800684a:	bd08      	pop	{r3, pc}

0800684c <tcp_netif_ipv4_addr_changed_pcblist>:

#if LWIP_IPV4
/** Helper function for tcp_netif_ipv4_addr_changed() that iterates a pcb list */
static void
tcp_netif_ipv4_addr_changed_pcblist(const ip4_addr_t* old_addr, struct tcp_pcb* pcb_list)
{
 800684c:	b538      	push	{r3, r4, r5, lr}
 800684e:	4605      	mov	r5, r0
  struct tcp_pcb *pcb;
  pcb = pcb_list;
  while (pcb != NULL) {
 8006850:	b901      	cbnz	r1, 8006854 <tcp_netif_ipv4_addr_changed_pcblist+0x8>
      pcb = next;
    } else {
      pcb = pcb->next;
    }
  }
}
 8006852:	bd38      	pop	{r3, r4, r5, pc}
    if (!IP_IS_V6_VAL(pcb->local_ip) && ip4_addr_cmp(ip_2_ip4(&pcb->local_ip), old_addr)
 8006854:	680a      	ldr	r2, [r1, #0]
 8006856:	682b      	ldr	r3, [r5, #0]
 8006858:	68cc      	ldr	r4, [r1, #12]
 800685a:	429a      	cmp	r2, r3
 800685c:	d102      	bne.n	8006864 <tcp_netif_ipv4_addr_changed_pcblist+0x18>
      tcp_abort(pcb);
 800685e:	4608      	mov	r0, r1
 8006860:	f7ff ffea 	bl	8006838 <tcp_abort>
      pcb = pcb->next;
 8006864:	4621      	mov	r1, r4
 8006866:	e7f3      	b.n	8006850 <tcp_netif_ipv4_addr_changed_pcblist+0x4>

08006868 <tcp_kill_state>:
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8006868:	4b0c      	ldr	r3, [pc, #48]	; (800689c <tcp_kill_state+0x34>)
{
 800686a:	b430      	push	{r4, r5}
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800686c:	6819      	ldr	r1, [r3, #0]
  inactivity = 0;
 800686e:	2400      	movs	r4, #0
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 8006870:	4b0b      	ldr	r3, [pc, #44]	; (80068a0 <tcp_kill_state+0x38>)
  inactive = NULL;
 8006872:	4622      	mov	r2, r4
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 8006874:	681d      	ldr	r5, [r3, #0]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8006876:	b921      	cbnz	r1, 8006882 <tcp_kill_state+0x1a>
  if (inactive != NULL) {
 8006878:	b172      	cbz	r2, 8006898 <tcp_kill_state+0x30>
    tcp_abandon(inactive, 0);
 800687a:	4610      	mov	r0, r2
}
 800687c:	bc30      	pop	{r4, r5}
    tcp_abandon(inactive, 0);
 800687e:	f7ff bf73 	b.w	8006768 <tcp_abandon>
    if (pcb->state == state) {
 8006882:	7e0b      	ldrb	r3, [r1, #24]
 8006884:	4283      	cmp	r3, r0
 8006886:	d105      	bne.n	8006894 <tcp_kill_state+0x2c>
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 8006888:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 800688a:	1aeb      	subs	r3, r5, r3
 800688c:	429c      	cmp	r4, r3
 800688e:	bf9c      	itt	ls
 8006890:	461c      	movls	r4, r3
 8006892:	460a      	movls	r2, r1
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8006894:	68c9      	ldr	r1, [r1, #12]
 8006896:	e7ee      	b.n	8006876 <tcp_kill_state+0xe>
}
 8006898:	bc30      	pop	{r4, r5}
 800689a:	4770      	bx	lr
 800689c:	20007668 	.word	0x20007668
 80068a0:	2000766c 	.word	0x2000766c

080068a4 <tcp_next_iss>:
  iss += tcp_ticks;       /* XXX */
 80068a4:	4b03      	ldr	r3, [pc, #12]	; (80068b4 <tcp_next_iss+0x10>)
 80068a6:	4a04      	ldr	r2, [pc, #16]	; (80068b8 <tcp_next_iss+0x14>)
 80068a8:	6858      	ldr	r0, [r3, #4]
 80068aa:	6812      	ldr	r2, [r2, #0]
 80068ac:	4410      	add	r0, r2
 80068ae:	6058      	str	r0, [r3, #4]
}
 80068b0:	4770      	bx	lr
 80068b2:	bf00      	nop
 80068b4:	2000003c 	.word	0x2000003c
 80068b8:	2000766c 	.word	0x2000766c

080068bc <tcp_alloc>:
{
 80068bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80068be:	4606      	mov	r6, r0
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 80068c0:	2001      	movs	r0, #1
 80068c2:	f7ff f871 	bl	80059a8 <memp_malloc>
 80068c6:	4d44      	ldr	r5, [pc, #272]	; (80069d8 <tcp_alloc+0x11c>)
  if (pcb == NULL) {
 80068c8:	4604      	mov	r4, r0
 80068ca:	2800      	cmp	r0, #0
 80068cc:	d133      	bne.n	8006936 <tcp_alloc+0x7a>
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 80068ce:	4b43      	ldr	r3, [pc, #268]	; (80069dc <tcp_alloc+0x120>)
  inactivity = 0;
 80068d0:	4621      	mov	r1, r4
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 80068d2:	6828      	ldr	r0, [r5, #0]
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 80068d4:	681b      	ldr	r3, [r3, #0]
 80068d6:	2b00      	cmp	r3, #0
 80068d8:	d168      	bne.n	80069ac <tcp_alloc+0xf0>
  if (inactive != NULL) {
 80068da:	b114      	cbz	r4, 80068e2 <tcp_alloc+0x26>
    tcp_abort(inactive);
 80068dc:	4620      	mov	r0, r4
 80068de:	f7ff ffab 	bl	8006838 <tcp_abort>
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 80068e2:	2001      	movs	r0, #1
 80068e4:	f7ff f860 	bl	80059a8 <memp_malloc>
    if (pcb == NULL) {
 80068e8:	4604      	mov	r4, r0
 80068ea:	bb20      	cbnz	r0, 8006936 <tcp_alloc+0x7a>
      tcp_kill_state(LAST_ACK);
 80068ec:	2009      	movs	r0, #9
 80068ee:	f7ff ffbb 	bl	8006868 <tcp_kill_state>
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 80068f2:	2001      	movs	r0, #1
 80068f4:	f7ff f858 	bl	80059a8 <memp_malloc>
      if (pcb == NULL) {
 80068f8:	4604      	mov	r4, r0
 80068fa:	b9e0      	cbnz	r0, 8006936 <tcp_alloc+0x7a>
        tcp_kill_state(CLOSING);
 80068fc:	2008      	movs	r0, #8
 80068fe:	f7ff ffb3 	bl	8006868 <tcp_kill_state>
        pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 8006902:	2001      	movs	r0, #1
 8006904:	f7ff f850 	bl	80059a8 <memp_malloc>
        if (pcb == NULL) {
 8006908:	4604      	mov	r4, r0
 800690a:	b9a0      	cbnz	r0, 8006936 <tcp_alloc+0x7a>
  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
 800690c:	f016 0f80 	tst.w	r6, #128	; 0x80
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8006910:	4b33      	ldr	r3, [pc, #204]	; (80069e0 <tcp_alloc+0x124>)
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 8006912:	f8d5 e000 	ldr.w	lr, [r5]
  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
 8006916:	bf0c      	ite	eq
 8006918:	4631      	moveq	r1, r6
 800691a:	217f      	movne	r1, #127	; 0x7f
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800691c:	681b      	ldr	r3, [r3, #0]
 800691e:	2b00      	cmp	r3, #0
 8006920:	d14c      	bne.n	80069bc <tcp_alloc+0x100>
  if (inactive != NULL) {
 8006922:	b114      	cbz	r4, 800692a <tcp_alloc+0x6e>
    tcp_abort(inactive);
 8006924:	4620      	mov	r0, r4
 8006926:	f7ff ff87 	bl	8006838 <tcp_abort>
          pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800692a:	2001      	movs	r0, #1
 800692c:	f7ff f83c 	bl	80059a8 <memp_malloc>
  if (pcb != NULL) {
 8006930:	4604      	mov	r4, r0
 8006932:	2800      	cmp	r0, #0
 8006934:	d038      	beq.n	80069a8 <tcp_alloc+0xec>
    memset(pcb, 0, sizeof(struct tcp_pcb));
 8006936:	2298      	movs	r2, #152	; 0x98
 8006938:	2100      	movs	r1, #0
 800693a:	4620      	mov	r0, r4
 800693c:	f003 f96c 	bl	8009c18 <memset>
    pcb->snd_buf = TCP_SND_BUF;
 8006940:	f44f 6386 	mov.w	r3, #1072	; 0x430
    pcb->snd_queuelen = 0;
 8006944:	2100      	movs	r1, #0
    pcb->prio = prio;
 8006946:	7666      	strb	r6, [r4, #25]
    pcb->snd_buf = TCP_SND_BUF;
 8006948:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
    pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 800694c:	f44f 6306 	mov.w	r3, #2144	; 0x860
    pcb->snd_queuelen = 0;
 8006950:	f8a4 1068 	strh.w	r1, [r4, #104]	; 0x68
    pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 8006954:	85e3      	strh	r3, [r4, #46]	; 0x2e
 8006956:	85a3      	strh	r3, [r4, #44]	; 0x2c
    pcb->ttl = TCP_TTL;
 8006958:	23ff      	movs	r3, #255	; 0xff
    pcb->tos = 0;
 800695a:	7261      	strb	r1, [r4, #9]
    pcb->ttl = TCP_TTL;
 800695c:	72a3      	strb	r3, [r4, #10]
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 800695e:	f44f 7306 	mov.w	r3, #536	; 0x218
    pcb->sa = 0;
 8006962:	f8a4 1040 	strh.w	r1, [r4, #64]	; 0x40
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 8006966:	86e3      	strh	r3, [r4, #54]	; 0x36
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 8006968:	2306      	movs	r3, #6
 800696a:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 800696e:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
    pcb->rtime = -1;
 8006972:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8006976:	86a3      	strh	r3, [r4, #52]	; 0x34
    pcb->cwnd = 1;
 8006978:	2301      	movs	r3, #1
 800697a:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    iss = tcp_next_iss();
 800697e:	f7ff ff91 	bl	80068a4 <tcp_next_iss>
    pcb->tmr = tcp_ticks;
 8006982:	682b      	ldr	r3, [r5, #0]
    pcb->snd_wl2 = iss;
 8006984:	65a0      	str	r0, [r4, #88]	; 0x58
    pcb->tmr = tcp_ticks;
 8006986:	6263      	str	r3, [r4, #36]	; 0x24
    pcb->last_timer = tcp_timer_ctr;
 8006988:	4b16      	ldr	r3, [pc, #88]	; (80069e4 <tcp_alloc+0x128>)
    pcb->snd_nxt = iss;
 800698a:	6520      	str	r0, [r4, #80]	; 0x50
    pcb->last_timer = tcp_timer_ctr;
 800698c:	781b      	ldrb	r3, [r3, #0]
    pcb->lastack = iss;
 800698e:	64a0      	str	r0, [r4, #72]	; 0x48
    pcb->last_timer = tcp_timer_ctr;
 8006990:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
    pcb->recv = tcp_recv_null;
 8006994:	4b14      	ldr	r3, [pc, #80]	; (80069e8 <tcp_alloc+0x12c>)
    pcb->snd_lbb = iss;
 8006996:	65e0      	str	r0, [r4, #92]	; 0x5c
    pcb->recv = tcp_recv_null;
 8006998:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 800699c:	4b13      	ldr	r3, [pc, #76]	; (80069ec <tcp_alloc+0x130>)
    pcb->polltmr = 0;
 800699e:	77e1      	strb	r1, [r4, #31]
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 80069a0:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    pcb->keep_cnt_sent = 0;
 80069a4:	f884 1096 	strb.w	r1, [r4, #150]	; 0x96
}
 80069a8:	4620      	mov	r0, r4
 80069aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 80069ac:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80069ae:	1a82      	subs	r2, r0, r2
 80069b0:	428a      	cmp	r2, r1
 80069b2:	bf24      	itt	cs
 80069b4:	461c      	movcs	r4, r3
 80069b6:	4611      	movcs	r1, r2
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 80069b8:	68db      	ldr	r3, [r3, #12]
 80069ba:	e78c      	b.n	80068d6 <tcp_alloc+0x1a>
    if (pcb->prio <= mprio &&
 80069bc:	7e5f      	ldrb	r7, [r3, #25]
 80069be:	428f      	cmp	r7, r1
 80069c0:	d807      	bhi.n	80069d2 <tcp_alloc+0x116>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 80069c2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80069c4:	ebae 0202 	sub.w	r2, lr, r2
    if (pcb->prio <= mprio &&
 80069c8:	4282      	cmp	r2, r0
 80069ca:	bf22      	ittt	cs
 80069cc:	4639      	movcs	r1, r7
 80069ce:	4610      	movcs	r0, r2
 80069d0:	461c      	movcs	r4, r3
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80069d2:	68db      	ldr	r3, [r3, #12]
 80069d4:	e7a3      	b.n	800691e <tcp_alloc+0x62>
 80069d6:	bf00      	nop
 80069d8:	2000766c 	.word	0x2000766c
 80069dc:	20007678 	.word	0x20007678
 80069e0:	20007668 	.word	0x20007668
 80069e4:	20003e11 	.word	0x20003e11
 80069e8:	080065f9 	.word	0x080065f9
 80069ec:	006ddd00 	.word	0x006ddd00

080069f0 <tcp_new>:
  return tcp_alloc(TCP_PRIO_NORMAL);
 80069f0:	2040      	movs	r0, #64	; 0x40
 80069f2:	f7ff bf63 	b.w	80068bc <tcp_alloc>

080069f6 <tcp_eff_send_mss_impl>:
{
 80069f6:	b510      	push	{r4, lr}
 80069f8:	4604      	mov	r4, r0
  outif = ip_route(isipv6, src, dest);
 80069fa:	4608      	mov	r0, r1
 80069fc:	f7fe f9c6 	bl	8004d8c <ip4_route>
    if (outif == NULL) {
 8006a00:	b130      	cbz	r0, 8006a10 <tcp_eff_send_mss_impl+0x1a>
    mtu = outif->mtu;
 8006a02:	8c43      	ldrh	r3, [r0, #34]	; 0x22
  if (mtu != 0) {
 8006a04:	b123      	cbz	r3, 8006a10 <tcp_eff_send_mss_impl+0x1a>
      mss_s = mtu - IP_HLEN - TCP_HLEN;
 8006a06:	3b28      	subs	r3, #40	; 0x28
    sendmss = LWIP_MIN(sendmss, mss_s);
 8006a08:	b29b      	uxth	r3, r3
 8006a0a:	429c      	cmp	r4, r3
 8006a0c:	bf28      	it	cs
 8006a0e:	461c      	movcs	r4, r3
}
 8006a10:	4620      	mov	r0, r4
 8006a12:	bd10      	pop	{r4, pc}

08006a14 <tcp_connect>:
{
 8006a14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006a16:	461f      	mov	r7, r3
  if ((pcb == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, ipaddr)) {
 8006a18:	4604      	mov	r4, r0
 8006a1a:	2800      	cmp	r0, #0
 8006a1c:	d061      	beq.n	8006ae2 <tcp_connect+0xce>
  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 8006a1e:	7e03      	ldrb	r3, [r0, #24]
 8006a20:	2b00      	cmp	r3, #0
 8006a22:	d15b      	bne.n	8006adc <tcp_connect+0xc8>
  if (ipaddr != NULL) {
 8006a24:	2900      	cmp	r1, #0
 8006a26:	d05c      	beq.n	8006ae2 <tcp_connect+0xce>
    ip_addr_set(&pcb->remote_ip, ipaddr);
 8006a28:	680b      	ldr	r3, [r1, #0]
  pcb->remote_port = port;
 8006a2a:	8382      	strh	r2, [r0, #28]
    ip_addr_set(&pcb->remote_ip, ipaddr);
 8006a2c:	6043      	str	r3, [r0, #4]
  if (ip_addr_isany(&pcb->local_ip)) {
 8006a2e:	6803      	ldr	r3, [r0, #0]
 8006a30:	b933      	cbnz	r3, 8006a40 <tcp_connect+0x2c>
    ip_route_get_local_ip(PCB_ISIPV6(pcb), &pcb->local_ip, &pcb->remote_ip, netif, local_ip);
 8006a32:	3004      	adds	r0, #4
 8006a34:	f7fe f9aa 	bl	8004d8c <ip4_route>
 8006a38:	2800      	cmp	r0, #0
 8006a3a:	d055      	beq.n	8006ae8 <tcp_connect+0xd4>
    ip_addr_copy(pcb->local_ip, *local_ip);
 8006a3c:	6843      	ldr	r3, [r0, #4]
 8006a3e:	6023      	str	r3, [r4, #0]
  old_local_port = pcb->local_port;
 8006a40:	8b66      	ldrh	r6, [r4, #26]
  if (pcb->local_port == 0) {
 8006a42:	b326      	cbz	r6, 8006a8e <tcp_connect+0x7a>
  iss = tcp_next_iss();
 8006a44:	f7ff ff2e 	bl	80068a4 <tcp_next_iss>
  pcb->snd_nxt = iss;
 8006a48:	6520      	str	r0, [r4, #80]	; 0x50
  pcb->lastack = iss - 1;
 8006a4a:	3801      	subs	r0, #1
  pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 8006a4c:	f44f 6506 	mov.w	r5, #2144	; 0x860
  pcb->rcv_nxt = 0;
 8006a50:	2300      	movs	r3, #0
  pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip, PCB_ISIPV6(pcb));
 8006a52:	1d21      	adds	r1, r4, #4
  pcb->lastack = iss - 1;
 8006a54:	64a0      	str	r0, [r4, #72]	; 0x48
  pcb->snd_lbb = iss - 1;
 8006a56:	65e0      	str	r0, [r4, #92]	; 0x5c
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 8006a58:	f44f 7006 	mov.w	r0, #536	; 0x218
  pcb->rcv_nxt = 0;
 8006a5c:	62a3      	str	r3, [r4, #40]	; 0x28
  pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 8006a5e:	85e5      	strh	r5, [r4, #46]	; 0x2e
 8006a60:	85a5      	strh	r5, [r4, #44]	; 0x2c
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 8006a62:	6323      	str	r3, [r4, #48]	; 0x30
  pcb->snd_wnd = TCP_WND;
 8006a64:	f8a4 5060 	strh.w	r5, [r4, #96]	; 0x60
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 8006a68:	86e0      	strh	r0, [r4, #54]	; 0x36
  pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip, PCB_ISIPV6(pcb));
 8006a6a:	f7ff ffc4 	bl	80069f6 <tcp_eff_send_mss_impl>
  pcb->cwnd = 1;
 8006a6e:	2301      	movs	r3, #1
  pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip, PCB_ISIPV6(pcb));
 8006a70:	86e0      	strh	r0, [r4, #54]	; 0x36
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
 8006a72:	2102      	movs	r1, #2
  pcb->ssthresh = TCP_WND;
 8006a74:	f8a4 504e 	strh.w	r5, [r4, #78]	; 0x4e
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
 8006a78:	4620      	mov	r0, r4
  pcb->cwnd = 1;
 8006a7a:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
  pcb->connected = connected;
 8006a7e:	f8c4 7084 	str.w	r7, [r4, #132]	; 0x84
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
 8006a82:	f001 faac 	bl	8007fde <tcp_enqueue_flags>
  if (ret == ERR_OK) {
 8006a86:	4605      	mov	r5, r0
 8006a88:	b148      	cbz	r0, 8006a9e <tcp_connect+0x8a>
}
 8006a8a:	4628      	mov	r0, r5
 8006a8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    pcb->local_port = tcp_new_port();
 8006a8e:	f7ff fa2b 	bl	8005ee8 <tcp_new_port>
 8006a92:	8360      	strh	r0, [r4, #26]
    if (pcb->local_port == 0) {
 8006a94:	2800      	cmp	r0, #0
 8006a96:	d1d5      	bne.n	8006a44 <tcp_connect+0x30>
      return ERR_BUF;
 8006a98:	f06f 0501 	mvn.w	r5, #1
 8006a9c:	e7f5      	b.n	8006a8a <tcp_connect+0x76>
    pcb->state = SYN_SENT;
 8006a9e:	2302      	movs	r3, #2
 8006aa0:	7623      	strb	r3, [r4, #24]
    if (old_local_port != 0) {
 8006aa2:	b12e      	cbz	r6, 8006ab0 <tcp_connect+0x9c>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 8006aa4:	4a12      	ldr	r2, [pc, #72]	; (8006af0 <tcp_connect+0xdc>)
 8006aa6:	6813      	ldr	r3, [r2, #0]
 8006aa8:	429c      	cmp	r4, r3
 8006aaa:	d10f      	bne.n	8006acc <tcp_connect+0xb8>
 8006aac:	68e3      	ldr	r3, [r4, #12]
 8006aae:	6013      	str	r3, [r2, #0]
    TCP_REG_ACTIVE(pcb);
 8006ab0:	4b10      	ldr	r3, [pc, #64]	; (8006af4 <tcp_connect+0xe0>)
 8006ab2:	681a      	ldr	r2, [r3, #0]
 8006ab4:	601c      	str	r4, [r3, #0]
 8006ab6:	60e2      	str	r2, [r4, #12]
 8006ab8:	f7fe fd8a 	bl	80055d0 <tcp_timer_needed>
 8006abc:	2201      	movs	r2, #1
 8006abe:	4b0e      	ldr	r3, [pc, #56]	; (8006af8 <tcp_connect+0xe4>)
    tcp_output(pcb);
 8006ac0:	4620      	mov	r0, r4
    TCP_REG_ACTIVE(pcb);
 8006ac2:	701a      	strb	r2, [r3, #0]
    tcp_output(pcb);
 8006ac4:	f001 fb36 	bl	8008134 <tcp_output>
 8006ac8:	e7df      	b.n	8006a8a <tcp_connect+0x76>
 8006aca:	4613      	mov	r3, r2
      TCP_RMV(&tcp_bound_pcbs, pcb);
 8006acc:	2b00      	cmp	r3, #0
 8006ace:	d0ef      	beq.n	8006ab0 <tcp_connect+0x9c>
 8006ad0:	68da      	ldr	r2, [r3, #12]
 8006ad2:	4294      	cmp	r4, r2
 8006ad4:	d1f9      	bne.n	8006aca <tcp_connect+0xb6>
 8006ad6:	68e2      	ldr	r2, [r4, #12]
 8006ad8:	60da      	str	r2, [r3, #12]
 8006ada:	e7e9      	b.n	8006ab0 <tcp_connect+0x9c>
  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 8006adc:	f06f 0509 	mvn.w	r5, #9
 8006ae0:	e7d3      	b.n	8006a8a <tcp_connect+0x76>
    return ERR_VAL;
 8006ae2:	f06f 0505 	mvn.w	r5, #5
 8006ae6:	e7d0      	b.n	8006a8a <tcp_connect+0x76>
      return ERR_RTE;
 8006ae8:	f06f 0503 	mvn.w	r5, #3
 8006aec:	e7cd      	b.n	8006a8a <tcp_connect+0x76>
 8006aee:	bf00      	nop
 8006af0:	20007674 	.word	0x20007674
 8006af4:	20007668 	.word	0x20007668
 8006af8:	20007664 	.word	0x20007664

08006afc <tcp_netif_ipv4_addr_changed>:
 *
 * @param old_addr IPv4 address of the netif before change
 * @param new_addr IPv4 address of the netif after change or NULL if netif has been removed
 */
void tcp_netif_ipv4_addr_changed(const ip4_addr_t* old_addr, const ip4_addr_t* new_addr)
{
 8006afc:	b538      	push	{r3, r4, r5, lr}
  struct tcp_pcb_listen *lpcb, *next;

  tcp_netif_ipv4_addr_changed_pcblist(old_addr, tcp_active_pcbs);
 8006afe:	4b0e      	ldr	r3, [pc, #56]	; (8006b38 <tcp_netif_ipv4_addr_changed+0x3c>)
{
 8006b00:	460c      	mov	r4, r1
 8006b02:	4605      	mov	r5, r0
  tcp_netif_ipv4_addr_changed_pcblist(old_addr, tcp_active_pcbs);
 8006b04:	6819      	ldr	r1, [r3, #0]
 8006b06:	f7ff fea1 	bl	800684c <tcp_netif_ipv4_addr_changed_pcblist>
  tcp_netif_ipv4_addr_changed_pcblist(old_addr, tcp_bound_pcbs);
 8006b0a:	4b0c      	ldr	r3, [pc, #48]	; (8006b3c <tcp_netif_ipv4_addr_changed+0x40>)
 8006b0c:	4628      	mov	r0, r5
 8006b0e:	6819      	ldr	r1, [r3, #0]
 8006b10:	f7ff fe9c 	bl	800684c <tcp_netif_ipv4_addr_changed_pcblist>

  if (!ip4_addr_isany(new_addr)) {
 8006b14:	b124      	cbz	r4, 8006b20 <tcp_netif_ipv4_addr_changed+0x24>
 8006b16:	6823      	ldr	r3, [r4, #0]
 8006b18:	b113      	cbz	r3, 8006b20 <tcp_netif_ipv4_addr_changed+0x24>
    /* PCB bound to current local interface address? */
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = next) {
 8006b1a:	4b09      	ldr	r3, [pc, #36]	; (8006b40 <tcp_netif_ipv4_addr_changed+0x44>)
 8006b1c:	681b      	ldr	r3, [r3, #0]
 8006b1e:	b903      	cbnz	r3, 8006b22 <tcp_netif_ipv4_addr_changed+0x26>
 8006b20:	bd38      	pop	{r3, r4, r5, pc}
      next = lpcb->next;
      /* Is this an IPv4 pcb? */
      if (!IP_IS_V6_VAL(lpcb->local_ip)) {
        /* PCB bound to current local interface address? */
        if ((!(ip4_addr_isany(ip_2_ip4(&lpcb->local_ip)))) &&
 8006b22:	681a      	ldr	r2, [r3, #0]
      next = lpcb->next;
 8006b24:	68d9      	ldr	r1, [r3, #12]
        if ((!(ip4_addr_isany(ip_2_ip4(&lpcb->local_ip)))) &&
 8006b26:	b122      	cbz	r2, 8006b32 <tcp_netif_ipv4_addr_changed+0x36>
 8006b28:	6828      	ldr	r0, [r5, #0]
 8006b2a:	4282      	cmp	r2, r0
            (ip4_addr_cmp(ip_2_ip4(&lpcb->local_ip), old_addr))) {
          /* The PCB is listening to the old ipaddr and
           * is set to listen to the new one instead */
              ip_addr_copy_from_ip4(lpcb->local_ip, *new_addr);
 8006b2c:	bf04      	itt	eq
 8006b2e:	6822      	ldreq	r2, [r4, #0]
 8006b30:	601a      	streq	r2, [r3, #0]
{
 8006b32:	460b      	mov	r3, r1
 8006b34:	e7f3      	b.n	8006b1e <tcp_netif_ipv4_addr_changed+0x22>
 8006b36:	bf00      	nop
 8006b38:	20007668 	.word	0x20007668
 8006b3c:	20007674 	.word	0x20007674
 8006b40:	20007670 	.word	0x20007670

08006b44 <tcp_oos_insert_segment>:
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 8006b44:	68c3      	ldr	r3, [r0, #12]
{
 8006b46:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006b4a:	4605      	mov	r5, r0
  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 8006b4c:	8998      	ldrh	r0, [r3, #12]
{
 8006b4e:	460c      	mov	r4, r1
  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 8006b50:	f7fe f849 	bl	8004be6 <lwip_ntohs>
 8006b54:	07c2      	lsls	r2, r0, #31
 8006b56:	d415      	bmi.n	8006b84 <tcp_oos_insert_segment+0x40>
    next = NULL;
  } else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
 8006b58:	4e18      	ldr	r6, [pc, #96]	; (8006bbc <tcp_oos_insert_segment+0x78>)
    while (next &&
 8006b5a:	b1bc      	cbz	r4, 8006b8c <tcp_oos_insert_segment+0x48>
           TCP_SEQ_GEQ((seqno + cseg->len),
 8006b5c:	68e7      	ldr	r7, [r4, #12]
 8006b5e:	6830      	ldr	r0, [r6, #0]
 8006b60:	892b      	ldrh	r3, [r5, #8]
 8006b62:	6879      	ldr	r1, [r7, #4]
 8006b64:	8922      	ldrh	r2, [r4, #8]
 8006b66:	4403      	add	r3, r0
 8006b68:	440a      	add	r2, r1
 8006b6a:	1a9a      	subs	r2, r3, r2
    while (next &&
 8006b6c:	2a00      	cmp	r2, #0
 8006b6e:	da10      	bge.n	8006b92 <tcp_oos_insert_segment+0x4e>
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
 8006b70:	1a5b      	subs	r3, r3, r1
    if (next &&
 8006b72:	2b00      	cmp	r3, #0
 8006b74:	dd0a      	ble.n	8006b8c <tcp_oos_insert_segment+0x48>
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
 8006b76:	1a09      	subs	r1, r1, r0
      pbuf_realloc(cseg->p, cseg->len);
 8006b78:	6868      	ldr	r0, [r5, #4]
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
 8006b7a:	b289      	uxth	r1, r1
 8006b7c:	8129      	strh	r1, [r5, #8]
      pbuf_realloc(cseg->p, cseg->len);
 8006b7e:	f7ff f8e9 	bl	8005d54 <pbuf_realloc>
 8006b82:	e003      	b.n	8006b8c <tcp_oos_insert_segment+0x48>
    tcp_segs_free(next);
 8006b84:	4620      	mov	r0, r4
    next = NULL;
 8006b86:	2400      	movs	r4, #0
    tcp_segs_free(next);
 8006b88:	f7ff faa2 	bl	80060d0 <tcp_segs_free>
    }
  }
  cseg->next = next;
 8006b8c:	602c      	str	r4, [r5, #0]
}
 8006b8e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 8006b92:	89b8      	ldrh	r0, [r7, #12]
 8006b94:	f7fe f827 	bl	8004be6 <lwip_ntohs>
 8006b98:	07c3      	lsls	r3, r0, #31
 8006b9a:	d509      	bpl.n	8006bb0 <tcp_oos_insert_segment+0x6c>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 8006b9c:	f8d5 800c 	ldr.w	r8, [r5, #12]
 8006ba0:	2001      	movs	r0, #1
 8006ba2:	f8b8 700c 	ldrh.w	r7, [r8, #12]
 8006ba6:	f7fe f81b 	bl	8004be0 <lwip_htons>
 8006baa:	4338      	orrs	r0, r7
 8006bac:	f8a8 000c 	strh.w	r0, [r8, #12]
      next = next->next;
 8006bb0:	6827      	ldr	r7, [r4, #0]
      tcp_seg_free(old_seg);
 8006bb2:	4620      	mov	r0, r4
 8006bb4:	f7ff fa7e 	bl	80060b4 <tcp_seg_free>
      next = next->next;
 8006bb8:	463c      	mov	r4, r7
 8006bba:	e7ce      	b.n	8006b5a <tcp_oos_insert_segment+0x16>
 8006bbc:	20003e14 	.word	0x20003e14

08006bc0 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
 8006bc0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
 8006bc4:	4db8      	ldr	r5, [pc, #736]	; (8006ea8 <tcp_receive+0x2e8>)
{
 8006bc6:	4604      	mov	r4, r0
  if (flags & TCP_ACK) {
 8006bc8:	792b      	ldrb	r3, [r5, #4]
 8006bca:	06df      	lsls	r7, r3, #27
 8006bcc:	d568      	bpl.n	8006ca0 <tcp_receive+0xe0>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 8006bce:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8006bd0:	682a      	ldr	r2, [r5, #0]
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 8006bd2:	7e00      	ldrb	r0, [r0, #24]
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 8006bd4:	1a9f      	subs	r7, r3, r2
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 8006bd6:	f8b4 1060 	ldrh.w	r1, [r4, #96]	; 0x60
 8006bda:	6da6      	ldr	r6, [r4, #88]	; 0x58
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 8006bdc:	2f00      	cmp	r7, #0
 8006bde:	db0c      	blt.n	8006bfa <tcp_receive+0x3a>
 8006be0:	4293      	cmp	r3, r2
 8006be2:	d103      	bne.n	8006bec <tcp_receive+0x2c>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 8006be4:	68ab      	ldr	r3, [r5, #8]
 8006be6:	1af3      	subs	r3, r6, r3
 8006be8:	2b00      	cmp	r3, #0
 8006bea:	db06      	blt.n	8006bfa <tcp_receive+0x3a>
 8006bec:	68ab      	ldr	r3, [r5, #8]
 8006bee:	429e      	cmp	r6, r3
 8006bf0:	d11b      	bne.n	8006c2a <tcp_receive+0x6a>
       (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 8006bf2:	68eb      	ldr	r3, [r5, #12]
 8006bf4:	89db      	ldrh	r3, [r3, #14]
 8006bf6:	428b      	cmp	r3, r1
 8006bf8:	d917      	bls.n	8006c2a <tcp_receive+0x6a>
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 8006bfa:	68eb      	ldr	r3, [r5, #12]
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < pcb->snd_wnd) {
 8006bfc:	f8b4 e062 	ldrh.w	lr, [r4, #98]	; 0x62
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 8006c00:	89df      	ldrh	r7, [r3, #14]
        pcb->snd_wnd_max = pcb->snd_wnd;
      }
      pcb->snd_wl1 = seqno;
 8006c02:	6562      	str	r2, [r4, #84]	; 0x54
      if (pcb->snd_wnd_max < pcb->snd_wnd) {
 8006c04:	45be      	cmp	lr, r7
      pcb->snd_wl2 = ackno;
 8006c06:	68aa      	ldr	r2, [r5, #8]
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 8006c08:	f8a4 7060 	strh.w	r7, [r4, #96]	; 0x60
      pcb->snd_wl2 = ackno;
 8006c0c:	65a2      	str	r2, [r4, #88]	; 0x58
        pcb->snd_wnd_max = pcb->snd_wnd;
 8006c0e:	bf38      	it	cc
 8006c10:	f8a4 7062 	strhcc.w	r7, [r4, #98]	; 0x62
 8006c14:	f894 2095 	ldrb.w	r2, [r4, #149]	; 0x95
      if (pcb->snd_wnd == 0) {
 8006c18:	2f00      	cmp	r7, #0
 8006c1a:	f040 80f6 	bne.w	8006e0a <tcp_receive+0x24a>
        if (pcb->persist_backoff == 0) {
 8006c1e:	b922      	cbnz	r2, 8006c2a <tcp_receive+0x6a>
          /* start persist timer */
          pcb->persist_cnt = 0;
          pcb->persist_backoff = 1;
 8006c20:	2301      	movs	r3, #1
          pcb->persist_cnt = 0;
 8006c22:	f884 7094 	strb.w	r7, [r4, #148]	; 0x94
        }
      } else if (pcb->persist_backoff > 0) {
        /* stop persist timer */
          pcb->persist_backoff = 0;
 8006c26:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 8006c2a:	68aa      	ldr	r2, [r5, #8]
 8006c2c:	6ca7      	ldr	r7, [r4, #72]	; 0x48
 8006c2e:	1bd3      	subs	r3, r2, r7
 8006c30:	2b00      	cmp	r3, #0
 8006c32:	f300 80f5 	bgt.w	8006e20 <tcp_receive+0x260>
      pcb->acked = 0;
 8006c36:	2300      	movs	r3, #0
 8006c38:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
      /* Clause 2 */
      if (tcplen == 0) {
 8006c3c:	8a2b      	ldrh	r3, [r5, #16]
 8006c3e:	2b00      	cmp	r3, #0
 8006c40:	f040 835b 	bne.w	80072fa <tcp_receive+0x73a>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
 8006c44:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 8006c48:	4431      	add	r1, r6
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
 8006c4a:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8006c4c:	4403      	add	r3, r0
 8006c4e:	4299      	cmp	r1, r3
 8006c50:	f040 8353 	bne.w	80072fa <tcp_receive+0x73a>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
 8006c54:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
 8006c58:	2b00      	cmp	r3, #0
 8006c5a:	f2c0 834e 	blt.w	80072fa <tcp_receive+0x73a>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
 8006c5e:	42ba      	cmp	r2, r7
 8006c60:	f040 834b 	bne.w	80072fa <tcp_receive+0x73a>
              found_dupack = 1;
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 8006c64:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
 8006c68:	1c53      	adds	r3, r2, #1
 8006c6a:	b2db      	uxtb	r3, r3
 8006c6c:	429a      	cmp	r2, r3
                ++pcb->dupacks;
 8006c6e:	bf38      	it	cc
 8006c70:	f884 3047 	strbcc.w	r3, [r4, #71]	; 0x47
              }
              if (pcb->dupacks > 3) {
 8006c74:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
 8006c78:	2b03      	cmp	r3, #3
 8006c7a:	f240 80cb 	bls.w	8006e14 <tcp_receive+0x254>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((tcpwnd_size_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 8006c7e:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 8006c82:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8006c84:	4413      	add	r3, r2
 8006c86:	b29b      	uxth	r3, r3
 8006c88:	429a      	cmp	r2, r3
 8006c8a:	d201      	bcs.n	8006c90 <tcp_receive+0xd0>
                  pcb->cwnd += pcb->mss;
 8006c8c:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 8006c90:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8006c92:	2b00      	cmp	r3, #0
 8006c94:	f040 814a 	bne.w	8006f2c <tcp_receive+0x36c>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 8006c98:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8006c9a:	2a00      	cmp	r2, #0
 8006c9c:	f040 8189 	bne.w	8006fb2 <tcp_receive+0x3f2>

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 8006ca0:	8a28      	ldrh	r0, [r5, #16]
 8006ca2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8006ca4:	2800      	cmp	r0, #0
 8006ca6:	f000 831c 	beq.w	80072e2 <tcp_receive+0x722>
 8006caa:	7e23      	ldrb	r3, [r4, #24]
 8006cac:	2b06      	cmp	r3, #6
 8006cae:	f200 8318 	bhi.w	80072e2 <tcp_receive+0x722>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 8006cb2:	682b      	ldr	r3, [r5, #0]
 8006cb4:	1ad6      	subs	r6, r2, r3
 8006cb6:	2e01      	cmp	r6, #1
 8006cb8:	f100 81a9 	bmi.w	800700e <tcp_receive+0x44e>
 8006cbc:	f1c3 0101 	rsb	r1, r3, #1
 8006cc0:	1a09      	subs	r1, r1, r0
 8006cc2:	4411      	add	r1, r2
 8006cc4:	2900      	cmp	r1, #0
 8006cc6:	f300 81a2 	bgt.w	800700e <tcp_receive+0x44e>
         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
 8006cca:	69a8      	ldr	r0, [r5, #24]
      off = pcb->rcv_nxt - seqno;
 8006ccc:	4631      	mov	r1, r6
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
 8006cce:	8943      	ldrh	r3, [r0, #10]
 8006cd0:	429e      	cmp	r6, r3
 8006cd2:	f340 819a 	ble.w	800700a <tcp_receive+0x44a>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 8006cd6:	8903      	ldrh	r3, [r0, #8]
 8006cd8:	1b9b      	subs	r3, r3, r6
          off -= p->len;
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
 8006cda:	2600      	movs	r6, #0
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 8006cdc:	b29b      	uxth	r3, r3
        while (p->len < off) {
 8006cde:	8942      	ldrh	r2, [r0, #10]
 8006ce0:	4291      	cmp	r1, r2
 8006ce2:	f300 818d 	bgt.w	8007000 <tcp_receive+0x440>
          p = p->next;
        }
        if (pbuf_header(p, (s16_t)-off)) {
 8006ce6:	4249      	negs	r1, r1
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      } else {
        if (pbuf_header(inseg.p, (s16_t)-off)) {
 8006ce8:	b209      	sxth	r1, r1
 8006cea:	f7fe ff76 	bl	8005bda <pbuf_header>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 8006cee:	8ba9      	ldrh	r1, [r5, #28]
 8006cf0:	682b      	ldr	r3, [r5, #0]
 8006cf2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8006cf4:	440b      	add	r3, r1
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 8006cf6:	602a      	str	r2, [r5, #0]
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 8006cf8:	1a9b      	subs	r3, r3, r2
 8006cfa:	83ab      	strh	r3, [r5, #28]
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 8006cfc:	6a2b      	ldr	r3, [r5, #32]
 8006cfe:	605a      	str	r2, [r3, #4]
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 8006d00:	6829      	ldr	r1, [r5, #0]
 8006d02:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8006d04:	1a8b      	subs	r3, r1, r2
 8006d06:	2b00      	cmp	r3, #0
 8006d08:	f2c0 82e6 	blt.w	80072d8 <tcp_receive+0x718>
 8006d0c:	1c4b      	adds	r3, r1, #1
 8006d0e:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
 8006d10:	1a9b      	subs	r3, r3, r2
 8006d12:	1a1b      	subs	r3, r3, r0
 8006d14:	2b00      	cmp	r3, #0
 8006d16:	f300 82df 	bgt.w	80072d8 <tcp_receive+0x718>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
      if (pcb->rcv_nxt == seqno) {
 8006d1a:	4291      	cmp	r1, r2
 8006d1c:	f040 8223 	bne.w	8007166 <tcp_receive+0x5a6>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 8006d20:	6a2b      	ldr	r3, [r5, #32]
 8006d22:	8bae      	ldrh	r6, [r5, #28]
 8006d24:	8998      	ldrh	r0, [r3, #12]
 8006d26:	f7fd ff5e 	bl	8004be6 <lwip_ntohs>
 8006d2a:	f010 0003 	ands.w	r0, r0, #3

        if (tcplen > pcb->rcv_wnd) {
 8006d2e:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
        tcplen = TCP_TCPLEN(&inseg);
 8006d30:	bf18      	it	ne
 8006d32:	2001      	movne	r0, #1
 8006d34:	4430      	add	r0, r6
 8006d36:	b280      	uxth	r0, r0
        if (tcplen > pcb->rcv_wnd) {
 8006d38:	4283      	cmp	r3, r0
        tcplen = TCP_TCPLEN(&inseg);
 8006d3a:	8228      	strh	r0, [r5, #16]
        if (tcplen > pcb->rcv_wnd) {
 8006d3c:	d22d      	bcs.n	8006d9a <tcp_receive+0x1da>
          LWIP_DEBUGF(TCP_INPUT_DEBUG,
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8006d3e:	6a2b      	ldr	r3, [r5, #32]
 8006d40:	8998      	ldrh	r0, [r3, #12]
 8006d42:	f7fd ff50 	bl	8004be6 <lwip_ntohs>
 8006d46:	07c6      	lsls	r6, r0, #31
 8006d48:	d50c      	bpl.n	8006d64 <tcp_receive+0x1a4>
            /* Must remove the FIN from the header as we're trimming
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~(unsigned int)TCP_FIN);
 8006d4a:	6a2f      	ldr	r7, [r5, #32]
 8006d4c:	89be      	ldrh	r6, [r7, #12]
 8006d4e:	4630      	mov	r0, r6
 8006d50:	f426 567c 	bic.w	r6, r6, #16128	; 0x3f00
 8006d54:	f7fd ff47 	bl	8004be6 <lwip_ntohs>
 8006d58:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 8006d5c:	f7fd ff40 	bl	8004be0 <lwip_htons>
 8006d60:	4306      	orrs	r6, r0
 8006d62:	81be      	strh	r6, [r7, #12]
          }
          /* Adjust length of segment to fit in the window. */
          TCPWND_CHECK16(pcb->rcv_wnd);
          inseg.len = (u16_t)pcb->rcv_wnd;
 8006d64:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8006d66:	83ab      	strh	r3, [r5, #28]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8006d68:	6a2b      	ldr	r3, [r5, #32]
 8006d6a:	8998      	ldrh	r0, [r3, #12]
 8006d6c:	f7fd ff3b 	bl	8004be6 <lwip_ntohs>
 8006d70:	0780      	lsls	r0, r0, #30
            inseg.len -= 1;
          }
          pbuf_realloc(inseg.p, inseg.len);
 8006d72:	69a8      	ldr	r0, [r5, #24]
            inseg.len -= 1;
 8006d74:	bf42      	ittt	mi
 8006d76:	8bab      	ldrhmi	r3, [r5, #28]
 8006d78:	f103 33ff 	addmi.w	r3, r3, #4294967295
 8006d7c:	83ab      	strhmi	r3, [r5, #28]
          pbuf_realloc(inseg.p, inseg.len);
 8006d7e:	8ba9      	ldrh	r1, [r5, #28]
 8006d80:	f7fe ffe8 	bl	8005d54 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 8006d84:	6a2b      	ldr	r3, [r5, #32]
 8006d86:	8bae      	ldrh	r6, [r5, #28]
 8006d88:	8998      	ldrh	r0, [r3, #12]
 8006d8a:	f7fd ff2c 	bl	8004be6 <lwip_ntohs>
 8006d8e:	f010 0003 	ands.w	r0, r0, #3
 8006d92:	bf18      	it	ne
 8006d94:	2001      	movne	r0, #1
 8006d96:	4406      	add	r6, r0
 8006d98:	822e      	strh	r6, [r5, #16]
        }
#if TCP_QUEUE_OOSEQ
        /* Received in-sequence data, adjust ooseq data if:
           - FIN has been received or
           - inseq overlaps with ooseq */
        if (pcb->ooseq != NULL) {
 8006d9a:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8006d9c:	2b00      	cmp	r3, #0
 8006d9e:	f000 8145 	beq.w	800702c <tcp_receive+0x46c>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8006da2:	6a2b      	ldr	r3, [r5, #32]
 8006da4:	8998      	ldrh	r0, [r3, #12]
 8006da6:	f7fd ff1e 	bl	8004be6 <lwip_ntohs>
 8006daa:	07c1      	lsls	r1, r0, #31
 8006dac:	f100 813b 	bmi.w	8007026 <tcp_receive+0x466>
              struct tcp_seg *old_ooseq = pcb->ooseq;
              pcb->ooseq = pcb->ooseq->next;
              tcp_seg_free(old_ooseq);
            }
          } else {
            next = pcb->ooseq;
 8006db0:	6f66      	ldr	r6, [r4, #116]	; 0x74
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 8006db2:	b346      	cbz	r6, 8006e06 <tcp_receive+0x246>
                   TCP_SEQ_GEQ(seqno + tcplen,
 8006db4:	68f7      	ldr	r7, [r6, #12]
 8006db6:	6828      	ldr	r0, [r5, #0]
 8006db8:	8a2b      	ldrh	r3, [r5, #16]
 8006dba:	687a      	ldr	r2, [r7, #4]
 8006dbc:	8931      	ldrh	r1, [r6, #8]
 8006dbe:	4403      	add	r3, r0
 8006dc0:	4411      	add	r1, r2
 8006dc2:	1a59      	subs	r1, r3, r1
            while (next &&
 8006dc4:	2900      	cmp	r1, #0
 8006dc6:	f280 815f 	bge.w	8007088 <tcp_receive+0x4c8>
              tcp_seg_free(prev);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
                TCP_SEQ_GT(seqno + tcplen,
 8006dca:	1a9b      	subs	r3, r3, r2
            if (next &&
 8006dcc:	2b00      	cmp	r3, #0
 8006dce:	dd1a      	ble.n	8006e06 <tcp_receive+0x246>
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8006dd0:	6a2b      	ldr	r3, [r5, #32]
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 8006dd2:	1a12      	subs	r2, r2, r0
 8006dd4:	83aa      	strh	r2, [r5, #28]
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8006dd6:	8998      	ldrh	r0, [r3, #12]
 8006dd8:	f7fd ff05 	bl	8004be6 <lwip_ntohs>
 8006ddc:	0787      	lsls	r7, r0, #30
                inseg.len -= 1;
              }
              pbuf_realloc(inseg.p, inseg.len);
 8006dde:	69a8      	ldr	r0, [r5, #24]
                inseg.len -= 1;
 8006de0:	bf42      	ittt	mi
 8006de2:	8bab      	ldrhmi	r3, [r5, #28]
 8006de4:	f103 33ff 	addmi.w	r3, r3, #4294967295
 8006de8:	83ab      	strhmi	r3, [r5, #28]
              pbuf_realloc(inseg.p, inseg.len);
 8006dea:	8ba9      	ldrh	r1, [r5, #28]
 8006dec:	f7fe ffb2 	bl	8005d54 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
 8006df0:	6a2b      	ldr	r3, [r5, #32]
 8006df2:	8baf      	ldrh	r7, [r5, #28]
 8006df4:	8998      	ldrh	r0, [r3, #12]
 8006df6:	f7fd fef6 	bl	8004be6 <lwip_ntohs>
 8006dfa:	f010 0003 	ands.w	r0, r0, #3
 8006dfe:	bf18      	it	ne
 8006e00:	2001      	movne	r0, #1
 8006e02:	4407      	add	r7, r0
 8006e04:	822f      	strh	r7, [r5, #16]
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
                          (seqno + tcplen) == next->tcphdr->seqno);
            }
            pcb->ooseq = next;
 8006e06:	6766      	str	r6, [r4, #116]	; 0x74
 8006e08:	e110      	b.n	800702c <tcp_receive+0x46c>
      } else if (pcb->persist_backoff > 0) {
 8006e0a:	2a00      	cmp	r2, #0
 8006e0c:	f43f af0d 	beq.w	8006c2a <tcp_receive+0x6a>
          pcb->persist_backoff = 0;
 8006e10:	2300      	movs	r3, #0
 8006e12:	e708      	b.n	8006c26 <tcp_receive+0x66>
              } else if (pcb->dupacks == 3) {
 8006e14:	f47f af3c 	bne.w	8006c90 <tcp_receive+0xd0>
                tcp_rexmit_fast(pcb);
 8006e18:	4620      	mov	r0, r4
 8006e1a:	f001 fb4d 	bl	80084b8 <tcp_rexmit_fast>
 8006e1e:	e737      	b.n	8006c90 <tcp_receive+0xd0>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 8006e20:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8006e22:	1a51      	subs	r1, r2, r1
 8006e24:	2900      	cmp	r1, #0
 8006e26:	dc7a      	bgt.n	8006f1e <tcp_receive+0x35e>
      if (pcb->flags & TF_INFR) {
 8006e28:	7fa1      	ldrb	r1, [r4, #30]
      pcb->acked = (tcpwnd_size_t)(ackno - pcb->lastack);
 8006e2a:	b29b      	uxth	r3, r3
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 8006e2c:	f9b4 7040 	ldrsh.w	r7, [r4, #64]	; 0x40
      if (pcb->flags & TF_INFR) {
 8006e30:	074e      	lsls	r6, r1, #29
      pcb->acked = (tcpwnd_size_t)(ackno - pcb->lastack);
 8006e32:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
      pcb->nrtx = 0;
 8006e36:	f04f 0600 	mov.w	r6, #0
      pcb->lastack = ackno;
 8006e3a:	64a2      	str	r2, [r4, #72]	; 0x48
        pcb->flags &= ~TF_INFR;
 8006e3c:	bf48      	it	mi
 8006e3e:	f021 0104 	bicmi.w	r1, r1, #4
      pcb->nrtx = 0;
 8006e42:	f884 6046 	strb.w	r6, [r4, #70]	; 0x46
        pcb->flags &= ~TF_INFR;
 8006e46:	bf44      	itt	mi
 8006e48:	77a1      	strbmi	r1, [r4, #30]
        pcb->cwnd = pcb->ssthresh;
 8006e4a:	f8b4 104e 	ldrhmi.w	r1, [r4, #78]	; 0x4e
      pcb->dupacks = 0;
 8006e4e:	f884 6047 	strb.w	r6, [r4, #71]	; 0x47
        pcb->cwnd = pcb->ssthresh;
 8006e52:	bf48      	it	mi
 8006e54:	f8a4 104c 	strhmi.w	r1, [r4, #76]	; 0x4c
      if (pcb->state >= ESTABLISHED) {
 8006e58:	2803      	cmp	r0, #3
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 8006e5a:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
 8006e5e:	eb01 01e7 	add.w	r1, r1, r7, asr #3
 8006e62:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
      pcb->snd_buf += pcb->acked;
 8006e66:	f8b4 1066 	ldrh.w	r1, [r4, #102]	; 0x66
 8006e6a:	440b      	add	r3, r1
 8006e6c:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
      if (pcb->state >= ESTABLISHED) {
 8006e70:	d90f      	bls.n	8006e92 <tcp_receive+0x2d2>
        if (pcb->cwnd < pcb->ssthresh) {
 8006e72:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 8006e76:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
 8006e7a:	4293      	cmp	r3, r2
          if ((tcpwnd_size_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 8006e7c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
          tcpwnd_size_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
 8006e7e:	bf9c      	itt	ls
 8006e80:	435b      	mulls	r3, r3
 8006e82:	fb93 f3f2 	sdivls	r3, r3, r2
 8006e86:	4413      	add	r3, r2
 8006e88:	b29b      	uxth	r3, r3
          if (new_cwnd > pcb->cwnd) {
 8006e8a:	429a      	cmp	r2, r3
 8006e8c:	d201      	bcs.n	8006e92 <tcp_receive+0x2d2>
            pcb->cwnd = new_cwnd;
 8006e8e:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
      while (pcb->unacked != NULL &&
 8006e92:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8006e94:	b953      	cbnz	r3, 8006eac <tcp_receive+0x2ec>
      if (pcb->unacked == NULL) {
 8006e96:	6f22      	ldr	r2, [r4, #112]	; 0x70
 8006e98:	2300      	movs	r3, #0
 8006e9a:	2a00      	cmp	r2, #0
 8006e9c:	d13d      	bne.n	8006f1a <tcp_receive+0x35a>
        pcb->rtime = -1;
 8006e9e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006ea2:	86a2      	strh	r2, [r4, #52]	; 0x34
      pcb->polltmr = 0;
 8006ea4:	77e3      	strb	r3, [r4, #31]
 8006ea6:	e6f3      	b.n	8006c90 <tcp_receive+0xd0>
 8006ea8:	20003e14 	.word	0x20003e14
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
 8006eac:	68db      	ldr	r3, [r3, #12]
 8006eae:	6858      	ldr	r0, [r3, #4]
 8006eb0:	f7fd fe9e 	bl	8004bf0 <lwip_ntohl>
 8006eb4:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8006eb6:	4607      	mov	r7, r0
 8006eb8:	891e      	ldrh	r6, [r3, #8]
 8006eba:	68db      	ldr	r3, [r3, #12]
 8006ebc:	8998      	ldrh	r0, [r3, #12]
 8006ebe:	f7fd fe92 	bl	8004be6 <lwip_ntohs>
 8006ec2:	68ab      	ldr	r3, [r5, #8]
 8006ec4:	f010 0003 	ands.w	r0, r0, #3
 8006ec8:	eba6 0603 	sub.w	r6, r6, r3
 8006ecc:	bf18      	it	ne
 8006ece:	2001      	movne	r0, #1
 8006ed0:	443e      	add	r6, r7
 8006ed2:	4406      	add	r6, r0
      while (pcb->unacked != NULL &&
 8006ed4:	2e00      	cmp	r6, #0
 8006ed6:	dcde      	bgt.n	8006e96 <tcp_receive+0x2d6>
        next = pcb->unacked;
 8006ed8:	6f26      	ldr	r6, [r4, #112]	; 0x70
        pcb->unacked = pcb->unacked->next;
 8006eda:	6833      	ldr	r3, [r6, #0]
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 8006edc:	6870      	ldr	r0, [r6, #4]
        pcb->unacked = pcb->unacked->next;
 8006ede:	6723      	str	r3, [r4, #112]	; 0x70
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 8006ee0:	f7fe ff61 	bl	8005da6 <pbuf_clen>
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 8006ee4:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 8006ee8:	b15b      	cbz	r3, 8006f02 <tcp_receive+0x342>
 8006eea:	68f3      	ldr	r3, [r6, #12]
 8006eec:	8998      	ldrh	r0, [r3, #12]
 8006eee:	f7fd fe7a 	bl	8004be6 <lwip_ntohs>
 8006ef2:	07c3      	lsls	r3, r0, #31
          pcb->acked--;
 8006ef4:	bf42      	ittt	mi
 8006ef6:	f8b4 3064 	ldrhmi.w	r3, [r4, #100]	; 0x64
 8006efa:	f103 33ff 	addmi.w	r3, r3, #4294967295
 8006efe:	f8a4 3064 	strhmi.w	r3, [r4, #100]	; 0x64
        pcb->snd_queuelen -= pbuf_clen(next->p);
 8006f02:	6870      	ldr	r0, [r6, #4]
 8006f04:	f7fe ff4f 	bl	8005da6 <pbuf_clen>
 8006f08:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 8006f0c:	1a18      	subs	r0, r3, r0
 8006f0e:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
        tcp_seg_free(next);
 8006f12:	4630      	mov	r0, r6
 8006f14:	f7ff f8ce 	bl	80060b4 <tcp_seg_free>
 8006f18:	e7bb      	b.n	8006e92 <tcp_receive+0x2d2>
        pcb->rtime = 0;
 8006f1a:	86a3      	strh	r3, [r4, #52]	; 0x34
 8006f1c:	e7c2      	b.n	8006ea4 <tcp_receive+0x2e4>
      pcb->acked = 0;
 8006f1e:	2300      	movs	r3, #0
      tcp_send_empty_ack(pcb);
 8006f20:	4620      	mov	r0, r4
      pcb->acked = 0;
 8006f22:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
      tcp_send_empty_ack(pcb);
 8006f26:	f001 f8cf 	bl	80080c8 <tcp_send_empty_ack>
 8006f2a:	e6b1      	b.n	8006c90 <tcp_receive+0xd0>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) +
 8006f2c:	68db      	ldr	r3, [r3, #12]
 8006f2e:	68ae      	ldr	r6, [r5, #8]
 8006f30:	6858      	ldr	r0, [r3, #4]
 8006f32:	f7fd fe5d 	bl	8004bf0 <lwip_ntohl>
 8006f36:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8006f38:	4607      	mov	r7, r0
 8006f3a:	f8b3 8008 	ldrh.w	r8, [r3, #8]
 8006f3e:	68db      	ldr	r3, [r3, #12]
 8006f40:	eba6 0608 	sub.w	r6, r6, r8
 8006f44:	8998      	ldrh	r0, [r3, #12]
 8006f46:	f7fd fe4e 	bl	8004be6 <lwip_ntohs>
 8006f4a:	f010 0003 	ands.w	r0, r0, #3
 8006f4e:	eba6 0607 	sub.w	r6, r6, r7
 8006f52:	bf18      	it	ne
 8006f54:	2001      	movne	r0, #1
 8006f56:	1a36      	subs	r6, r6, r0
    while (pcb->unsent != NULL &&
 8006f58:	2e00      	cmp	r6, #0
 8006f5a:	f6ff ae9d 	blt.w	8006c98 <tcp_receive+0xd8>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) +
 8006f5e:	68ab      	ldr	r3, [r5, #8]
 8006f60:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8006f62:	1a9b      	subs	r3, r3, r2
 8006f64:	2b00      	cmp	r3, #0
 8006f66:	f73f ae97 	bgt.w	8006c98 <tcp_receive+0xd8>
      next = pcb->unsent;
 8006f6a:	6ee6      	ldr	r6, [r4, #108]	; 0x6c
      pcb->unsent = pcb->unsent->next;
 8006f6c:	6833      	ldr	r3, [r6, #0]
 8006f6e:	66e3      	str	r3, [r4, #108]	; 0x6c
      if (pcb->unsent == NULL) {
 8006f70:	b90b      	cbnz	r3, 8006f76 <tcp_receive+0x3b6>
        pcb->unsent_oversize = 0;
 8006f72:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 8006f76:	6870      	ldr	r0, [r6, #4]
 8006f78:	f7fe ff15 	bl	8005da6 <pbuf_clen>
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 8006f7c:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 8006f80:	b15b      	cbz	r3, 8006f9a <tcp_receive+0x3da>
 8006f82:	68f3      	ldr	r3, [r6, #12]
 8006f84:	8998      	ldrh	r0, [r3, #12]
 8006f86:	f7fd fe2e 	bl	8004be6 <lwip_ntohs>
 8006f8a:	07c7      	lsls	r7, r0, #31
        pcb->acked--;
 8006f8c:	bf42      	ittt	mi
 8006f8e:	f8b4 3064 	ldrhmi.w	r3, [r4, #100]	; 0x64
 8006f92:	f103 33ff 	addmi.w	r3, r3, #4294967295
 8006f96:	f8a4 3064 	strhmi.w	r3, [r4, #100]	; 0x64
      pcb->snd_queuelen -= pbuf_clen(next->p);
 8006f9a:	6870      	ldr	r0, [r6, #4]
 8006f9c:	f7fe ff03 	bl	8005da6 <pbuf_clen>
 8006fa0:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 8006fa4:	1a18      	subs	r0, r3, r0
 8006fa6:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
      tcp_seg_free(next);
 8006faa:	4630      	mov	r0, r6
 8006fac:	f7ff f882 	bl	80060b4 <tcp_seg_free>
 8006fb0:	e66e      	b.n	8006c90 <tcp_receive+0xd0>
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 8006fb2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8006fb4:	68a9      	ldr	r1, [r5, #8]
 8006fb6:	1a5b      	subs	r3, r3, r1
 8006fb8:	2b00      	cmp	r3, #0
 8006fba:	f6bf ae71 	bge.w	8006ca0 <tcp_receive+0xe0>
      m = (s16_t)(tcp_ticks - pcb->rttest);
 8006fbe:	4b97      	ldr	r3, [pc, #604]	; (800721c <tcp_receive+0x65c>)
      m = m - (pcb->sa >> 3);
 8006fc0:	f9b4 0040 	ldrsh.w	r0, [r4, #64]	; 0x40
      m = (s16_t)(tcp_ticks - pcb->rttest);
 8006fc4:	6819      	ldr	r1, [r3, #0]
 8006fc6:	1a89      	subs	r1, r1, r2
      m = m - (pcb->sv >> 2);
 8006fc8:	f9b4 2042 	ldrsh.w	r2, [r4, #66]	; 0x42
      m = m - (pcb->sa >> 3);
 8006fcc:	eba1 01e0 	sub.w	r1, r1, r0, asr #3
      pcb->sv += m;
 8006fd0:	eba2 02a2 	sub.w	r2, r2, r2, asr #2
      m = m - (pcb->sa >> 3);
 8006fd4:	b289      	uxth	r1, r1
 8006fd6:	b20b      	sxth	r3, r1
      pcb->sa += m;
 8006fd8:	4408      	add	r0, r1
      if (m < 0) {
 8006fda:	2b00      	cmp	r3, #0
      pcb->sa += m;
 8006fdc:	b200      	sxth	r0, r0
        m = -m;
 8006fde:	bfb8      	it	lt
 8006fe0:	4249      	neglt	r1, r1
      pcb->sa += m;
 8006fe2:	f8a4 0040 	strh.w	r0, [r4, #64]	; 0x40
        m = -m;
 8006fe6:	bfb8      	it	lt
 8006fe8:	b20b      	sxthlt	r3, r1
      pcb->sv += m;
 8006fea:	4413      	add	r3, r2
 8006fec:	b29b      	uxth	r3, r3
 8006fee:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 8006ff2:	eb03 03e0 	add.w	r3, r3, r0, asr #3
 8006ff6:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
      pcb->rttest = 0;
 8006ffa:	2300      	movs	r3, #0
 8006ffc:	63a3      	str	r3, [r4, #56]	; 0x38
 8006ffe:	e64f      	b.n	8006ca0 <tcp_receive+0xe0>
          p->tot_len = new_tot_len;
 8007000:	8103      	strh	r3, [r0, #8]
          off -= p->len;
 8007002:	1a89      	subs	r1, r1, r2
          p->len = 0;
 8007004:	8146      	strh	r6, [r0, #10]
          p = p->next;
 8007006:	6800      	ldr	r0, [r0, #0]
 8007008:	e669      	b.n	8006cde <tcp_receive+0x11e>
        if (pbuf_header(inseg.p, (s16_t)-off)) {
 800700a:	4271      	negs	r1, r6
 800700c:	e66c      	b.n	8006ce8 <tcp_receive+0x128>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
 800700e:	1a9b      	subs	r3, r3, r2
 8007010:	2b00      	cmp	r3, #0
        tcp_ack_now(pcb);
 8007012:	bfbe      	ittt	lt
 8007014:	7fa3      	ldrblt	r3, [r4, #30]
 8007016:	f043 0302 	orrlt.w	r3, r3, #2
 800701a:	77a3      	strblt	r3, [r4, #30]
 800701c:	e670      	b.n	8006d00 <tcp_receive+0x140>
              pcb->ooseq = pcb->ooseq->next;
 800701e:	6803      	ldr	r3, [r0, #0]
 8007020:	6763      	str	r3, [r4, #116]	; 0x74
              tcp_seg_free(old_ooseq);
 8007022:	f7ff f847 	bl	80060b4 <tcp_seg_free>
            while (pcb->ooseq != NULL) {
 8007026:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8007028:	2800      	cmp	r0, #0
 800702a:	d1f8      	bne.n	800701e <tcp_receive+0x45e>
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 800702c:	8a29      	ldrh	r1, [r5, #16]

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
        pcb->rcv_wnd -= tcplen;

        tcp_update_rcv_ann_wnd(pcb);
 800702e:	4620      	mov	r0, r4
        pcb->rcv_wnd -= tcplen;
 8007030:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
        pcb->rcv_nxt = seqno + tcplen;
 8007032:	682a      	ldr	r2, [r5, #0]
        pcb->rcv_wnd -= tcplen;
 8007034:	1a5b      	subs	r3, r3, r1
        pcb->rcv_nxt = seqno + tcplen;
 8007036:	440a      	add	r2, r1
        pcb->rcv_wnd -= tcplen;
 8007038:	85a3      	strh	r3, [r4, #44]	; 0x2c
        pcb->rcv_nxt = seqno + tcplen;
 800703a:	62a2      	str	r2, [r4, #40]	; 0x28
        tcp_update_rcv_ann_wnd(pcb);
 800703c:	f7fe fffc 	bl	8006038 <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
 8007040:	69ab      	ldr	r3, [r5, #24]
 8007042:	891a      	ldrh	r2, [r3, #8]
 8007044:	b112      	cbz	r2, 800704c <tcp_receive+0x48c>
          recv_data = inseg.p;
 8007046:	626b      	str	r3, [r5, #36]	; 0x24
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 8007048:	2300      	movs	r3, #0
 800704a:	61ab      	str	r3, [r5, #24]
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800704c:	6a2b      	ldr	r3, [r5, #32]
            if (recv_data) {
              pbuf_cat(recv_data, cseg->p);
            } else {
              recv_data = cseg->p;
            }
            cseg->p = NULL;
 800704e:	2700      	movs	r7, #0
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
              pcb->state = CLOSE_WAIT;
 8007050:	f04f 0807 	mov.w	r8, #7
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8007054:	8998      	ldrh	r0, [r3, #12]
 8007056:	f7fd fdc6 	bl	8004be6 <lwip_ntohs>
 800705a:	07c6      	lsls	r6, r0, #31
          recv_flags |= TF_GOT_FIN;
 800705c:	bf42      	ittt	mi
 800705e:	f895 3028 	ldrbmi.w	r3, [r5, #40]	; 0x28
 8007062:	f043 0320 	orrmi.w	r3, r3, #32
 8007066:	f885 3028 	strbmi.w	r3, [r5, #40]	; 0x28
        while (pcb->ooseq != NULL &&
 800706a:	6f66      	ldr	r6, [r4, #116]	; 0x74
 800706c:	b126      	cbz	r6, 8007078 <tcp_receive+0x4b8>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 800706e:	68f2      	ldr	r2, [r6, #12]
        while (pcb->ooseq != NULL &&
 8007070:	6aa1      	ldr	r1, [r4, #40]	; 0x28
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 8007072:	6853      	ldr	r3, [r2, #4]
        while (pcb->ooseq != NULL &&
 8007074:	428b      	cmp	r3, r1
 8007076:	d02d      	beq.n	80070d4 <tcp_receive+0x514>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 8007078:	7fa3      	ldrb	r3, [r4, #30]
 800707a:	07d9      	lsls	r1, r3, #31
 800707c:	d56e      	bpl.n	800715c <tcp_receive+0x59c>
 800707e:	f023 0301 	bic.w	r3, r3, #1
    }
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
      tcp_ack_now(pcb);
 8007082:	f043 0302 	orr.w	r3, r3, #2
 8007086:	e06b      	b.n	8007160 <tcp_receive+0x5a0>
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
 8007088:	89b8      	ldrh	r0, [r7, #12]
 800708a:	f7fd fdac 	bl	8004be6 <lwip_ntohs>
 800708e:	07c2      	lsls	r2, r0, #31
 8007090:	d51a      	bpl.n	80070c8 <tcp_receive+0x508>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 8007092:	6a2b      	ldr	r3, [r5, #32]
 8007094:	8998      	ldrh	r0, [r3, #12]
 8007096:	f7fd fda6 	bl	8004be6 <lwip_ntohs>
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
 800709a:	0783      	lsls	r3, r0, #30
 800709c:	d414      	bmi.n	80070c8 <tcp_receive+0x508>
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 800709e:	f8d5 8020 	ldr.w	r8, [r5, #32]
 80070a2:	2001      	movs	r0, #1
 80070a4:	f8b8 700c 	ldrh.w	r7, [r8, #12]
 80070a8:	f7fd fd9a 	bl	8004be0 <lwip_htons>
                tcplen = TCP_TCPLEN(&inseg);
 80070ac:	6a2b      	ldr	r3, [r5, #32]
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 80070ae:	4338      	orrs	r0, r7
                tcplen = TCP_TCPLEN(&inseg);
 80070b0:	8baf      	ldrh	r7, [r5, #28]
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 80070b2:	f8a8 000c 	strh.w	r0, [r8, #12]
                tcplen = TCP_TCPLEN(&inseg);
 80070b6:	8998      	ldrh	r0, [r3, #12]
 80070b8:	f7fd fd95 	bl	8004be6 <lwip_ntohs>
 80070bc:	f010 0003 	ands.w	r0, r0, #3
 80070c0:	bf18      	it	ne
 80070c2:	2001      	movne	r0, #1
 80070c4:	4407      	add	r7, r0
 80070c6:	822f      	strh	r7, [r5, #16]
              next = next->next;
 80070c8:	6837      	ldr	r7, [r6, #0]
              tcp_seg_free(prev);
 80070ca:	4630      	mov	r0, r6
 80070cc:	f7fe fff2 	bl	80060b4 <tcp_seg_free>
              next = next->next;
 80070d0:	463e      	mov	r6, r7
 80070d2:	e66e      	b.n	8006db2 <tcp_receive+0x1f2>
          seqno = pcb->ooseq->tcphdr->seqno;
 80070d4:	602b      	str	r3, [r5, #0]
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 80070d6:	8990      	ldrh	r0, [r2, #12]
 80070d8:	f8b6 9008 	ldrh.w	r9, [r6, #8]
 80070dc:	f7fd fd83 	bl	8004be6 <lwip_ntohs>
 80070e0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80070e2:	f010 0003 	ands.w	r0, r0, #3
 80070e6:	4499      	add	r9, r3
 80070e8:	bf18      	it	ne
 80070ea:	2001      	movne	r0, #1
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 80070ec:	68f3      	ldr	r3, [r6, #12]
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 80070ee:	4448      	add	r0, r9
 80070f0:	62a0      	str	r0, [r4, #40]	; 0x28
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 80070f2:	8998      	ldrh	r0, [r3, #12]
 80070f4:	f7fd fd77 	bl	8004be6 <lwip_ntohs>
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 80070f8:	68f3      	ldr	r3, [r6, #12]
 80070fa:	f8b6 9008 	ldrh.w	r9, [r6, #8]
 80070fe:	8998      	ldrh	r0, [r3, #12]
 8007100:	f7fd fd71 	bl	8004be6 <lwip_ntohs>
 8007104:	f010 0003 	ands.w	r0, r0, #3
 8007108:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 800710a:	bf18      	it	ne
 800710c:	2001      	movne	r0, #1
 800710e:	4448      	add	r0, r9
 8007110:	1a18      	subs	r0, r3, r0
 8007112:	85a0      	strh	r0, [r4, #44]	; 0x2c
          tcp_update_rcv_ann_wnd(pcb);
 8007114:	4620      	mov	r0, r4
 8007116:	f7fe ff8f 	bl	8006038 <tcp_update_rcv_ann_wnd>
          if (cseg->p->tot_len > 0) {
 800711a:	6871      	ldr	r1, [r6, #4]
 800711c:	890b      	ldrh	r3, [r1, #8]
 800711e:	b123      	cbz	r3, 800712a <tcp_receive+0x56a>
            if (recv_data) {
 8007120:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8007122:	b1c8      	cbz	r0, 8007158 <tcp_receive+0x598>
              pbuf_cat(recv_data, cseg->p);
 8007124:	f7fe fe4c 	bl	8005dc0 <pbuf_cat>
            cseg->p = NULL;
 8007128:	6077      	str	r7, [r6, #4]
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 800712a:	68f3      	ldr	r3, [r6, #12]
 800712c:	8998      	ldrh	r0, [r3, #12]
 800712e:	f7fd fd5a 	bl	8004be6 <lwip_ntohs>
 8007132:	07c0      	lsls	r0, r0, #31
 8007134:	d50a      	bpl.n	800714c <tcp_receive+0x58c>
            recv_flags |= TF_GOT_FIN;
 8007136:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 800713a:	f043 0320 	orr.w	r3, r3, #32
 800713e:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
 8007142:	7e23      	ldrb	r3, [r4, #24]
 8007144:	2b04      	cmp	r3, #4
              pcb->state = CLOSE_WAIT;
 8007146:	bf08      	it	eq
 8007148:	f884 8018 	strbeq.w	r8, [r4, #24]
          pcb->ooseq = cseg->next;
 800714c:	6833      	ldr	r3, [r6, #0]
          tcp_seg_free(cseg);
 800714e:	4630      	mov	r0, r6
          pcb->ooseq = cseg->next;
 8007150:	6763      	str	r3, [r4, #116]	; 0x74
          tcp_seg_free(cseg);
 8007152:	f7fe ffaf 	bl	80060b4 <tcp_seg_free>
 8007156:	e788      	b.n	800706a <tcp_receive+0x4aa>
              recv_data = cseg->p;
 8007158:	6269      	str	r1, [r5, #36]	; 0x24
 800715a:	e7e5      	b.n	8007128 <tcp_receive+0x568>
        tcp_ack(pcb);
 800715c:	f043 0301 	orr.w	r3, r3, #1
      tcp_ack_now(pcb);
 8007160:	77a3      	strb	r3, [r4, #30]
    }
  }
}
 8007162:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        tcp_send_empty_ack(pcb);
 8007166:	4620      	mov	r0, r4
 8007168:	f000 ffae 	bl	80080c8 <tcp_send_empty_ack>
        if (pcb->ooseq == NULL) {
 800716c:	6f66      	ldr	r6, [r4, #116]	; 0x74
 800716e:	b92e      	cbnz	r6, 800717c <tcp_receive+0x5bc>
          pcb->ooseq = tcp_seg_copy(&inseg);
 8007170:	482b      	ldr	r0, [pc, #172]	; (8007220 <tcp_receive+0x660>)
 8007172:	f7fe ffb5 	bl	80060e0 <tcp_seg_copy>
 8007176:	6760      	str	r0, [r4, #116]	; 0x74
 8007178:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            if (seqno == next->tcphdr->seqno) {
 800717c:	682b      	ldr	r3, [r5, #0]
 800717e:	2700      	movs	r7, #0
 8007180:	f103 3eff 	add.w	lr, r3, #4294967295
 8007184:	f103 0c01 	add.w	ip, r3, #1
 8007188:	68f0      	ldr	r0, [r6, #12]
 800718a:	6842      	ldr	r2, [r0, #4]
 800718c:	429a      	cmp	r2, r3
 800718e:	d115      	bne.n	80071bc <tcp_receive+0x5fc>
              if (inseg.len > next->len) {
 8007190:	8baa      	ldrh	r2, [r5, #28]
 8007192:	8933      	ldrh	r3, [r6, #8]
 8007194:	429a      	cmp	r2, r3
 8007196:	f240 80b4 	bls.w	8007302 <tcp_receive+0x742>
                cseg = tcp_seg_copy(&inseg);
 800719a:	4821      	ldr	r0, [pc, #132]	; (8007220 <tcp_receive+0x660>)
 800719c:	f7fe ffa0 	bl	80060e0 <tcp_seg_copy>
                if (cseg != NULL) {
 80071a0:	2800      	cmp	r0, #0
 80071a2:	f000 80ae 	beq.w	8007302 <tcp_receive+0x742>
                  if (prev != NULL) {
 80071a6:	b13f      	cbz	r7, 80071b8 <tcp_receive+0x5f8>
                    prev->next = cseg;
 80071a8:	6038      	str	r0, [r7, #0]
                    tcp_oos_insert_segment(cseg, next);
 80071aa:	4631      	mov	r1, r6
}
 80071ac:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
                    tcp_oos_insert_segment(cseg, next);
 80071b0:	f7ff bcc8 	b.w	8006b44 <tcp_oos_insert_segment>
 80071b4:	460e      	mov	r6, r1
 80071b6:	e7e7      	b.n	8007188 <tcp_receive+0x5c8>
                    pcb->ooseq = cseg;
 80071b8:	6760      	str	r0, [r4, #116]	; 0x74
 80071ba:	e7f6      	b.n	80071aa <tcp_receive+0x5ea>
              if (prev == NULL) {
 80071bc:	b957      	cbnz	r7, 80071d4 <tcp_receive+0x614>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
 80071be:	1a99      	subs	r1, r3, r2
 80071c0:	2900      	cmp	r1, #0
 80071c2:	da2f      	bge.n	8007224 <tcp_receive+0x664>
                  cseg = tcp_seg_copy(&inseg);
 80071c4:	4816      	ldr	r0, [pc, #88]	; (8007220 <tcp_receive+0x660>)
 80071c6:	f7fe ff8b 	bl	80060e0 <tcp_seg_copy>
                  if (cseg != NULL) {
 80071ca:	2800      	cmp	r0, #0
 80071cc:	f000 8099 	beq.w	8007302 <tcp_receive+0x742>
                    pcb->ooseq = cseg;
 80071d0:	6760      	str	r0, [r4, #116]	; 0x74
 80071d2:	e7ea      	b.n	80071aa <tcp_receive+0x5ea>
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
 80071d4:	68f9      	ldr	r1, [r7, #12]
 80071d6:	6849      	ldr	r1, [r1, #4]
 80071d8:	ebae 0101 	sub.w	r1, lr, r1
 80071dc:	2900      	cmp	r1, #0
 80071de:	db21      	blt.n	8007224 <tcp_receive+0x664>
 80071e0:	ebac 0102 	sub.w	r1, ip, r2
 80071e4:	2900      	cmp	r1, #0
 80071e6:	dc1d      	bgt.n	8007224 <tcp_receive+0x664>
                  cseg = tcp_seg_copy(&inseg);
 80071e8:	480d      	ldr	r0, [pc, #52]	; (8007220 <tcp_receive+0x660>)
 80071ea:	f7fe ff79 	bl	80060e0 <tcp_seg_copy>
                  if (cseg != NULL) {
 80071ee:	4604      	mov	r4, r0
 80071f0:	2800      	cmp	r0, #0
 80071f2:	f000 8086 	beq.w	8007302 <tcp_receive+0x742>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
 80071f6:	68fb      	ldr	r3, [r7, #12]
 80071f8:	6829      	ldr	r1, [r5, #0]
 80071fa:	685a      	ldr	r2, [r3, #4]
 80071fc:	893b      	ldrh	r3, [r7, #8]
 80071fe:	4413      	add	r3, r2
 8007200:	1a5b      	subs	r3, r3, r1
 8007202:	2b00      	cmp	r3, #0
 8007204:	dd05      	ble.n	8007212 <tcp_receive+0x652>
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
 8007206:	1a89      	subs	r1, r1, r2
                      pbuf_realloc(prev->p, prev->len);
 8007208:	6878      	ldr	r0, [r7, #4]
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
 800720a:	b289      	uxth	r1, r1
 800720c:	8139      	strh	r1, [r7, #8]
                      pbuf_realloc(prev->p, prev->len);
 800720e:	f7fe fda1 	bl	8005d54 <pbuf_realloc>
                    prev->next = cseg;
 8007212:	603c      	str	r4, [r7, #0]
                    tcp_oos_insert_segment(cseg, next);
 8007214:	4631      	mov	r1, r6
 8007216:	4620      	mov	r0, r4
 8007218:	e7c8      	b.n	80071ac <tcp_receive+0x5ec>
 800721a:	bf00      	nop
 800721c:	2000766c 	.word	0x2000766c
 8007220:	20003e28 	.word	0x20003e28
              if (next->next == NULL &&
 8007224:	6831      	ldr	r1, [r6, #0]
 8007226:	4637      	mov	r7, r6
 8007228:	2900      	cmp	r1, #0
 800722a:	d1c3      	bne.n	80071b4 <tcp_receive+0x5f4>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
 800722c:	1a9b      	subs	r3, r3, r2
              if (next->next == NULL &&
 800722e:	2b00      	cmp	r3, #0
 8007230:	dd67      	ble.n	8007302 <tcp_receive+0x742>
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 8007232:	8980      	ldrh	r0, [r0, #12]
 8007234:	f7fd fcd7 	bl	8004be6 <lwip_ntohs>
 8007238:	07c2      	lsls	r2, r0, #31
 800723a:	d462      	bmi.n	8007302 <tcp_receive+0x742>
                next->next = tcp_seg_copy(&inseg);
 800723c:	4832      	ldr	r0, [pc, #200]	; (8007308 <tcp_receive+0x748>)
 800723e:	f7fe ff4f 	bl	80060e0 <tcp_seg_copy>
 8007242:	6030      	str	r0, [r6, #0]
                if (next->next != NULL) {
 8007244:	2800      	cmp	r0, #0
 8007246:	d05c      	beq.n	8007302 <tcp_receive+0x742>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
 8007248:	68f3      	ldr	r3, [r6, #12]
 800724a:	6829      	ldr	r1, [r5, #0]
 800724c:	685a      	ldr	r2, [r3, #4]
 800724e:	8933      	ldrh	r3, [r6, #8]
 8007250:	4413      	add	r3, r2
 8007252:	1a5b      	subs	r3, r3, r1
 8007254:	2b00      	cmp	r3, #0
 8007256:	dd05      	ble.n	8007264 <tcp_receive+0x6a4>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
 8007258:	1a89      	subs	r1, r1, r2
                    pbuf_realloc(next->p, next->len);
 800725a:	6870      	ldr	r0, [r6, #4]
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
 800725c:	b289      	uxth	r1, r1
 800725e:	8131      	strh	r1, [r6, #8]
                    pbuf_realloc(next->p, next->len);
 8007260:	f7fe fd78 	bl	8005d54 <pbuf_realloc>
                  if (TCP_SEQ_GT((u32_t)tcplen + seqno, pcb->rcv_nxt + (u32_t)pcb->rcv_wnd)) {
 8007264:	682a      	ldr	r2, [r5, #0]
 8007266:	8a2b      	ldrh	r3, [r5, #16]
 8007268:	4413      	add	r3, r2
 800726a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800726c:	1a9b      	subs	r3, r3, r2
 800726e:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 8007270:	1a9b      	subs	r3, r3, r2
 8007272:	2b00      	cmp	r3, #0
 8007274:	dd45      	ble.n	8007302 <tcp_receive+0x742>
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
 8007276:	6833      	ldr	r3, [r6, #0]
 8007278:	68db      	ldr	r3, [r3, #12]
 800727a:	8998      	ldrh	r0, [r3, #12]
 800727c:	f7fd fcb3 	bl	8004be6 <lwip_ntohs>
 8007280:	07c3      	lsls	r3, r0, #31
 8007282:	d510      	bpl.n	80072a6 <tcp_receive+0x6e6>
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) & ~TCP_FIN);
 8007284:	6833      	ldr	r3, [r6, #0]
 8007286:	f8d3 800c 	ldr.w	r8, [r3, #12]
 800728a:	f8b8 700c 	ldrh.w	r7, [r8, #12]
 800728e:	4638      	mov	r0, r7
 8007290:	f427 577c 	bic.w	r7, r7, #16128	; 0x3f00
 8007294:	f7fd fca7 	bl	8004be6 <lwip_ntohs>
 8007298:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 800729c:	f7fd fca0 	bl	8004be0 <lwip_htons>
 80072a0:	4307      	orrs	r7, r0
 80072a2:	f8a8 700c 	strh.w	r7, [r8, #12]
                    next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
 80072a6:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
 80072a8:	682a      	ldr	r2, [r5, #0]
 80072aa:	6833      	ldr	r3, [r6, #0]
 80072ac:	1a89      	subs	r1, r1, r2
 80072ae:	6aa2      	ldr	r2, [r4, #40]	; 0x28
                    pbuf_realloc(next->next->p, next->next->len);
 80072b0:	6858      	ldr	r0, [r3, #4]
                    next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
 80072b2:	4411      	add	r1, r2
 80072b4:	b289      	uxth	r1, r1
 80072b6:	8119      	strh	r1, [r3, #8]
                    pbuf_realloc(next->next->p, next->next->len);
 80072b8:	f7fe fd4c 	bl	8005d54 <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
 80072bc:	6833      	ldr	r3, [r6, #0]
 80072be:	891c      	ldrh	r4, [r3, #8]
 80072c0:	68db      	ldr	r3, [r3, #12]
 80072c2:	8998      	ldrh	r0, [r3, #12]
 80072c4:	f7fd fc8f 	bl	8004be6 <lwip_ntohs>
 80072c8:	f010 0003 	ands.w	r0, r0, #3
 80072cc:	bf18      	it	ne
 80072ce:	2001      	movne	r0, #1
 80072d0:	4404      	add	r4, r0
 80072d2:	822c      	strh	r4, [r5, #16]
 80072d4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      tcp_send_empty_ack(pcb);
 80072d8:	4620      	mov	r0, r4
}
 80072da:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
      tcp_send_empty_ack(pcb);
 80072de:	f000 bef3 	b.w	80080c8 <tcp_send_empty_ack>
    if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
 80072e2:	682b      	ldr	r3, [r5, #0]
 80072e4:	1a99      	subs	r1, r3, r2
 80072e6:	2900      	cmp	r1, #0
 80072e8:	db05      	blt.n	80072f6 <tcp_receive+0x736>
 80072ea:	3301      	adds	r3, #1
 80072ec:	1a9b      	subs	r3, r3, r2
 80072ee:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 80072f0:	1a9b      	subs	r3, r3, r2
 80072f2:	2b00      	cmp	r3, #0
 80072f4:	dd05      	ble.n	8007302 <tcp_receive+0x742>
      tcp_ack_now(pcb);
 80072f6:	7fa3      	ldrb	r3, [r4, #30]
 80072f8:	e6c3      	b.n	8007082 <tcp_receive+0x4c2>
        pcb->dupacks = 0;
 80072fa:	2300      	movs	r3, #0
 80072fc:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
 8007300:	e4c6      	b.n	8006c90 <tcp_receive+0xd0>
 8007302:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8007306:	bf00      	nop
 8007308:	20003e28 	.word	0x20003e28

0800730c <tcp_getoptbyte>:

static u8_t
tcp_getoptbyte(void)
{
  if ((tcphdr_opt2 == NULL) || (tcp_optidx < tcphdr_opt1len)) {
 800730c:	4a0a      	ldr	r2, [pc, #40]	; (8007338 <tcp_getoptbyte+0x2c>)
 800730e:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8007310:	4611      	mov	r1, r2
{
 8007312:	b510      	push	{r4, lr}
  if ((tcphdr_opt2 == NULL) || (tcp_optidx < tcphdr_opt1len)) {
 8007314:	b118      	cbz	r0, 800731e <tcp_getoptbyte+0x12>
 8007316:	8e13      	ldrh	r3, [r2, #48]	; 0x30
 8007318:	8e54      	ldrh	r4, [r2, #50]	; 0x32
 800731a:	42a3      	cmp	r3, r4
 800731c:	d206      	bcs.n	800732c <tcp_getoptbyte+0x20>
    u8_t* opts = (u8_t *)tcphdr + TCP_HLEN;
    return opts[tcp_optidx++];
 800731e:	8e0a      	ldrh	r2, [r1, #48]	; 0x30
    u8_t* opts = (u8_t *)tcphdr + TCP_HLEN;
 8007320:	68cb      	ldr	r3, [r1, #12]
    return opts[tcp_optidx++];
 8007322:	1c50      	adds	r0, r2, #1
 8007324:	4413      	add	r3, r2
 8007326:	8608      	strh	r0, [r1, #48]	; 0x30
 8007328:	7d18      	ldrb	r0, [r3, #20]
 800732a:	bd10      	pop	{r4, pc}
  } else {
    u8_t idx = (u8_t)(tcp_optidx++ - tcphdr_opt1len);
 800732c:	1c59      	adds	r1, r3, #1
 800732e:	1b1b      	subs	r3, r3, r4
    return tcphdr_opt2[idx];
 8007330:	b2db      	uxtb	r3, r3
    u8_t idx = (u8_t)(tcp_optidx++ - tcphdr_opt1len);
 8007332:	8611      	strh	r1, [r2, #48]	; 0x30
    return tcphdr_opt2[idx];
 8007334:	5cc0      	ldrb	r0, [r0, r3]
  }
}
 8007336:	bd10      	pop	{r4, pc}
 8007338:	20003e14 	.word	0x20003e14

0800733c <tcp_parseopt.isra.1>:
 * Currently, only the MSS option is supported!
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
 800733c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  /* Parse the TCP MSS option, if present. */
  if (TCPH_HDRLEN(tcphdr) > 0x5) {
 800733e:	4d20      	ldr	r5, [pc, #128]	; (80073c0 <tcp_parseopt.isra.1+0x84>)
tcp_parseopt(struct tcp_pcb *pcb)
 8007340:	4607      	mov	r7, r0
  if (TCPH_HDRLEN(tcphdr) > 0x5) {
 8007342:	68eb      	ldr	r3, [r5, #12]
 8007344:	8998      	ldrh	r0, [r3, #12]
 8007346:	f7fd fc4e 	bl	8004be6 <lwip_ntohs>
 800734a:	f3c0 300f 	ubfx	r0, r0, #12, #16
 800734e:	2805      	cmp	r0, #5
 8007350:	d90c      	bls.n	800736c <tcp_parseopt.isra.1+0x30>
    u16_t max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
 8007352:	68eb      	ldr	r3, [r5, #12]
 8007354:	8998      	ldrh	r0, [r3, #12]
 8007356:	f7fd fc46 	bl	8004be6 <lwip_ntohs>
    for (tcp_optidx = 0; tcp_optidx < max_c; ) {
 800735a:	2300      	movs	r3, #0
    u16_t max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
 800735c:	0b06      	lsrs	r6, r0, #12
    for (tcp_optidx = 0; tcp_optidx < max_c; ) {
 800735e:	862b      	strh	r3, [r5, #48]	; 0x30
    u16_t max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
 8007360:	3e05      	subs	r6, #5
 8007362:	00b6      	lsls	r6, r6, #2
 8007364:	b2b6      	uxth	r6, r6
    for (tcp_optidx = 0; tcp_optidx < max_c; ) {
 8007366:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
 8007368:	42b3      	cmp	r3, r6
 800736a:	d300      	bcc.n	800736e <tcp_parseopt.isra.1+0x32>
 800736c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      u8_t opt = tcp_getoptbyte();
 800736e:	f7ff ffcd 	bl	800730c <tcp_getoptbyte>
      switch (opt) {
 8007372:	2801      	cmp	r0, #1
 8007374:	d0f7      	beq.n	8007366 <tcp_parseopt.isra.1+0x2a>
 8007376:	d3f9      	bcc.n	800736c <tcp_parseopt.isra.1+0x30>
 8007378:	2802      	cmp	r0, #2
 800737a:	d117      	bne.n	80073ac <tcp_parseopt.isra.1+0x70>
        /* NOP option. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
      case LWIP_TCP_OPT_MSS:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (tcp_getoptbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_MSS) > max_c) {
 800737c:	f7ff ffc6 	bl	800730c <tcp_getoptbyte>
 8007380:	2804      	cmp	r0, #4
 8007382:	d1f3      	bne.n	800736c <tcp_parseopt.isra.1+0x30>
 8007384:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
 8007386:	3301      	adds	r3, #1
 8007388:	42b3      	cmp	r3, r6
 800738a:	daef      	bge.n	800736c <tcp_parseopt.isra.1+0x30>
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (tcp_getoptbyte() << 8);
 800738c:	f7ff ffbe 	bl	800730c <tcp_getoptbyte>
 8007390:	0200      	lsls	r0, r0, #8
 8007392:	b284      	uxth	r4, r0
        mss |= tcp_getoptbyte();
 8007394:	f7ff ffba 	bl	800730c <tcp_getoptbyte>
 8007398:	4320      	orrs	r0, r4
 800739a:	b280      	uxth	r0, r0
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 800739c:	1e43      	subs	r3, r0, #1
 800739e:	f5b3 7f06 	cmp.w	r3, #536	; 0x218
 80073a2:	bf28      	it	cs
 80073a4:	f44f 7006 	movcs.w	r0, #536	; 0x218
 80073a8:	8038      	strh	r0, [r7, #0]
 80073aa:	e7dc      	b.n	8007366 <tcp_parseopt.isra.1+0x2a>
        tcp_optidx += LWIP_TCP_OPT_LEN_TS - 6;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        data = tcp_getoptbyte();
 80073ac:	f7ff ffae 	bl	800730c <tcp_getoptbyte>
        if (data < 2) {
 80073b0:	2801      	cmp	r0, #1
 80073b2:	d9db      	bls.n	800736c <tcp_parseopt.isra.1+0x30>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        tcp_optidx += data - 2;
 80073b4:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
 80073b6:	3b02      	subs	r3, #2
 80073b8:	4418      	add	r0, r3
 80073ba:	8628      	strh	r0, [r5, #48]	; 0x30
 80073bc:	e7d3      	b.n	8007366 <tcp_parseopt.isra.1+0x2a>
 80073be:	bf00      	nop
 80073c0:	20003e14 	.word	0x20003e14

080073c4 <tcp_input>:
{
 80073c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  tcphdr = (struct tcp_hdr *)p->payload;
 80073c8:	6843      	ldr	r3, [r0, #4]
{
 80073ca:	b085      	sub	sp, #20
  tcphdr = (struct tcp_hdr *)p->payload;
 80073cc:	4d96      	ldr	r5, [pc, #600]	; (8007628 <tcp_input+0x264>)
{
 80073ce:	4606      	mov	r6, r0
  tcphdr = (struct tcp_hdr *)p->payload;
 80073d0:	60eb      	str	r3, [r5, #12]
  if (p->len < sizeof(struct tcp_hdr)) {
 80073d2:	8943      	ldrh	r3, [r0, #10]
 80073d4:	2b13      	cmp	r3, #19
 80073d6:	f240 80f7 	bls.w	80075c8 <tcp_input+0x204>
      (!ip_current_is_v6() && ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif())) ||
 80073da:	4f94      	ldr	r7, [pc, #592]	; (800762c <tcp_input+0x268>)
 80073dc:	6839      	ldr	r1, [r7, #0]
 80073de:	6978      	ldr	r0, [r7, #20]
 80073e0:	f7fd fe1b 	bl	800501a <ip4_addr_isbroadcast_u32>
  if (
 80073e4:	4680      	mov	r8, r0
 80073e6:	2800      	cmp	r0, #0
 80073e8:	f040 80ee 	bne.w	80075c8 <tcp_input+0x204>
       ip_addr_ismulticast(ip_current_dest_addr())) {
 80073ec:	697b      	ldr	r3, [r7, #20]
 80073ee:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      (!ip_current_is_v6() && ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif())) ||
 80073f2:	2be0      	cmp	r3, #224	; 0xe0
 80073f4:	f000 80e8 	beq.w	80075c8 <tcp_input+0x204>
  hdrlen = TCPH_HDRLEN(tcphdr);
 80073f8:	68eb      	ldr	r3, [r5, #12]
 80073fa:	8998      	ldrh	r0, [r3, #12]
 80073fc:	f7fd fbf3 	bl	8004be6 <lwip_ntohs>
 8007400:	f3c0 300f 	ubfx	r0, r0, #12, #16
  if (p->len < hdrlen * 4) {
 8007404:	8973      	ldrh	r3, [r6, #10]
  tcphdr_opt1len = (hdrlen * 4) - TCP_HLEN;
 8007406:	1f44      	subs	r4, r0, #5
  tcphdr_opt2 = NULL;
 8007408:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
  if (p->len < hdrlen * 4) {
 800740c:	ebb3 0f80 	cmp.w	r3, r0, lsl #2
  tcphdr_opt1len = (hdrlen * 4) - TCP_HLEN;
 8007410:	ea4f 0484 	mov.w	r4, r4, lsl #2
 8007414:	b2a4      	uxth	r4, r4
 8007416:	866c      	strh	r4, [r5, #50]	; 0x32
  if (p->len < hdrlen * 4) {
 8007418:	da59      	bge.n	80074ce <tcp_input+0x10a>
    if (p->len >= TCP_HLEN) {
 800741a:	2b13      	cmp	r3, #19
 800741c:	f240 80d4 	bls.w	80075c8 <tcp_input+0x204>
      pbuf_header(p, -TCP_HLEN); /* cannot fail */
 8007420:	f06f 0113 	mvn.w	r1, #19
 8007424:	4630      	mov	r0, r6
 8007426:	f7fe fbd8 	bl	8005bda <pbuf_header>
      LWIP_ASSERT("tcphdr_opt1len >= p->len", tcphdr_opt1len >= p->len);
 800742a:	8971      	ldrh	r1, [r6, #10]
      if (optlen > tcphdr_opt1len) {
 800742c:	428c      	cmp	r4, r1
      tcphdr_opt1len = p->len;
 800742e:	8669      	strh	r1, [r5, #50]	; 0x32
      if (optlen > tcphdr_opt1len) {
 8007430:	d911      	bls.n	8007456 <tcp_input+0x92>
        u8_t phret = pbuf_header(p, -(s16_t)tcphdr_opt1len);
 8007432:	4249      	negs	r1, r1
 8007434:	4630      	mov	r0, r6
 8007436:	b209      	sxth	r1, r1
 8007438:	f7fe fbcf 	bl	8005bda <pbuf_header>
        tcphdr_opt2 = (u8_t*)p->next->payload;
 800743c:	6830      	ldr	r0, [r6, #0]
 800743e:	6843      	ldr	r3, [r0, #4]
 8007440:	62eb      	str	r3, [r5, #44]	; 0x2c
        opt2len = optlen - tcphdr_opt1len;
 8007442:	8e6b      	ldrh	r3, [r5, #50]	; 0x32
 8007444:	1ae4      	subs	r4, r4, r3
 8007446:	b2a4      	uxth	r4, r4
        phret = pbuf_header(p->next, -opt2len);
 8007448:	4261      	negs	r1, r4
 800744a:	b209      	sxth	r1, r1
 800744c:	f7fe fbc5 	bl	8005bda <pbuf_header>
        p->tot_len -= opt2len;
 8007450:	8933      	ldrh	r3, [r6, #8]
 8007452:	1b1c      	subs	r4, r3, r4
 8007454:	8134      	strh	r4, [r6, #8]
  tcphdr->src = ntohs(tcphdr->src);
 8007456:	68ec      	ldr	r4, [r5, #12]
  prev = NULL;
 8007458:	f04f 0900 	mov.w	r9, #0
  tcphdr->src = ntohs(tcphdr->src);
 800745c:	8820      	ldrh	r0, [r4, #0]
 800745e:	f7fd fbc2 	bl	8004be6 <lwip_ntohs>
 8007462:	8020      	strh	r0, [r4, #0]
  tcphdr->dest = ntohs(tcphdr->dest);
 8007464:	68ec      	ldr	r4, [r5, #12]
 8007466:	8860      	ldrh	r0, [r4, #2]
 8007468:	f7fd fbbd 	bl	8004be6 <lwip_ntohs>
 800746c:	8060      	strh	r0, [r4, #2]
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 800746e:	68ec      	ldr	r4, [r5, #12]
 8007470:	6860      	ldr	r0, [r4, #4]
 8007472:	f7fd fbbd 	bl	8004bf0 <lwip_ntohl>
 8007476:	6060      	str	r0, [r4, #4]
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 8007478:	68ec      	ldr	r4, [r5, #12]
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 800747a:	6028      	str	r0, [r5, #0]
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 800747c:	68a0      	ldr	r0, [r4, #8]
 800747e:	f7fd fbb7 	bl	8004bf0 <lwip_ntohl>
 8007482:	60a0      	str	r0, [r4, #8]
  tcphdr->wnd = ntohs(tcphdr->wnd);
 8007484:	68ec      	ldr	r4, [r5, #12]
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 8007486:	60a8      	str	r0, [r5, #8]
  tcphdr->wnd = ntohs(tcphdr->wnd);
 8007488:	89e0      	ldrh	r0, [r4, #14]
 800748a:	f7fd fbac 	bl	8004be6 <lwip_ntohs>
  flags = TCPH_FLAGS(tcphdr);
 800748e:	68eb      	ldr	r3, [r5, #12]
  tcphdr->wnd = ntohs(tcphdr->wnd);
 8007490:	81e0      	strh	r0, [r4, #14]
  flags = TCPH_FLAGS(tcphdr);
 8007492:	8998      	ldrh	r0, [r3, #12]
 8007494:	f7fd fba7 	bl	8004be6 <lwip_ntohs>
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 8007498:	f8b6 a008 	ldrh.w	sl, [r6, #8]
  flags = TCPH_FLAGS(tcphdr);
 800749c:	b2c3      	uxtb	r3, r0
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800749e:	4864      	ldr	r0, [pc, #400]	; (8007630 <tcp_input+0x26c>)
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 80074a0:	f8d7 c010 	ldr.w	ip, [r7, #16]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 80074a4:	f013 0103 	ands.w	r1, r3, #3
  flags = TCPH_FLAGS(tcphdr);
 80074a8:	f003 023f 	and.w	r2, r3, #63	; 0x3f
        ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 80074ac:	f8d7 e014 	ldr.w	lr, [r7, #20]
 80074b0:	4680      	mov	r8, r0
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 80074b2:	bf18      	it	ne
 80074b4:	2101      	movne	r1, #1
  flags = TCPH_FLAGS(tcphdr);
 80074b6:	712a      	strb	r2, [r5, #4]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80074b8:	6802      	ldr	r2, [r0, #0]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 80074ba:	4451      	add	r1, sl
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80074bc:	9203      	str	r2, [sp, #12]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 80074be:	b289      	uxth	r1, r1
    if (pcb->remote_port == tcphdr->src &&
 80074c0:	68ea      	ldr	r2, [r5, #12]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80074c2:	9c03      	ldr	r4, [sp, #12]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 80074c4:	8229      	strh	r1, [r5, #16]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80074c6:	b954      	cbnz	r4, 80074de <tcp_input+0x11a>
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 80074c8:	485a      	ldr	r0, [pc, #360]	; (8007634 <tcp_input+0x270>)
 80074ca:	6800      	ldr	r0, [r0, #0]
 80074cc:	e083      	b.n	80075d6 <tcp_input+0x212>
    pbuf_header(p, -(hdrlen * 4)); /* cannot fail */
 80074ce:	ebc0 3080 	rsb	r0, r0, r0, lsl #14
 80074d2:	0081      	lsls	r1, r0, #2
 80074d4:	4630      	mov	r0, r6
 80074d6:	b209      	sxth	r1, r1
 80074d8:	f7fe fb7f 	bl	8005bda <pbuf_header>
 80074dc:	e7bb      	b.n	8007456 <tcp_input+0x92>
    if (pcb->remote_port == tcphdr->src &&
 80074de:	f8b4 b01c 	ldrh.w	fp, [r4, #28]
 80074e2:	8810      	ldrh	r0, [r2, #0]
 80074e4:	4583      	cmp	fp, r0
 80074e6:	d13b      	bne.n	8007560 <tcp_input+0x19c>
 80074e8:	f8b4 b01a 	ldrh.w	fp, [r4, #26]
 80074ec:	8850      	ldrh	r0, [r2, #2]
 80074ee:	4583      	cmp	fp, r0
 80074f0:	d136      	bne.n	8007560 <tcp_input+0x19c>
        pcb->local_port == tcphdr->dest &&
 80074f2:	6860      	ldr	r0, [r4, #4]
 80074f4:	4560      	cmp	r0, ip
 80074f6:	d133      	bne.n	8007560 <tcp_input+0x19c>
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 80074f8:	6820      	ldr	r0, [r4, #0]
 80074fa:	4570      	cmp	r0, lr
 80074fc:	d130      	bne.n	8007560 <tcp_input+0x19c>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 80074fe:	68e1      	ldr	r1, [r4, #12]
      if (prev != NULL) {
 8007500:	f1b9 0f00 	cmp.w	r9, #0
 8007504:	d005      	beq.n	8007512 <tcp_input+0x14e>
        prev->next = pcb->next;
 8007506:	f8c9 100c 	str.w	r1, [r9, #12]
        pcb->next = tcp_active_pcbs;
 800750a:	9903      	ldr	r1, [sp, #12]
 800750c:	60e1      	str	r1, [r4, #12]
        tcp_active_pcbs = pcb;
 800750e:	4948      	ldr	r1, [pc, #288]	; (8007630 <tcp_input+0x26c>)
 8007510:	600c      	str	r4, [r1, #0]
    inseg.next = NULL;
 8007512:	2100      	movs	r1, #0
    if (flags & TCP_PSH) {
 8007514:	071b      	lsls	r3, r3, #28
    inseg.len = p->tot_len;
 8007516:	f8a5 a01c 	strh.w	sl, [r5, #28]
    inseg.next = NULL;
 800751a:	6169      	str	r1, [r5, #20]
    inseg.p = p;
 800751c:	61ae      	str	r6, [r5, #24]
    inseg.tcphdr = tcphdr;
 800751e:	622a      	str	r2, [r5, #32]
    recv_data = NULL;
 8007520:	6269      	str	r1, [r5, #36]	; 0x24
    recv_flags = 0;
 8007522:	f885 1028 	strb.w	r1, [r5, #40]	; 0x28
    if (flags & TCP_PSH) {
 8007526:	d503      	bpl.n	8007530 <tcp_input+0x16c>
      p->flags |= PBUF_FLAG_PUSH;
 8007528:	7b73      	ldrb	r3, [r6, #13]
 800752a:	f043 0301 	orr.w	r3, r3, #1
 800752e:	7373      	strb	r3, [r6, #13]
    if (pcb->refused_data != NULL) {
 8007530:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8007532:	4e41      	ldr	r6, [pc, #260]	; (8007638 <tcp_input+0x274>)
 8007534:	2b00      	cmp	r3, #0
 8007536:	f040 80da 	bne.w	80076ee <tcp_input+0x32a>
  if (flags & TCP_RST) {
 800753a:	792b      	ldrb	r3, [r5, #4]
    tcp_input_pcb = pcb;
 800753c:	6034      	str	r4, [r6, #0]
  if (flags & TCP_RST) {
 800753e:	075a      	lsls	r2, r3, #29
 8007540:	f100 80ed 	bmi.w	800771e <tcp_input+0x35a>
  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
 8007544:	f013 0f02 	tst.w	r3, #2
 8007548:	7fa3      	ldrb	r3, [r4, #30]
 800754a:	f000 8116 	beq.w	800777a <tcp_input+0x3b6>
 800754e:	7e22      	ldrb	r2, [r4, #24]
 8007550:	3a02      	subs	r2, #2
 8007552:	2a01      	cmp	r2, #1
 8007554:	f240 8111 	bls.w	800777a <tcp_input+0x3b6>
      tcp_ack_now(pcb);
 8007558:	f043 0302 	orr.w	r3, r3, #2
      pcb->flags &= ~TF_ACK_DELAY;
 800755c:	77a3      	strb	r3, [r4, #30]
 800755e:	e0f7      	b.n	8007750 <tcp_input+0x38c>
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8007560:	46a1      	mov	r9, r4
 8007562:	68e4      	ldr	r4, [r4, #12]
 8007564:	e7af      	b.n	80074c6 <tcp_input+0x102>
      if (pcb->remote_port == tcphdr->src &&
 8007566:	8b84      	ldrh	r4, [r0, #28]
 8007568:	f8b2 a000 	ldrh.w	sl, [r2]
 800756c:	45a2      	cmp	sl, r4
 800756e:	d131      	bne.n	80075d4 <tcp_input+0x210>
          pcb->local_port == tcphdr->dest &&
 8007570:	8b44      	ldrh	r4, [r0, #26]
      if (pcb->remote_port == tcphdr->src &&
 8007572:	f8b2 9002 	ldrh.w	r9, [r2, #2]
 8007576:	45a1      	cmp	r9, r4
 8007578:	d12c      	bne.n	80075d4 <tcp_input+0x210>
          pcb->local_port == tcphdr->dest &&
 800757a:	6844      	ldr	r4, [r0, #4]
 800757c:	45a4      	cmp	ip, r4
 800757e:	d129      	bne.n	80075d4 <tcp_input+0x210>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 8007580:	6804      	ldr	r4, [r0, #0]
 8007582:	45a6      	cmp	lr, r4
 8007584:	d126      	bne.n	80075d4 <tcp_input+0x210>
  if (flags & TCP_RST) {
 8007586:	075a      	lsls	r2, r3, #29
 8007588:	d41e      	bmi.n	80075c8 <tcp_input+0x204>
  if (flags & TCP_SYN) {
 800758a:	079f      	lsls	r7, r3, #30
 800758c:	d510      	bpl.n	80075b0 <tcp_input+0x1ec>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
 800758e:	682c      	ldr	r4, [r5, #0]
 8007590:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8007592:	1ae3      	subs	r3, r4, r3
 8007594:	d411      	bmi.n	80075ba <tcp_input+0x1f6>
 8007596:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
 8007598:	1a9b      	subs	r3, r3, r2
 800759a:	2b00      	cmp	r3, #0
 800759c:	dc0d      	bgt.n	80075ba <tcp_input+0x1f6>
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 800759e:	4b27      	ldr	r3, [pc, #156]	; (800763c <tcp_input+0x278>)
 80075a0:	4421      	add	r1, r4
 80075a2:	1d1a      	adds	r2, r3, #4
 80075a4:	e88d 0600 	stmia.w	sp, {r9, sl}
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 80075a8:	68a8      	ldr	r0, [r5, #8]
 80075aa:	f000 fefd 	bl	80083a8 <tcp_rst>
 80075ae:	e00b      	b.n	80075c8 <tcp_input+0x204>
  } else if (flags & TCP_FIN) {
 80075b0:	07dc      	lsls	r4, r3, #31
    pcb->tmr = tcp_ticks;
 80075b2:	bf42      	ittt	mi
 80075b4:	4b22      	ldrmi	r3, [pc, #136]	; (8007640 <tcp_input+0x27c>)
 80075b6:	681b      	ldrmi	r3, [r3, #0]
 80075b8:	6243      	strmi	r3, [r0, #36]	; 0x24
  if ((tcplen > 0)) {
 80075ba:	b129      	cbz	r1, 80075c8 <tcp_input+0x204>
    pcb->flags |= TF_ACK_NOW;
 80075bc:	7f83      	ldrb	r3, [r0, #30]
 80075be:	f043 0302 	orr.w	r3, r3, #2
 80075c2:	7783      	strb	r3, [r0, #30]
    return tcp_output(pcb);
 80075c4:	f000 fdb6 	bl	8008134 <tcp_output>
  pbuf_free(p);
 80075c8:	4630      	mov	r0, r6
}
 80075ca:	b005      	add	sp, #20
 80075cc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  pbuf_free(p);
 80075d0:	f7fe bb11 	b.w	8005bf6 <pbuf_free>
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 80075d4:	68c0      	ldr	r0, [r0, #12]
 80075d6:	2800      	cmp	r0, #0
 80075d8:	d1c5      	bne.n	8007566 <tcp_input+0x1a2>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 80075da:	4c1a      	ldr	r4, [pc, #104]	; (8007644 <tcp_input+0x280>)
 80075dc:	f8d4 b000 	ldr.w	fp, [r4]
 80075e0:	46a4      	mov	ip, r4
 80075e2:	46d9      	mov	r9, fp
 80075e4:	f1b9 0f00 	cmp.w	r9, #0
 80075e8:	d10c      	bne.n	8007604 <tcp_input+0x240>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 80075ea:	8990      	ldrh	r0, [r2, #12]
 80075ec:	f7fd fafb 	bl	8004be6 <lwip_ntohs>
 80075f0:	0742      	lsls	r2, r0, #29
 80075f2:	d4e9      	bmi.n	80075c8 <tcp_input+0x204>
        ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 80075f4:	68eb      	ldr	r3, [r5, #12]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 80075f6:	8a28      	ldrh	r0, [r5, #16]
 80075f8:	881a      	ldrh	r2, [r3, #0]
 80075fa:	6829      	ldr	r1, [r5, #0]
 80075fc:	9201      	str	r2, [sp, #4]
 80075fe:	885b      	ldrh	r3, [r3, #2]
 8007600:	9300      	str	r3, [sp, #0]
 8007602:	e29a      	b.n	8007b3a <tcp_input+0x776>
      if (lpcb->local_port == tcphdr->dest) {
 8007604:	f8b9 a01a 	ldrh.w	sl, [r9, #26]
 8007608:	8854      	ldrh	r4, [r2, #2]
 800760a:	4554      	cmp	r4, sl
 800760c:	d107      	bne.n	800761e <tcp_input+0x25a>
          if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
 800760e:	f8d9 4000 	ldr.w	r4, [r9]
 8007612:	45a6      	cmp	lr, r4
 8007614:	f000 827d 	beq.w	8007b12 <tcp_input+0x74e>
          } else if (ip_addr_isany(&lpcb->local_ip)) {
 8007618:	2c00      	cmp	r4, #0
 800761a:	f000 827a 	beq.w	8007b12 <tcp_input+0x74e>
 800761e:	4648      	mov	r0, r9
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8007620:	f8d9 900c 	ldr.w	r9, [r9, #12]
 8007624:	e7de      	b.n	80075e4 <tcp_input+0x220>
 8007626:	bf00      	nop
 8007628:	20003e14 	.word	0x20003e14
 800762c:	20003f8c 	.word	0x20003f8c
 8007630:	20007668 	.word	0x20007668
 8007634:	20007678 	.word	0x20007678
 8007638:	2000767c 	.word	0x2000767c
 800763c:	20003f9c 	.word	0x20003f9c
 8007640:	2000766c 	.word	0x2000766c
 8007644:	20007670 	.word	0x20007670
  } else if (flags & TCP_SYN) {
 8007648:	0799      	lsls	r1, r3, #30
 800764a:	d5bd      	bpl.n	80075c8 <tcp_input+0x204>
    npcb = tcp_alloc(pcb->prio);
 800764c:	f899 0019 	ldrb.w	r0, [r9, #25]
 8007650:	f7ff f934 	bl	80068bc <tcp_alloc>
    if (npcb == NULL) {
 8007654:	4682      	mov	sl, r0
 8007656:	2800      	cmp	r0, #0
 8007658:	d0b6      	beq.n	80075c8 <tcp_input+0x204>
    ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
 800765a:	697b      	ldr	r3, [r7, #20]
    npcb->remote_port = tcphdr->src;
 800765c:	68ea      	ldr	r2, [r5, #12]
    ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
 800765e:	6003      	str	r3, [r0, #0]
    ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
 8007660:	693b      	ldr	r3, [r7, #16]
 8007662:	6043      	str	r3, [r0, #4]
    npcb->local_port = pcb->local_port;
 8007664:	f8b9 301a 	ldrh.w	r3, [r9, #26]
 8007668:	8343      	strh	r3, [r0, #26]
    npcb->remote_port = tcphdr->src;
 800766a:	7813      	ldrb	r3, [r2, #0]
 800766c:	7852      	ldrb	r2, [r2, #1]
 800766e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8007672:	8383      	strh	r3, [r0, #28]
    npcb->state = SYN_RCVD;
 8007674:	2303      	movs	r3, #3
 8007676:	7603      	strb	r3, [r0, #24]
    npcb->rcv_nxt = seqno + 1;
 8007678:	682b      	ldr	r3, [r5, #0]
 800767a:	1c5a      	adds	r2, r3, #1
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 800767c:	3b01      	subs	r3, #1
 800767e:	6543      	str	r3, [r0, #84]	; 0x54
    npcb->callback_arg = pcb->callback_arg;
 8007680:	f8d9 3010 	ldr.w	r3, [r9, #16]
    npcb->rcv_nxt = seqno + 1;
 8007684:	6282      	str	r2, [r0, #40]	; 0x28
    npcb->callback_arg = pcb->callback_arg;
 8007686:	6103      	str	r3, [r0, #16]
    npcb->accept = pcb->accept;
 8007688:	f8d9 3014 	ldr.w	r3, [r9, #20]
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 800768c:	6302      	str	r2, [r0, #48]	; 0x30
    npcb->accept = pcb->accept;
 800768e:	6143      	str	r3, [r0, #20]
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 8007690:	f899 3008 	ldrb.w	r3, [r9, #8]
 8007694:	f003 030c 	and.w	r3, r3, #12
 8007698:	7203      	strb	r3, [r0, #8]
    TCP_REG_ACTIVE(npcb);
 800769a:	f8d8 3000 	ldr.w	r3, [r8]
 800769e:	f8c8 0000 	str.w	r0, [r8]
 80076a2:	60c3      	str	r3, [r0, #12]
 80076a4:	f7fd ff94 	bl	80055d0 <tcp_timer_needed>
 80076a8:	2201      	movs	r2, #1
 80076aa:	4ba5      	ldr	r3, [pc, #660]	; (8007940 <tcp_input+0x57c>)
    tcp_parseopt(npcb);
 80076ac:	f10a 0036 	add.w	r0, sl, #54	; 0x36
    TCP_REG_ACTIVE(npcb);
 80076b0:	701a      	strb	r2, [r3, #0]
    tcp_parseopt(npcb);
 80076b2:	f7ff fe43 	bl	800733c <tcp_parseopt.isra.1>
    npcb->snd_wnd = SND_WND_SCALE(npcb, tcphdr->wnd);
 80076b6:	68eb      	ldr	r3, [r5, #12]
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip,
 80076b8:	f10a 0104 	add.w	r1, sl, #4
 80076bc:	f8ba 0036 	ldrh.w	r0, [sl, #54]	; 0x36
    npcb->snd_wnd = SND_WND_SCALE(npcb, tcphdr->wnd);
 80076c0:	89db      	ldrh	r3, [r3, #14]
 80076c2:	f8aa 3060 	strh.w	r3, [sl, #96]	; 0x60
    npcb->snd_wnd_max = npcb->snd_wnd;
 80076c6:	f8aa 3062 	strh.w	r3, [sl, #98]	; 0x62
    npcb->ssthresh = LWIP_TCP_INITIAL_SSTHRESH(npcb);
 80076ca:	f8aa 304e 	strh.w	r3, [sl, #78]	; 0x4e
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip,
 80076ce:	f7ff f992 	bl	80069f6 <tcp_eff_send_mss_impl>
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 80076d2:	2112      	movs	r1, #18
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip,
 80076d4:	f8aa 0036 	strh.w	r0, [sl, #54]	; 0x36
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 80076d8:	4650      	mov	r0, sl
 80076da:	f000 fc80 	bl	8007fde <tcp_enqueue_flags>
    if (rc != ERR_OK) {
 80076de:	b120      	cbz	r0, 80076ea <tcp_input+0x326>
      tcp_abandon(npcb, 0);
 80076e0:	4621      	mov	r1, r4
 80076e2:	4650      	mov	r0, sl
 80076e4:	f7ff f840 	bl	8006768 <tcp_abandon>
 80076e8:	e76e      	b.n	80075c8 <tcp_input+0x204>
    return tcp_output(npcb);
 80076ea:	4650      	mov	r0, sl
 80076ec:	e76a      	b.n	80075c4 <tcp_input+0x200>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 80076ee:	4620      	mov	r0, r4
 80076f0:	f7fe ff94 	bl	800661c <tcp_process_refused_data>
 80076f4:	300c      	adds	r0, #12
 80076f6:	d007      	beq.n	8007708 <tcp_input+0x344>
 80076f8:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 80076fa:	2b00      	cmp	r3, #0
 80076fc:	f43f af1d 	beq.w	800753a <tcp_input+0x176>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
 8007700:	8a2b      	ldrh	r3, [r5, #16]
 8007702:	2b00      	cmp	r3, #0
 8007704:	f43f af19 	beq.w	800753a <tcp_input+0x176>
    tcp_input_pcb = NULL;
 8007708:	2400      	movs	r4, #0
    if (inseg.p != NULL)
 800770a:	69a8      	ldr	r0, [r5, #24]
    tcp_input_pcb = NULL;
 800770c:	6034      	str	r4, [r6, #0]
    recv_data = NULL;
 800770e:	626c      	str	r4, [r5, #36]	; 0x24
    if (inseg.p != NULL)
 8007710:	b110      	cbz	r0, 8007718 <tcp_input+0x354>
      pbuf_free(inseg.p);
 8007712:	f7fe fa70 	bl	8005bf6 <pbuf_free>
      inseg.p = NULL;
 8007716:	61ac      	str	r4, [r5, #24]
}
 8007718:	b005      	add	sp, #20
 800771a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (pcb->state == SYN_SENT) {
 800771e:	7e23      	ldrb	r3, [r4, #24]
 8007720:	2b02      	cmp	r3, #2
 8007722:	d10d      	bne.n	8007740 <tcp_input+0x37c>
      if (ackno == pcb->snd_nxt) {
 8007724:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8007726:	68ab      	ldr	r3, [r5, #8]
 8007728:	429a      	cmp	r2, r3
 800772a:	d111      	bne.n	8007750 <tcp_input+0x38c>
      recv_flags |= TF_RESET;
 800772c:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 8007730:	f043 0308 	orr.w	r3, r3, #8
 8007734:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
      pcb->flags &= ~TF_ACK_DELAY;
 8007738:	7fa3      	ldrb	r3, [r4, #30]
 800773a:	f023 0301 	bic.w	r3, r3, #1
 800773e:	e70d      	b.n	800755c <tcp_input+0x198>
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 8007740:	682b      	ldr	r3, [r5, #0]
 8007742:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8007744:	1a9b      	subs	r3, r3, r2
 8007746:	d403      	bmi.n	8007750 <tcp_input+0x38c>
 8007748:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 800774a:	1a9b      	subs	r3, r3, r2
 800774c:	2b00      	cmp	r3, #0
 800774e:	dded      	ble.n	800772c <tcp_input+0x368>
      if (recv_flags & TF_RESET) {
 8007750:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 8007754:	071b      	lsls	r3, r3, #28
 8007756:	f140 8181 	bpl.w	8007a5c <tcp_input+0x698>
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
 800775a:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 800775e:	b11b      	cbz	r3, 8007768 <tcp_input+0x3a4>
 8007760:	f06f 010c 	mvn.w	r1, #12
            TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
 8007764:	6920      	ldr	r0, [r4, #16]
 8007766:	4798      	blx	r3
          tcp_pcb_remove(&tcp_active_pcbs, pcb);
 8007768:	4621      	mov	r1, r4
 800776a:	4876      	ldr	r0, [pc, #472]	; (8007944 <tcp_input+0x580>)
 800776c:	f7fe fe72 	bl	8006454 <tcp_pcb_remove>
          memp_free(MEMP_TCP_PCB, pcb);
 8007770:	4621      	mov	r1, r4
 8007772:	2001      	movs	r0, #1
 8007774:	f7fe f924 	bl	80059c0 <memp_free>
          goto aborted;
 8007778:	e7c6      	b.n	8007708 <tcp_input+0x344>
  if ((pcb->flags & TF_RXCLOSED) == 0) {
 800777a:	06df      	lsls	r7, r3, #27
  tcp_parseopt(pcb);
 800777c:	f104 0036 	add.w	r0, r4, #54	; 0x36
    pcb->tmr = tcp_ticks;
 8007780:	bf5e      	ittt	pl
 8007782:	4b71      	ldrpl	r3, [pc, #452]	; (8007948 <tcp_input+0x584>)
 8007784:	681b      	ldrpl	r3, [r3, #0]
 8007786:	6263      	strpl	r3, [r4, #36]	; 0x24
  pcb->keep_cnt_sent = 0;
 8007788:	2300      	movs	r3, #0
 800778a:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
  tcp_parseopt(pcb);
 800778e:	f7ff fdd5 	bl	800733c <tcp_parseopt.isra.1>
  switch (pcb->state) {
 8007792:	7e23      	ldrb	r3, [r4, #24]
 8007794:	3b02      	subs	r3, #2
 8007796:	2b07      	cmp	r3, #7
 8007798:	d8da      	bhi.n	8007750 <tcp_input+0x38c>
 800779a:	e8df f013 	tbh	[pc, r3, lsl #1]
 800779e:	0008      	.short	0x0008
 80077a0:	00cc0071 	.word	0x00cc0071
 80077a4:	011900d9 	.word	0x011900d9
 80077a8:	013300cc 	.word	0x013300cc
 80077ac:	014d      	.short	0x014d
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
 80077ae:	792b      	ldrb	r3, [r5, #4]
 80077b0:	f003 0312 	and.w	r3, r3, #18
 80077b4:	2b12      	cmp	r3, #18
 80077b6:	d151      	bne.n	800785c <tcp_input+0x498>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
 80077b8:	6f23      	ldr	r3, [r4, #112]	; 0x70
 80077ba:	68db      	ldr	r3, [r3, #12]
 80077bc:	6858      	ldr	r0, [r3, #4]
 80077be:	f7fd fa17 	bl	8004bf0 <lwip_ntohl>
 80077c2:	68ab      	ldr	r3, [r5, #8]
 80077c4:	3001      	adds	r0, #1
 80077c6:	4298      	cmp	r0, r3
 80077c8:	d148      	bne.n	800785c <tcp_input+0x498>
      pcb->snd_buf++;
 80077ca:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
      pcb->lastack = ackno;
 80077ce:	64a0      	str	r0, [r4, #72]	; 0x48
      pcb->snd_buf++;
 80077d0:	3301      	adds	r3, #1
      pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip,
 80077d2:	8ee0      	ldrh	r0, [r4, #54]	; 0x36
      pcb->snd_buf++;
 80077d4:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
      pcb->rcv_nxt = seqno + 1;
 80077d8:	682b      	ldr	r3, [r5, #0]
 80077da:	1c5a      	adds	r2, r3, #1
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 80077dc:	3b01      	subs	r3, #1
      pcb->rcv_nxt = seqno + 1;
 80077de:	62a2      	str	r2, [r4, #40]	; 0x28
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 80077e0:	6322      	str	r2, [r4, #48]	; 0x30
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 80077e2:	68ea      	ldr	r2, [r5, #12]
 80077e4:	89d2      	ldrh	r2, [r2, #14]
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 80077e6:	6563      	str	r3, [r4, #84]	; 0x54
      pcb->state = ESTABLISHED;
 80077e8:	2304      	movs	r3, #4
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 80077ea:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
      pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip,
 80077ee:	18e1      	adds	r1, r4, r3
      pcb->snd_wnd_max = pcb->snd_wnd;
 80077f0:	f8a4 2062 	strh.w	r2, [r4, #98]	; 0x62
      pcb->state = ESTABLISHED;
 80077f4:	7623      	strb	r3, [r4, #24]
      pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip,
 80077f6:	f7ff f8fe 	bl	80069f6 <tcp_eff_send_mss_impl>
      pcb->ssthresh = LWIP_TCP_INITIAL_SSTHRESH(pcb);
 80077fa:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
      pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 80077fe:	f241 121c 	movw	r2, #4380	; 0x111c
      pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip,
 8007802:	86e0      	strh	r0, [r4, #54]	; 0x36
      pcb->ssthresh = LWIP_TCP_INITIAL_SSTHRESH(pcb);
 8007804:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
      pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 8007808:	0043      	lsls	r3, r0, #1
 800780a:	0080      	lsls	r0, r0, #2
 800780c:	4293      	cmp	r3, r2
 800780e:	bf38      	it	cc
 8007810:	4613      	movcc	r3, r2
 8007812:	4283      	cmp	r3, r0
 8007814:	bf28      	it	cs
 8007816:	4603      	movcs	r3, r0
      rseg = pcb->unacked;
 8007818:	6f20      	ldr	r0, [r4, #112]	; 0x70
      pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 800781a:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
      --pcb->snd_queuelen;
 800781e:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 8007822:	3b01      	subs	r3, #1
 8007824:	f8a4 3068 	strh.w	r3, [r4, #104]	; 0x68
      pcb->unacked = rseg->next;
 8007828:	6803      	ldr	r3, [r0, #0]
 800782a:	6723      	str	r3, [r4, #112]	; 0x70
      tcp_seg_free(rseg);
 800782c:	f7fe fc42 	bl	80060b4 <tcp_seg_free>
      if (pcb->unacked == NULL) {
 8007830:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8007832:	b93b      	cbnz	r3, 8007844 <tcp_input+0x480>
        pcb->rtime = -1;
 8007834:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8007838:	86a3      	strh	r3, [r4, #52]	; 0x34
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 800783a:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 800783e:	b933      	cbnz	r3, 800784e <tcp_input+0x48a>
      tcp_ack_now(pcb);
 8007840:	7fa3      	ldrb	r3, [r4, #30]
 8007842:	e689      	b.n	8007558 <tcp_input+0x194>
        pcb->rtime = 0;
 8007844:	2300      	movs	r3, #0
 8007846:	86a3      	strh	r3, [r4, #52]	; 0x34
        pcb->nrtx = 0;
 8007848:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
 800784c:	e7f5      	b.n	800783a <tcp_input+0x476>
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 800784e:	2200      	movs	r2, #0
 8007850:	4621      	mov	r1, r4
 8007852:	6920      	ldr	r0, [r4, #16]
 8007854:	4798      	blx	r3
      if (err == ERR_ABRT) {
 8007856:	300c      	adds	r0, #12
 8007858:	d1f2      	bne.n	8007840 <tcp_input+0x47c>
 800785a:	e755      	b.n	8007708 <tcp_input+0x344>
    else if (flags & TCP_ACK) {
 800785c:	792b      	ldrb	r3, [r5, #4]
 800785e:	06d8      	lsls	r0, r3, #27
 8007860:	f57f af76 	bpl.w	8007750 <tcp_input+0x38c>
        ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 8007864:	68eb      	ldr	r3, [r5, #12]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 8007866:	8a28      	ldrh	r0, [r5, #16]
 8007868:	881a      	ldrh	r2, [r3, #0]
 800786a:	6829      	ldr	r1, [r5, #0]
 800786c:	9201      	str	r2, [sp, #4]
 800786e:	885b      	ldrh	r3, [r3, #2]
 8007870:	4401      	add	r1, r0
 8007872:	68a8      	ldr	r0, [r5, #8]
 8007874:	9300      	str	r3, [sp, #0]
 8007876:	4b35      	ldr	r3, [pc, #212]	; (800794c <tcp_input+0x588>)
 8007878:	1d1a      	adds	r2, r3, #4
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 800787a:	f000 fd95 	bl	80083a8 <tcp_rst>
 800787e:	e767      	b.n	8007750 <tcp_input+0x38c>
    if (flags & TCP_ACK) {
 8007880:	792b      	ldrb	r3, [r5, #4]
 8007882:	06d9      	lsls	r1, r3, #27
 8007884:	d54a      	bpl.n	800791c <tcp_input+0x558>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 8007886:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8007888:	68a8      	ldr	r0, [r5, #8]
 800788a:	43db      	mvns	r3, r3
 800788c:	42c3      	cmn	r3, r0
 800788e:	d43a      	bmi.n	8007906 <tcp_input+0x542>
 8007890:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8007892:	1ac3      	subs	r3, r0, r3
 8007894:	2b00      	cmp	r3, #0
 8007896:	dc36      	bgt.n	8007906 <tcp_input+0x542>
        pcb->state = ESTABLISHED;
 8007898:	2304      	movs	r3, #4
 800789a:	7623      	strb	r3, [r4, #24]
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
 800789c:	6963      	ldr	r3, [r4, #20]
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
 800789e:	b91b      	cbnz	r3, 80078a8 <tcp_input+0x4e4>
            tcp_abort(pcb);
 80078a0:	4620      	mov	r0, r4
 80078a2:	f7fe ffc9 	bl	8006838 <tcp_abort>
            goto aborted;
 80078a6:	e72f      	b.n	8007708 <tcp_input+0x344>
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
 80078a8:	2200      	movs	r2, #0
 80078aa:	4621      	mov	r1, r4
 80078ac:	6920      	ldr	r0, [r4, #16]
 80078ae:	4798      	blx	r3
        if (err != ERR_OK) {
 80078b0:	b118      	cbz	r0, 80078ba <tcp_input+0x4f6>
          if (err != ERR_ABRT) {
 80078b2:	300c      	adds	r0, #12
 80078b4:	f43f af28 	beq.w	8007708 <tcp_input+0x344>
 80078b8:	e7f2      	b.n	80078a0 <tcp_input+0x4dc>
        tcp_receive(pcb);
 80078ba:	4620      	mov	r0, r4
 80078bc:	f7ff f980 	bl	8006bc0 <tcp_receive>
        pcb->ssthresh = LWIP_TCP_INITIAL_SSTHRESH(pcb);
 80078c0:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 80078c4:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
        if (pcb->acked != 0) {
 80078c8:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 80078cc:	b113      	cbz	r3, 80078d4 <tcp_input+0x510>
          pcb->acked--;
 80078ce:	3b01      	subs	r3, #1
 80078d0:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 80078d4:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 80078d6:	f241 111c 	movw	r1, #4380	; 0x111c
 80078da:	0053      	lsls	r3, r2, #1
 80078dc:	0092      	lsls	r2, r2, #2
 80078de:	428b      	cmp	r3, r1
 80078e0:	bf38      	it	cc
 80078e2:	460b      	movcc	r3, r1
 80078e4:	4293      	cmp	r3, r2
 80078e6:	bf28      	it	cs
 80078e8:	4613      	movcs	r3, r2
 80078ea:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    if (recv_flags & TF_GOT_FIN) { /* passive close */
 80078ee:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 80078f2:	069b      	lsls	r3, r3, #26
 80078f4:	f57f af2c 	bpl.w	8007750 <tcp_input+0x38c>
      tcp_ack_now(pcb);
 80078f8:	7fa3      	ldrb	r3, [r4, #30]
 80078fa:	f043 0302 	orr.w	r3, r3, #2
 80078fe:	77a3      	strb	r3, [r4, #30]
      pcb->state = CLOSE_WAIT;
 8007900:	2307      	movs	r3, #7
      pcb->state = FIN_WAIT_2;
 8007902:	7623      	strb	r3, [r4, #24]
 8007904:	e724      	b.n	8007750 <tcp_input+0x38c>
          ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 8007906:	68eb      	ldr	r3, [r5, #12]
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 8007908:	8a2f      	ldrh	r7, [r5, #16]
 800790a:	881a      	ldrh	r2, [r3, #0]
 800790c:	6829      	ldr	r1, [r5, #0]
 800790e:	9201      	str	r2, [sp, #4]
 8007910:	885b      	ldrh	r3, [r3, #2]
 8007912:	4439      	add	r1, r7
 8007914:	9300      	str	r3, [sp, #0]
 8007916:	4b0d      	ldr	r3, [pc, #52]	; (800794c <tcp_input+0x588>)
 8007918:	1d1a      	adds	r2, r3, #4
 800791a:	e7ae      	b.n	800787a <tcp_input+0x4b6>
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 800791c:	079a      	lsls	r2, r3, #30
 800791e:	f57f af17 	bpl.w	8007750 <tcp_input+0x38c>
 8007922:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007924:	682a      	ldr	r2, [r5, #0]
 8007926:	3b01      	subs	r3, #1
 8007928:	4293      	cmp	r3, r2
 800792a:	f47f af11 	bne.w	8007750 <tcp_input+0x38c>
      tcp_rexmit(pcb);
 800792e:	4620      	mov	r0, r4
 8007930:	f000 fd9b 	bl	800846a <tcp_rexmit>
 8007934:	e70c      	b.n	8007750 <tcp_input+0x38c>
    tcp_receive(pcb);
 8007936:	4620      	mov	r0, r4
 8007938:	f7ff f942 	bl	8006bc0 <tcp_receive>
 800793c:	e7d7      	b.n	80078ee <tcp_input+0x52a>
 800793e:	bf00      	nop
 8007940:	20007664 	.word	0x20007664
 8007944:	20007668 	.word	0x20007668
 8007948:	2000766c 	.word	0x2000766c
 800794c:	20003f9c 	.word	0x20003f9c
    tcp_receive(pcb);
 8007950:	4620      	mov	r0, r4
 8007952:	f7ff f935 	bl	8006bc0 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 8007956:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 800795a:	f013 0f20 	tst.w	r3, #32
 800795e:	792b      	ldrb	r3, [r5, #4]
 8007960:	d02c      	beq.n	80079bc <tcp_input+0x5f8>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 8007962:	f013 0f10 	tst.w	r3, #16
 8007966:	7fa3      	ldrb	r3, [r4, #30]
        tcp_ack_now(pcb);
 8007968:	f043 0302 	orr.w	r3, r3, #2
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 800796c:	d023      	beq.n	80079b6 <tcp_input+0x5f2>
 800796e:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8007970:	68aa      	ldr	r2, [r5, #8]
 8007972:	4291      	cmp	r1, r2
 8007974:	d11f      	bne.n	80079b6 <tcp_input+0x5f2>
        tcp_ack_now(pcb);
 8007976:	77a3      	strb	r3, [r4, #30]
        tcp_pcb_purge(pcb);
 8007978:	4620      	mov	r0, r4
 800797a:	f7fe fbd8 	bl	800612e <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 800797e:	4a71      	ldr	r2, [pc, #452]	; (8007b44 <tcp_input+0x780>)
 8007980:	6813      	ldr	r3, [r2, #0]
 8007982:	429c      	cmp	r4, r3
 8007984:	d109      	bne.n	800799a <tcp_input+0x5d6>
      TCP_RMV_ACTIVE(pcb);
 8007986:	68e3      	ldr	r3, [r4, #12]
 8007988:	6013      	str	r3, [r2, #0]
 800798a:	e008      	b.n	800799e <tcp_input+0x5da>
        TCP_RMV_ACTIVE(pcb);
 800798c:	68da      	ldr	r2, [r3, #12]
 800798e:	4294      	cmp	r4, r2
 8007990:	d102      	bne.n	8007998 <tcp_input+0x5d4>
      TCP_RMV_ACTIVE(pcb);
 8007992:	68e2      	ldr	r2, [r4, #12]
 8007994:	60da      	str	r2, [r3, #12]
 8007996:	e002      	b.n	800799e <tcp_input+0x5da>
        TCP_RMV_ACTIVE(pcb);
 8007998:	4613      	mov	r3, r2
 800799a:	2b00      	cmp	r3, #0
 800799c:	d1f6      	bne.n	800798c <tcp_input+0x5c8>
      TCP_RMV_ACTIVE(pcb);
 800799e:	2201      	movs	r2, #1
 80079a0:	4b69      	ldr	r3, [pc, #420]	; (8007b48 <tcp_input+0x784>)
 80079a2:	701a      	strb	r2, [r3, #0]
      pcb->state = TIME_WAIT;
 80079a4:	230a      	movs	r3, #10
 80079a6:	7623      	strb	r3, [r4, #24]
      TCP_REG(&tcp_tw_pcbs, pcb);
 80079a8:	4b68      	ldr	r3, [pc, #416]	; (8007b4c <tcp_input+0x788>)
 80079aa:	681a      	ldr	r2, [r3, #0]
 80079ac:	601c      	str	r4, [r3, #0]
 80079ae:	60e2      	str	r2, [r4, #12]
 80079b0:	f7fd fe0e 	bl	80055d0 <tcp_timer_needed>
 80079b4:	e6cc      	b.n	8007750 <tcp_input+0x38c>
        tcp_ack_now(pcb);
 80079b6:	77a3      	strb	r3, [r4, #30]
        pcb->state = CLOSING;
 80079b8:	2308      	movs	r3, #8
 80079ba:	e7a2      	b.n	8007902 <tcp_input+0x53e>
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 80079bc:	06df      	lsls	r7, r3, #27
 80079be:	f57f aec7 	bpl.w	8007750 <tcp_input+0x38c>
 80079c2:	6d22      	ldr	r2, [r4, #80]	; 0x50
 80079c4:	68ab      	ldr	r3, [r5, #8]
 80079c6:	429a      	cmp	r2, r3
 80079c8:	f47f aec2 	bne.w	8007750 <tcp_input+0x38c>
      pcb->state = FIN_WAIT_2;
 80079cc:	2306      	movs	r3, #6
 80079ce:	e798      	b.n	8007902 <tcp_input+0x53e>
    tcp_receive(pcb);
 80079d0:	4620      	mov	r0, r4
 80079d2:	f7ff f8f5 	bl	8006bc0 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 80079d6:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 80079da:	0698      	lsls	r0, r3, #26
 80079dc:	f57f aeb8 	bpl.w	8007750 <tcp_input+0x38c>
      tcp_ack_now(pcb);
 80079e0:	7fa3      	ldrb	r3, [r4, #30]
      tcp_pcb_purge(pcb);
 80079e2:	4620      	mov	r0, r4
      tcp_ack_now(pcb);
 80079e4:	f043 0302 	orr.w	r3, r3, #2
 80079e8:	77a3      	strb	r3, [r4, #30]
      tcp_pcb_purge(pcb);
 80079ea:	f7fe fba0 	bl	800612e <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 80079ee:	4a55      	ldr	r2, [pc, #340]	; (8007b44 <tcp_input+0x780>)
 80079f0:	6813      	ldr	r3, [r2, #0]
 80079f2:	429c      	cmp	r4, r3
 80079f4:	d0c7      	beq.n	8007986 <tcp_input+0x5c2>
 80079f6:	2b00      	cmp	r3, #0
 80079f8:	d0d1      	beq.n	800799e <tcp_input+0x5da>
 80079fa:	68da      	ldr	r2, [r3, #12]
 80079fc:	4294      	cmp	r4, r2
 80079fe:	d0c8      	beq.n	8007992 <tcp_input+0x5ce>
 8007a00:	4613      	mov	r3, r2
 8007a02:	e7f8      	b.n	80079f6 <tcp_input+0x632>
    tcp_receive(pcb);
 8007a04:	4620      	mov	r0, r4
 8007a06:	f7ff f8db 	bl	8006bc0 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 8007a0a:	792b      	ldrb	r3, [r5, #4]
 8007a0c:	06d9      	lsls	r1, r3, #27
 8007a0e:	f57f ae9f 	bpl.w	8007750 <tcp_input+0x38c>
 8007a12:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8007a14:	68ab      	ldr	r3, [r5, #8]
 8007a16:	429a      	cmp	r2, r3
 8007a18:	f47f ae9a 	bne.w	8007750 <tcp_input+0x38c>
      tcp_pcb_purge(pcb);
 8007a1c:	4620      	mov	r0, r4
 8007a1e:	f7fe fb86 	bl	800612e <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 8007a22:	4a48      	ldr	r2, [pc, #288]	; (8007b44 <tcp_input+0x780>)
 8007a24:	6813      	ldr	r3, [r2, #0]
 8007a26:	429c      	cmp	r4, r3
 8007a28:	d0ad      	beq.n	8007986 <tcp_input+0x5c2>
 8007a2a:	2b00      	cmp	r3, #0
 8007a2c:	d0b7      	beq.n	800799e <tcp_input+0x5da>
 8007a2e:	68da      	ldr	r2, [r3, #12]
 8007a30:	4294      	cmp	r4, r2
 8007a32:	d0ae      	beq.n	8007992 <tcp_input+0x5ce>
 8007a34:	4613      	mov	r3, r2
 8007a36:	e7f8      	b.n	8007a2a <tcp_input+0x666>
    tcp_receive(pcb);
 8007a38:	4620      	mov	r0, r4
 8007a3a:	f7ff f8c1 	bl	8006bc0 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 8007a3e:	792b      	ldrb	r3, [r5, #4]
 8007a40:	06da      	lsls	r2, r3, #27
 8007a42:	f57f ae85 	bpl.w	8007750 <tcp_input+0x38c>
 8007a46:	68ab      	ldr	r3, [r5, #8]
 8007a48:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8007a4a:	429a      	cmp	r2, r3
      recv_flags |= TF_CLOSED;
 8007a4c:	bf02      	ittt	eq
 8007a4e:	f895 3028 	ldrbeq.w	r3, [r5, #40]	; 0x28
 8007a52:	f043 0310 	orreq.w	r3, r3, #16
 8007a56:	f885 3028 	strbeq.w	r3, [r5, #40]	; 0x28
 8007a5a:	e679      	b.n	8007750 <tcp_input+0x38c>
        if (pcb->acked > 0) {
 8007a5c:	f8b4 2064 	ldrh.w	r2, [r4, #100]	; 0x64
 8007a60:	b96a      	cbnz	r2, 8007a7e <tcp_input+0x6ba>
        if (recv_flags & TF_CLOSED) {
 8007a62:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 8007a66:	06df      	lsls	r7, r3, #27
 8007a68:	d412      	bmi.n	8007a90 <tcp_input+0x6cc>
        if (recv_data != NULL) {
 8007a6a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8007a6c:	b34a      	cbz	r2, 8007ac2 <tcp_input+0x6fe>
          if (pcb->flags & TF_RXCLOSED) {
 8007a6e:	7fa3      	ldrb	r3, [r4, #30]
 8007a70:	f013 0310 	ands.w	r3, r3, #16
 8007a74:	d018      	beq.n	8007aa8 <tcp_input+0x6e4>
            pbuf_free(recv_data);
 8007a76:	4610      	mov	r0, r2
 8007a78:	f7fe f8bd 	bl	8005bf6 <pbuf_free>
 8007a7c:	e710      	b.n	80078a0 <tcp_input+0x4dc>
            TCP_EVENT_SENT(pcb, (u16_t)acked, err);
 8007a7e:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 8007a80:	2b00      	cmp	r3, #0
 8007a82:	d0ee      	beq.n	8007a62 <tcp_input+0x69e>
 8007a84:	4621      	mov	r1, r4
 8007a86:	6920      	ldr	r0, [r4, #16]
 8007a88:	4798      	blx	r3
            if (err == ERR_ABRT) {
 8007a8a:	300c      	adds	r0, #12
 8007a8c:	d1e9      	bne.n	8007a62 <tcp_input+0x69e>
 8007a8e:	e63b      	b.n	8007708 <tcp_input+0x344>
          if (!(pcb->flags & TF_RXCLOSED)) {
 8007a90:	7fa3      	ldrb	r3, [r4, #30]
 8007a92:	06d8      	lsls	r0, r3, #27
 8007a94:	f53f ae68 	bmi.w	8007768 <tcp_input+0x3a4>
            TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
 8007a98:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8007a9c:	2b00      	cmp	r3, #0
 8007a9e:	f43f ae63 	beq.w	8007768 <tcp_input+0x3a4>
 8007aa2:	f06f 010d 	mvn.w	r1, #13
 8007aa6:	e65d      	b.n	8007764 <tcp_input+0x3a0>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 8007aa8:	f8d4 7080 	ldr.w	r7, [r4, #128]	; 0x80
 8007aac:	b1cf      	cbz	r7, 8007ae2 <tcp_input+0x71e>
 8007aae:	4621      	mov	r1, r4
 8007ab0:	6920      	ldr	r0, [r4, #16]
 8007ab2:	47b8      	blx	r7
          if (err == ERR_ABRT) {
 8007ab4:	f110 0f0c 	cmn.w	r0, #12
 8007ab8:	f43f ae26 	beq.w	8007708 <tcp_input+0x344>
          if (err != ERR_OK) {
 8007abc:	b108      	cbz	r0, 8007ac2 <tcp_input+0x6fe>
            pcb->refused_data = recv_data;
 8007abe:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8007ac0:	67a3      	str	r3, [r4, #120]	; 0x78
        if (recv_flags & TF_GOT_FIN) {
 8007ac2:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 8007ac6:	0699      	lsls	r1, r3, #26
 8007ac8:	d505      	bpl.n	8007ad6 <tcp_input+0x712>
          if (pcb->refused_data != NULL) {
 8007aca:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8007acc:	b17b      	cbz	r3, 8007aee <tcp_input+0x72a>
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 8007ace:	7b5a      	ldrb	r2, [r3, #13]
 8007ad0:	f042 0220 	orr.w	r2, r2, #32
 8007ad4:	735a      	strb	r2, [r3, #13]
        tcp_input_pcb = NULL;
 8007ad6:	2300      	movs	r3, #0
        tcp_output(pcb);
 8007ad8:	4620      	mov	r0, r4
        tcp_input_pcb = NULL;
 8007ada:	6033      	str	r3, [r6, #0]
        tcp_output(pcb);
 8007adc:	f000 fb2a 	bl	8008134 <tcp_output>
 8007ae0:	e612      	b.n	8007708 <tcp_input+0x344>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 8007ae2:	463b      	mov	r3, r7
 8007ae4:	4621      	mov	r1, r4
 8007ae6:	4638      	mov	r0, r7
 8007ae8:	f7fe fd86 	bl	80065f8 <tcp_recv_null>
 8007aec:	e7e2      	b.n	8007ab4 <tcp_input+0x6f0>
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 8007aee:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
            TCP_EVENT_CLOSED(pcb, err);
 8007af0:	f8d4 7080 	ldr.w	r7, [r4, #128]	; 0x80
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 8007af4:	f5b3 6f06 	cmp.w	r3, #2144	; 0x860
              pcb->rcv_wnd++;
 8007af8:	bf1c      	itt	ne
 8007afa:	3301      	addne	r3, #1
 8007afc:	85a3      	strhne	r3, [r4, #44]	; 0x2c
            TCP_EVENT_CLOSED(pcb, err);
 8007afe:	2f00      	cmp	r7, #0
 8007b00:	d0e9      	beq.n	8007ad6 <tcp_input+0x712>
 8007b02:	2300      	movs	r3, #0
 8007b04:	4621      	mov	r1, r4
 8007b06:	6920      	ldr	r0, [r4, #16]
 8007b08:	461a      	mov	r2, r3
 8007b0a:	47b8      	blx	r7
            if (err == ERR_ABRT) {
 8007b0c:	300c      	adds	r0, #12
 8007b0e:	d1e2      	bne.n	8007ad6 <tcp_input+0x712>
 8007b10:	e5fa      	b.n	8007708 <tcp_input+0x344>
      if (prev != NULL) {
 8007b12:	b130      	cbz	r0, 8007b22 <tcp_input+0x75e>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 8007b14:	f8d9 400c 	ldr.w	r4, [r9, #12]
        tcp_listen_pcbs.listen_pcbs = lpcb;
 8007b18:	f8cc 9000 	str.w	r9, [ip]
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 8007b1c:	60c4      	str	r4, [r0, #12]
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 8007b1e:	f8c9 b00c 	str.w	fp, [r9, #12]
  if (flags & TCP_RST) {
 8007b22:	0758      	lsls	r0, r3, #29
 8007b24:	f53f ad50 	bmi.w	80075c8 <tcp_input+0x204>
  if (flags & TCP_ACK) {
 8007b28:	f013 0410 	ands.w	r4, r3, #16
 8007b2c:	f43f ad8c 	beq.w	8007648 <tcp_input+0x284>
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 8007b30:	8813      	ldrh	r3, [r2, #0]
 8007b32:	6828      	ldr	r0, [r5, #0]
 8007b34:	9301      	str	r3, [sp, #4]
 8007b36:	f8cd a000 	str.w	sl, [sp]
 8007b3a:	4b05      	ldr	r3, [pc, #20]	; (8007b50 <tcp_input+0x78c>)
 8007b3c:	4401      	add	r1, r0
 8007b3e:	1d1a      	adds	r2, r3, #4
 8007b40:	e532      	b.n	80075a8 <tcp_input+0x1e4>
 8007b42:	bf00      	nop
 8007b44:	20007668 	.word	0x20007668
 8007b48:	20007664 	.word	0x20007664
 8007b4c:	20007678 	.word	0x20007678
 8007b50:	20003f9c 	.word	0x20003f9c

08007b54 <tcp_trigger_input_pcb_close>:
}

void
tcp_trigger_input_pcb_close(void)
{
  recv_flags |= TF_CLOSED;
 8007b54:	4a03      	ldr	r2, [pc, #12]	; (8007b64 <tcp_trigger_input_pcb_close+0x10>)
 8007b56:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 8007b5a:	f043 0310 	orr.w	r3, r3, #16
 8007b5e:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
 8007b62:	4770      	bx	lr
 8007b64:	20003e14 	.word	0x20003e14

08007b68 <tcp_pbuf_prealloc>:
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
 8007b68:	b570      	push	{r4, r5, r6, lr}
 8007b6a:	460d      	mov	r5, r1
 8007b6c:	461e      	mov	r6, r3
 8007b6e:	f89d 1018 	ldrb.w	r1, [sp, #24]
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  /* always create MSS-sized pbufs */
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
 8007b72:	4295      	cmp	r5, r2
{
 8007b74:	9b04      	ldr	r3, [sp, #16]
  if (length < max_length) {
 8007b76:	d21d      	bcs.n	8007bb4 <tcp_pbuf_prealloc+0x4c>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 8007b78:	f89d 4014 	ldrb.w	r4, [sp, #20]
 8007b7c:	07a4      	lsls	r4, r4, #30
 8007b7e:	d407      	bmi.n	8007b90 <tcp_pbuf_prealloc+0x28>
 8007b80:	7f9c      	ldrb	r4, [r3, #30]
 8007b82:	0664      	lsls	r4, r4, #25
 8007b84:	d416      	bmi.n	8007bb4 <tcp_pbuf_prealloc+0x4c>
        (!(pcb->flags & TF_NODELAY) &&
 8007b86:	b119      	cbz	r1, 8007b90 <tcp_pbuf_prealloc+0x28>
         (!first_seg ||
 8007b88:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8007b8a:	b909      	cbnz	r1, 8007b90 <tcp_pbuf_prealloc+0x28>
          pcb->unsent != NULL ||
 8007b8c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8007b8e:	b18b      	cbz	r3, 8007bb4 <tcp_pbuf_prealloc+0x4c>
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
 8007b90:	f205 241b 	addw	r4, r5, #539	; 0x21b
 8007b94:	f024 0103 	bic.w	r1, r4, #3
 8007b98:	428a      	cmp	r2, r1
 8007b9a:	bf28      	it	cs
 8007b9c:	460a      	movcs	r2, r1
 8007b9e:	b291      	uxth	r1, r2
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
 8007ba0:	2200      	movs	r2, #0
 8007ba2:	f7fe f84f 	bl	8005c44 <pbuf_alloc>
  if (p == NULL) {
 8007ba6:	b120      	cbz	r0, 8007bb2 <tcp_pbuf_prealloc+0x4a>
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
 8007ba8:	8942      	ldrh	r2, [r0, #10]
 8007baa:	1b52      	subs	r2, r2, r5
 8007bac:	8032      	strh	r2, [r6, #0]
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
 8007bae:	8105      	strh	r5, [r0, #8]
 8007bb0:	8145      	strh	r5, [r0, #10]
  return p;
}
 8007bb2:	bd70      	pop	{r4, r5, r6, pc}
 8007bb4:	4629      	mov	r1, r5
 8007bb6:	e7f3      	b.n	8007ba0 <tcp_pbuf_prealloc+0x38>

08007bb8 <tcp_create_segment>:
{
 8007bb8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8007bbc:	f89d 9020 	ldrb.w	r9, [sp, #32]
 8007bc0:	4680      	mov	r8, r0
  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 8007bc2:	2003      	movs	r0, #3
{
 8007bc4:	460f      	mov	r7, r1
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 8007bc6:	f019 0f01 	tst.w	r9, #1
{
 8007bca:	4616      	mov	r6, r2
 8007bcc:	469a      	mov	sl, r3
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 8007bce:	bf14      	ite	ne
 8007bd0:	2504      	movne	r5, #4
 8007bd2:	2500      	moveq	r5, #0
  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 8007bd4:	f7fd fee8 	bl	80059a8 <memp_malloc>
 8007bd8:	4604      	mov	r4, r0
 8007bda:	b928      	cbnz	r0, 8007be8 <tcp_create_segment+0x30>
    pbuf_free(p);
 8007bdc:	4638      	mov	r0, r7
 8007bde:	f7fe f80a 	bl	8005bf6 <pbuf_free>
}
 8007be2:	4620      	mov	r0, r4
 8007be4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  seg->flags = optflags;
 8007be8:	f880 900a 	strb.w	r9, [r0, #10]
  seg->next = NULL;
 8007bec:	f04f 0900 	mov.w	r9, #0
  seg->len = p->tot_len - optlen;
 8007bf0:	893b      	ldrh	r3, [r7, #8]
  if (pbuf_header(p, TCP_HLEN)) {
 8007bf2:	2114      	movs	r1, #20
  seg->p = p;
 8007bf4:	6047      	str	r7, [r0, #4]
  seg->len = p->tot_len - optlen;
 8007bf6:	1b5b      	subs	r3, r3, r5
  seg->next = NULL;
 8007bf8:	f8c0 9000 	str.w	r9, [r0]
  seg->len = p->tot_len - optlen;
 8007bfc:	8103      	strh	r3, [r0, #8]
  if (pbuf_header(p, TCP_HLEN)) {
 8007bfe:	4638      	mov	r0, r7
 8007c00:	f7fd ffeb 	bl	8005bda <pbuf_header>
 8007c04:	4607      	mov	r7, r0
 8007c06:	b120      	cbz	r0, 8007c12 <tcp_create_segment+0x5a>
    tcp_seg_free(seg);
 8007c08:	4620      	mov	r0, r4
    return NULL;
 8007c0a:	464c      	mov	r4, r9
    tcp_seg_free(seg);
 8007c0c:	f7fe fa52 	bl	80060b4 <tcp_seg_free>
    return NULL;
 8007c10:	e7e7      	b.n	8007be2 <tcp_create_segment+0x2a>
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 8007c12:	6863      	ldr	r3, [r4, #4]
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 8007c14:	08ad      	lsrs	r5, r5, #2
  seg->tcphdr->src = htons(pcb->local_port);
 8007c16:	f8b8 001a 	ldrh.w	r0, [r8, #26]
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 8007c1a:	f8d3 9004 	ldr.w	r9, [r3, #4]
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 8007c1e:	3505      	adds	r5, #5
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 8007c20:	f8c4 900c 	str.w	r9, [r4, #12]
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 8007c24:	ea46 3505 	orr.w	r5, r6, r5, lsl #12
  seg->tcphdr->src = htons(pcb->local_port);
 8007c28:	f7fc ffda 	bl	8004be0 <lwip_htons>
 8007c2c:	f8a9 0000 	strh.w	r0, [r9]
  seg->tcphdr->dest = htons(pcb->remote_port);
 8007c30:	f8d4 900c 	ldr.w	r9, [r4, #12]
 8007c34:	f8b8 001c 	ldrh.w	r0, [r8, #28]
 8007c38:	f7fc ffd2 	bl	8004be0 <lwip_htons>
  seg->tcphdr->seqno = htonl(seqno);
 8007c3c:	f8d4 800c 	ldr.w	r8, [r4, #12]
  seg->tcphdr->dest = htons(pcb->remote_port);
 8007c40:	f8a9 0002 	strh.w	r0, [r9, #2]
  seg->tcphdr->seqno = htonl(seqno);
 8007c44:	4650      	mov	r0, sl
 8007c46:	f7fc ffd1 	bl	8004bec <lwip_htonl>
 8007c4a:	f8c8 0004 	str.w	r0, [r8, #4]
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 8007c4e:	b2a8      	uxth	r0, r5
 8007c50:	f8d4 800c 	ldr.w	r8, [r4, #12]
 8007c54:	f7fc ffc4 	bl	8004be0 <lwip_htons>
  seg->tcphdr->urgp = 0;
 8007c58:	68e3      	ldr	r3, [r4, #12]
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 8007c5a:	f8a8 000c 	strh.w	r0, [r8, #12]
  seg->tcphdr->urgp = 0;
 8007c5e:	749f      	strb	r7, [r3, #18]
 8007c60:	74df      	strb	r7, [r3, #19]
  return seg;
 8007c62:	e7be      	b.n	8007be2 <tcp_create_segment+0x2a>

08007c64 <tcp_output_alloc_header.constprop.0>:
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 8007c64:	3114      	adds	r1, #20
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
 8007c66:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 8007c68:	b289      	uxth	r1, r1
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
 8007c6a:	4605      	mov	r5, r0
 8007c6c:	4617      	mov	r7, r2
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 8007c6e:	2001      	movs	r0, #1
 8007c70:	2200      	movs	r2, #0
 8007c72:	f7fd ffe7 	bl	8005c44 <pbuf_alloc>
  if (p != NULL) {
 8007c76:	4606      	mov	r6, r0
 8007c78:	b1f8      	cbz	r0, 8007cba <tcp_output_alloc_header.constprop.0+0x56>
    tcphdr = (struct tcp_hdr *)p->payload;
 8007c7a:	6844      	ldr	r4, [r0, #4]
    tcphdr->src = htons(pcb->local_port);
 8007c7c:	8b68      	ldrh	r0, [r5, #26]
 8007c7e:	f7fc ffaf 	bl	8004be0 <lwip_htons>
 8007c82:	8020      	strh	r0, [r4, #0]
    tcphdr->dest = htons(pcb->remote_port);
 8007c84:	8ba8      	ldrh	r0, [r5, #28]
 8007c86:	f7fc ffab 	bl	8004be0 <lwip_htons>
    tcphdr->seqno = seqno_be;
 8007c8a:	6067      	str	r7, [r4, #4]
    tcphdr->dest = htons(pcb->remote_port);
 8007c8c:	8060      	strh	r0, [r4, #2]
    tcphdr->ackno = htonl(pcb->rcv_nxt);
 8007c8e:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 8007c90:	f7fc ffac 	bl	8004bec <lwip_htonl>
 8007c94:	60a0      	str	r0, [r4, #8]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
 8007c96:	f245 0010 	movw	r0, #20496	; 0x5010
 8007c9a:	f7fc ffa1 	bl	8004be0 <lwip_htons>
 8007c9e:	81a0      	strh	r0, [r4, #12]
    tcphdr->wnd = htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 8007ca0:	8de8      	ldrh	r0, [r5, #46]	; 0x2e
 8007ca2:	f7fc ff9d 	bl	8004be0 <lwip_htons>
    tcphdr->chksum = 0;
 8007ca6:	2300      	movs	r3, #0
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8007ca8:	8dea      	ldrh	r2, [r5, #46]	; 0x2e
    tcphdr->chksum = 0;
 8007caa:	7423      	strb	r3, [r4, #16]
 8007cac:	7463      	strb	r3, [r4, #17]
    tcphdr->urgp = 0;
 8007cae:	74a3      	strb	r3, [r4, #18]
 8007cb0:	74e3      	strb	r3, [r4, #19]
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8007cb2:	6aab      	ldr	r3, [r5, #40]	; 0x28
    tcphdr->wnd = htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 8007cb4:	81e0      	strh	r0, [r4, #14]
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8007cb6:	4413      	add	r3, r2
 8007cb8:	632b      	str	r3, [r5, #48]	; 0x30
}
 8007cba:	4630      	mov	r0, r6
 8007cbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08007cbe <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will not be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
 8007cbe:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007cc2:	b08f      	sub	sp, #60	; 0x3c
 8007cc4:	4692      	mov	sl, r2
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max/2));
 8007cc6:	8ec2      	ldrh	r2, [r0, #54]	; 0x36
{
 8007cc8:	4604      	mov	r4, r0
 8007cca:	9307      	str	r3, [sp, #28]
  u16_t oversize = 0;
 8007ccc:	2300      	movs	r3, #0
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
 8007cce:	9106      	str	r1, [sp, #24]
  u16_t oversize = 0;
 8007cd0:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
  u16_t mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max/2));
 8007cd4:	f8b0 3062 	ldrh.w	r3, [r0, #98]	; 0x62
 8007cd8:	085b      	lsrs	r3, r3, #1
 8007cda:	4293      	cmp	r3, r2
 8007cdc:	bf28      	it	cs
 8007cde:	4613      	movcs	r3, r2
  mss_local = mss_local ? mss_local : pcb->mss;
 8007ce0:	2b00      	cmp	r3, #0
 8007ce2:	bf08      	it	eq
 8007ce4:	4613      	moveq	r3, r2
 8007ce6:	9304      	str	r3, [sp, #16]
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
 8007ce8:	2900      	cmp	r1, #0
 8007cea:	f000 8165 	beq.w	8007fb8 <tcp_write+0x2fa>
  if ((pcb->state != ESTABLISHED) &&
 8007cee:	7e23      	ldrb	r3, [r4, #24]
 8007cf0:	2b07      	cmp	r3, #7
 8007cf2:	d003      	beq.n	8007cfc <tcp_write+0x3e>
      (pcb->state != CLOSE_WAIT) &&
 8007cf4:	3b02      	subs	r3, #2
 8007cf6:	2b02      	cmp	r3, #2
 8007cf8:	f200 8161 	bhi.w	8007fbe <tcp_write+0x300>
  } else if (len == 0) {
 8007cfc:	f1ba 0f00 	cmp.w	sl, #0
 8007d00:	d010      	beq.n	8007d24 <tcp_write+0x66>
  if (len > pcb->snd_buf) {
 8007d02:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
 8007d06:	4553      	cmp	r3, sl
 8007d08:	d208      	bcs.n	8007d1c <tcp_write+0x5e>
    pcb->flags |= TF_NAGLEMEMERR;
 8007d0a:	7fa3      	ldrb	r3, [r4, #30]
 8007d0c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8007d10:	77a3      	strb	r3, [r4, #30]
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
 8007d12:	f04f 30ff 	mov.w	r0, #4294967295
}
 8007d16:	b00f      	add	sp, #60	; 0x3c
 8007d18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 8007d1c:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 8007d20:	2b08      	cmp	r3, #8
 8007d22:	d8f2      	bhi.n	8007d0a <tcp_write+0x4c>
  queuelen = pcb->snd_queuelen;
 8007d24:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
  if (pcb->unsent != NULL) {
 8007d28:	f8d4 b06c 	ldr.w	fp, [r4, #108]	; 0x6c
  queuelen = pcb->snd_queuelen;
 8007d2c:	9305      	str	r3, [sp, #20]
  if (pcb->unsent != NULL) {
 8007d2e:	465e      	mov	r6, fp
 8007d30:	f1bb 0f00 	cmp.w	fp, #0
 8007d34:	d104      	bne.n	8007d40 <tcp_write+0x82>
  u16_t oversize_used = 0;
 8007d36:	465f      	mov	r7, fp
  u16_t pos = 0; /* position in 'arg' data */
 8007d38:	46d8      	mov	r8, fp
  struct pbuf *concat_p = NULL;
 8007d3a:	465d      	mov	r5, fp
 8007d3c:	e052      	b.n	8007de4 <tcp_write+0x126>
 8007d3e:	464e      	mov	r6, r9
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 8007d40:	f8d6 9000 	ldr.w	r9, [r6]
 8007d44:	f1b9 0f00 	cmp.w	r9, #0
 8007d48:	d1f9      	bne.n	8007d3e <tcp_write+0x80>
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 8007d4a:	7ab3      	ldrb	r3, [r6, #10]
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
 8007d4c:	8935      	ldrh	r5, [r6, #8]
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 8007d4e:	f013 0f01 	tst.w	r3, #1
    space = mss_local - (last_unsent->len + unsent_optlen);
 8007d52:	9a04      	ldr	r2, [sp, #16]
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 8007d54:	bf18      	it	ne
 8007d56:	2304      	movne	r3, #4
    space = mss_local - (last_unsent->len + unsent_optlen);
 8007d58:	eba2 0205 	sub.w	r2, r2, r5
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 8007d5c:	bf08      	it	eq
 8007d5e:	2300      	moveq	r3, #0
    space = mss_local - (last_unsent->len + unsent_optlen);
 8007d60:	1ad3      	subs	r3, r2, r3
 8007d62:	b29a      	uxth	r2, r3
    oversize = pcb->unsent_oversize;
 8007d64:	f8b4 306a 	ldrh.w	r3, [r4, #106]	; 0x6a
    if (oversize > 0) {
 8007d68:	2b00      	cmp	r3, #0
 8007d6a:	f000 8132 	beq.w	8007fd2 <tcp_write+0x314>
      oversize_used = oversize < len ? oversize : len;
 8007d6e:	459a      	cmp	sl, r3
 8007d70:	4657      	mov	r7, sl
 8007d72:	46b3      	mov	fp, r6
 8007d74:	bf28      	it	cs
 8007d76:	461f      	movcs	r7, r3
      oversize -= oversize_used;
 8007d78:	1bdb      	subs	r3, r3, r7
      space -= oversize_used;
 8007d7a:	1bd2      	subs	r2, r2, r7
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 8007d7c:	45ba      	cmp	sl, r7
      oversize -= oversize_used;
 8007d7e:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
      space -= oversize_used;
 8007d82:	b292      	uxth	r2, r2
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 8007d84:	f240 811e 	bls.w	8007fc4 <tcp_write+0x306>
 8007d88:	2a00      	cmp	r2, #0
 8007d8a:	d061      	beq.n	8007e50 <tcp_write+0x192>
 8007d8c:	2d00      	cmp	r5, #0
 8007d8e:	d062      	beq.n	8007e56 <tcp_write+0x198>
      u16_t seglen = space < len - pos ? space : len - pos;
 8007d90:	ebaa 0b07 	sub.w	fp, sl, r7
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 8007d94:	9b07      	ldr	r3, [sp, #28]
      u16_t seglen = space < len - pos ? space : len - pos;
 8007d96:	4593      	cmp	fp, r2
 8007d98:	bfa8      	it	ge
 8007d9a:	4693      	movge	fp, r2
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 8007d9c:	07db      	lsls	r3, r3, #31
      u16_t seglen = space < len - pos ? space : len - pos;
 8007d9e:	fa1f f88b 	uxth.w	r8, fp
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 8007da2:	d548      	bpl.n	8007e36 <tcp_write+0x178>
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
 8007da4:	2301      	movs	r3, #1
 8007da6:	9400      	str	r4, [sp, #0]
 8007da8:	4641      	mov	r1, r8
 8007daa:	2004      	movs	r0, #4
 8007dac:	9302      	str	r3, [sp, #8]
 8007dae:	9b07      	ldr	r3, [sp, #28]
 8007db0:	9301      	str	r3, [sp, #4]
 8007db2:	f10d 0336 	add.w	r3, sp, #54	; 0x36
 8007db6:	f7ff fed7 	bl	8007b68 <tcp_pbuf_prealloc>
 8007dba:	4605      	mov	r5, r0
 8007dbc:	2800      	cmp	r0, #0
 8007dbe:	f000 80f9 	beq.w	8007fb4 <tcp_write+0x2f6>
        TCP_DATA_COPY2(concat_p->payload, (const u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
 8007dc2:	9b06      	ldr	r3, [sp, #24]
 8007dc4:	4642      	mov	r2, r8
 8007dc6:	6840      	ldr	r0, [r0, #4]
 8007dc8:	19d9      	adds	r1, r3, r7
 8007dca:	f001 ff1a 	bl	8009c02 <memcpy>
      queuelen += pbuf_clen(concat_p);
 8007dce:	4628      	mov	r0, r5
      pos += seglen;
 8007dd0:	44b8      	add	r8, r7
      queuelen += pbuf_clen(concat_p);
 8007dd2:	f7fd ffe8 	bl	8005da6 <pbuf_clen>
 8007dd6:	9b05      	ldr	r3, [sp, #20]
      pos += seglen;
 8007dd8:	fa1f f888 	uxth.w	r8, r8
      queuelen += pbuf_clen(concat_p);
 8007ddc:	46b3      	mov	fp, r6
 8007dde:	4403      	add	r3, r0
 8007de0:	b29b      	uxth	r3, r3
 8007de2:	9305      	str	r3, [sp, #20]
    if (apiflags & TCP_WRITE_FLAG_COPY) {
 8007de4:	9b07      	ldr	r3, [sp, #28]
 8007de6:	f04f 0900 	mov.w	r9, #0
 8007dea:	f003 0301 	and.w	r3, r3, #1
 8007dee:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
 8007df2:	9308      	str	r3, [sp, #32]
  while (pos < len) {
 8007df4:	45d0      	cmp	r8, sl
 8007df6:	d330      	bcc.n	8007e5a <tcp_write+0x19c>
  if (oversize_used > 0) {
 8007df8:	b147      	cbz	r7, 8007e0c <tcp_write+0x14e>
    for (p = last_unsent->p; p; p = p->next) {
 8007dfa:	f8d6 8004 	ldr.w	r8, [r6, #4]
 8007dfe:	f1b8 0f00 	cmp.w	r8, #0
 8007e02:	f040 809a 	bne.w	8007f3a <tcp_write+0x27c>
    last_unsent->len += oversize_used;
 8007e06:	8933      	ldrh	r3, [r6, #8]
 8007e08:	441f      	add	r7, r3
 8007e0a:	8137      	strh	r7, [r6, #8]
  pcb->unsent_oversize = oversize;
 8007e0c:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
 8007e10:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
  if (concat_p != NULL) {
 8007e14:	2d00      	cmp	r5, #0
 8007e16:	f000 80a9 	beq.w	8007f6c <tcp_write+0x2ae>
    pbuf_cat(last_unsent->p, concat_p);
 8007e1a:	4629      	mov	r1, r5
 8007e1c:	6870      	ldr	r0, [r6, #4]
 8007e1e:	f7fd ffcf 	bl	8005dc0 <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
 8007e22:	8933      	ldrh	r3, [r6, #8]
 8007e24:	892a      	ldrh	r2, [r5, #8]
 8007e26:	4413      	add	r3, r2
 8007e28:	8133      	strh	r3, [r6, #8]
    last_unsent->next = queue;
 8007e2a:	f8c6 9000 	str.w	r9, [r6]
 8007e2e:	e0a2      	b.n	8007f76 <tcp_write+0x2b8>
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 8007e30:	464f      	mov	r7, r9
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 8007e32:	46cb      	mov	fp, r9
 8007e34:	e7a8      	b.n	8007d88 <tcp_write+0xca>
        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 8007e36:	2201      	movs	r2, #1
 8007e38:	4641      	mov	r1, r8
 8007e3a:	2004      	movs	r0, #4
 8007e3c:	f7fd ff02 	bl	8005c44 <pbuf_alloc>
 8007e40:	4605      	mov	r5, r0
 8007e42:	2800      	cmp	r0, #0
 8007e44:	f000 80b6 	beq.w	8007fb4 <tcp_write+0x2f6>
        ((struct pbuf_rom*)concat_p)->payload = (const u8_t*)arg + pos;
 8007e48:	9b06      	ldr	r3, [sp, #24]
 8007e4a:	443b      	add	r3, r7
 8007e4c:	6043      	str	r3, [r0, #4]
 8007e4e:	e7be      	b.n	8007dce <tcp_write+0x110>
 8007e50:	46b8      	mov	r8, r7
  struct pbuf *concat_p = NULL;
 8007e52:	4615      	mov	r5, r2
 8007e54:	e7c6      	b.n	8007de4 <tcp_write+0x126>
 8007e56:	46b8      	mov	r8, r7
 8007e58:	e7c4      	b.n	8007de4 <tcp_write+0x126>
    u16_t left = len - pos;
 8007e5a:	ebaa 0308 	sub.w	r3, sl, r8
    u16_t seglen = left > max_len ? max_len : left;
 8007e5e:	9a04      	ldr	r2, [sp, #16]
 8007e60:	b29b      	uxth	r3, r3
 8007e62:	4293      	cmp	r3, r2
 8007e64:	bf28      	it	cs
 8007e66:	4613      	movcs	r3, r2
 8007e68:	b29b      	uxth	r3, r3
 8007e6a:	9309      	str	r3, [sp, #36]	; 0x24
    if (apiflags & TCP_WRITE_FLAG_COPY) {
 8007e6c:	9b08      	ldr	r3, [sp, #32]
 8007e6e:	b303      	cbz	r3, 8007eb2 <tcp_write+0x1f4>
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
 8007e70:	fab9 f389 	clz	r3, r9
 8007e74:	9400      	str	r4, [sp, #0]
 8007e76:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007e78:	2000      	movs	r0, #0
 8007e7a:	095b      	lsrs	r3, r3, #5
 8007e7c:	9302      	str	r3, [sp, #8]
 8007e7e:	9b07      	ldr	r3, [sp, #28]
 8007e80:	9301      	str	r3, [sp, #4]
 8007e82:	f10d 0336 	add.w	r3, sp, #54	; 0x36
 8007e86:	f7ff fe6f 	bl	8007b68 <tcp_pbuf_prealloc>
 8007e8a:	4683      	mov	fp, r0
 8007e8c:	b330      	cbz	r0, 8007edc <tcp_write+0x21e>
      TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
 8007e8e:	9b06      	ldr	r3, [sp, #24]
 8007e90:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8007e92:	eb03 0108 	add.w	r1, r3, r8
 8007e96:	6840      	ldr	r0, [r0, #4]
 8007e98:	f001 feb3 	bl	8009c02 <memcpy>
    queuelen += pbuf_clen(p);
 8007e9c:	4658      	mov	r0, fp
 8007e9e:	f7fd ff82 	bl	8005da6 <pbuf_clen>
 8007ea2:	9b05      	ldr	r3, [sp, #20]
 8007ea4:	4403      	add	r3, r0
 8007ea6:	b29b      	uxth	r3, r3
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 8007ea8:	2b09      	cmp	r3, #9
    queuelen += pbuf_clen(p);
 8007eaa:	9305      	str	r3, [sp, #20]
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 8007eac:	d92a      	bls.n	8007f04 <tcp_write+0x246>
      pbuf_free(p);
 8007eae:	4658      	mov	r0, fp
 8007eb0:	e012      	b.n	8007ed8 <tcp_write+0x21a>
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 8007eb2:	2201      	movs	r2, #1
 8007eb4:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007eb6:	9808      	ldr	r0, [sp, #32]
 8007eb8:	f7fd fec4 	bl	8005c44 <pbuf_alloc>
 8007ebc:	b170      	cbz	r0, 8007edc <tcp_write+0x21e>
      ((struct pbuf_rom*)p2)->payload = (const u8_t*)arg + pos;
 8007ebe:	9a06      	ldr	r2, [sp, #24]
 8007ec0:	900b      	str	r0, [sp, #44]	; 0x2c
 8007ec2:	4442      	add	r2, r8
 8007ec4:	6042      	str	r2, [r0, #4]
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 8007ec6:	9a08      	ldr	r2, [sp, #32]
 8007ec8:	4611      	mov	r1, r2
 8007eca:	4610      	mov	r0, r2
 8007ecc:	f7fd feba 	bl	8005c44 <pbuf_alloc>
 8007ed0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007ed2:	4683      	mov	fp, r0
 8007ed4:	b990      	cbnz	r0, 8007efc <tcp_write+0x23e>
        pbuf_free(p2);
 8007ed6:	4618      	mov	r0, r3
      pbuf_free(p);
 8007ed8:	f7fd fe8d 	bl	8005bf6 <pbuf_free>
  pcb->flags |= TF_NAGLEMEMERR;
 8007edc:	7fa3      	ldrb	r3, [r4, #30]
 8007ede:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8007ee2:	77a3      	strb	r3, [r4, #30]
  if (concat_p != NULL) {
 8007ee4:	b115      	cbz	r5, 8007eec <tcp_write+0x22e>
    pbuf_free(concat_p);
 8007ee6:	4628      	mov	r0, r5
 8007ee8:	f7fd fe85 	bl	8005bf6 <pbuf_free>
  if (queue != NULL) {
 8007eec:	f1b9 0f00 	cmp.w	r9, #0
 8007ef0:	f43f af0f 	beq.w	8007d12 <tcp_write+0x54>
    tcp_segs_free(queue);
 8007ef4:	4648      	mov	r0, r9
 8007ef6:	f7fe f8eb 	bl	80060d0 <tcp_segs_free>
 8007efa:	e70a      	b.n	8007d12 <tcp_write+0x54>
      pbuf_cat(p/*header*/, p2/*data*/);
 8007efc:	4619      	mov	r1, r3
 8007efe:	f7fd ff5f 	bl	8005dc0 <pbuf_cat>
 8007f02:	e7cb      	b.n	8007e9c <tcp_write+0x1de>
    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 8007f04:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8007f06:	2200      	movs	r2, #0
 8007f08:	4659      	mov	r1, fp
 8007f0a:	4620      	mov	r0, r4
 8007f0c:	9200      	str	r2, [sp, #0]
 8007f0e:	4443      	add	r3, r8
 8007f10:	f7ff fe52 	bl	8007bb8 <tcp_create_segment>
 8007f14:	4683      	mov	fp, r0
 8007f16:	2800      	cmp	r0, #0
 8007f18:	d0e0      	beq.n	8007edc <tcp_write+0x21e>
    if (queue == NULL) {
 8007f1a:	f1b9 0f00 	cmp.w	r9, #0
 8007f1e:	d008      	beq.n	8007f32 <tcp_write+0x274>
      prev_seg->next = seg;
 8007f20:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007f22:	6018      	str	r0, [r3, #0]
    pos += seglen;
 8007f24:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007f26:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
 8007f2a:	4498      	add	r8, r3
 8007f2c:	fa1f f888 	uxth.w	r8, r8
 8007f30:	e760      	b.n	8007df4 <tcp_write+0x136>
 8007f32:	4681      	mov	r9, r0
 8007f34:	e7f6      	b.n	8007f24 <tcp_write+0x266>
  struct pbuf *concat_p = NULL;
 8007f36:	464d      	mov	r5, r9
 8007f38:	e75f      	b.n	8007dfa <tcp_write+0x13c>
      p->tot_len += oversize_used;
 8007f3a:	f8b8 3008 	ldrh.w	r3, [r8, #8]
 8007f3e:	443b      	add	r3, r7
 8007f40:	f8a8 3008 	strh.w	r3, [r8, #8]
      if (p->next == NULL) {
 8007f44:	f8d8 3000 	ldr.w	r3, [r8]
 8007f48:	b96b      	cbnz	r3, 8007f66 <tcp_write+0x2a8>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 8007f4a:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8007f4e:	463a      	mov	r2, r7
 8007f50:	f8b8 000a 	ldrh.w	r0, [r8, #10]
 8007f54:	9906      	ldr	r1, [sp, #24]
 8007f56:	4418      	add	r0, r3
 8007f58:	f001 fe53 	bl	8009c02 <memcpy>
        p->len += oversize_used;
 8007f5c:	f8b8 300a 	ldrh.w	r3, [r8, #10]
 8007f60:	443b      	add	r3, r7
 8007f62:	f8a8 300a 	strh.w	r3, [r8, #10]
    for (p = last_unsent->p; p; p = p->next) {
 8007f66:	f8d8 8000 	ldr.w	r8, [r8]
 8007f6a:	e748      	b.n	8007dfe <tcp_write+0x140>
  if (last_unsent == NULL) {
 8007f6c:	2e00      	cmp	r6, #0
 8007f6e:	f47f af5c 	bne.w	8007e2a <tcp_write+0x16c>
    pcb->unsent = queue;
 8007f72:	f8c4 906c 	str.w	r9, [r4, #108]	; 0x6c
  pcb->snd_lbb += len;
 8007f76:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8007f78:	4453      	add	r3, sl
 8007f7a:	65e3      	str	r3, [r4, #92]	; 0x5c
  pcb->snd_buf -= len;
 8007f7c:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
 8007f80:	eba3 0a0a 	sub.w	sl, r3, sl
  pcb->snd_queuelen = queuelen;
 8007f84:	f8bd 3014 	ldrh.w	r3, [sp, #20]
  pcb->snd_buf -= len;
 8007f88:	f8a4 a066 	strh.w	sl, [r4, #102]	; 0x66
  pcb->snd_queuelen = queuelen;
 8007f8c:	f8a4 3068 	strh.w	r3, [r4, #104]	; 0x68
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
 8007f90:	f1bb 0f00 	cmp.w	fp, #0
 8007f94:	d00c      	beq.n	8007fb0 <tcp_write+0x2f2>
 8007f96:	f8db 400c 	ldr.w	r4, [fp, #12]
 8007f9a:	b14c      	cbz	r4, 8007fb0 <tcp_write+0x2f2>
 8007f9c:	9b07      	ldr	r3, [sp, #28]
 8007f9e:	f013 0b02 	ands.w	fp, r3, #2
 8007fa2:	d105      	bne.n	8007fb0 <tcp_write+0x2f2>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 8007fa4:	89a5      	ldrh	r5, [r4, #12]
 8007fa6:	2008      	movs	r0, #8
 8007fa8:	f7fc fe1a 	bl	8004be0 <lwip_htons>
 8007fac:	4328      	orrs	r0, r5
 8007fae:	81a0      	strh	r0, [r4, #12]
  return ERR_OK;
 8007fb0:	2000      	movs	r0, #0
 8007fb2:	e6b0      	b.n	8007d16 <tcp_write+0x58>
  struct pbuf *concat_p = NULL;
 8007fb4:	2500      	movs	r5, #0
 8007fb6:	e791      	b.n	8007edc <tcp_write+0x21e>
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
 8007fb8:	f06f 000e 	mvn.w	r0, #14
 8007fbc:	e6ab      	b.n	8007d16 <tcp_write+0x58>
    return ERR_CONN;
 8007fbe:	f06f 000a 	mvn.w	r0, #10
 8007fc2:	e6a8      	b.n	8007d16 <tcp_write+0x58>
  if (oversize_used > 0) {
 8007fc4:	2f00      	cmp	r7, #0
 8007fc6:	d1b6      	bne.n	8007f36 <tcp_write+0x278>
  pcb->unsent_oversize = oversize;
 8007fc8:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
 8007fcc:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
 8007fd0:	e72b      	b.n	8007e2a <tcp_write+0x16c>
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 8007fd2:	f1ba 0f00 	cmp.w	sl, #0
 8007fd6:	f47f af2b 	bne.w	8007e30 <tcp_write+0x172>
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 8007fda:	46d3      	mov	fp, sl
 8007fdc:	e7f4      	b.n	8007fc8 <tcp_write+0x30a>

08007fde <tcp_enqueue_flags>:

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow (FIN flag should always come through!) */
  if (((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) &&
 8007fde:	f8b0 3068 	ldrh.w	r3, [r0, #104]	; 0x68
 8007fe2:	2b08      	cmp	r3, #8
{
 8007fe4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8007fe6:	4604      	mov	r4, r0
 8007fe8:	460d      	mov	r5, r1
 8007fea:	f001 0603 	and.w	r6, r1, #3
  if (((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) &&
 8007fee:	d908      	bls.n	8008002 <tcp_enqueue_flags+0x24>
 8007ff0:	07ca      	lsls	r2, r1, #31
 8007ff2:	d406      	bmi.n	8008002 <tcp_enqueue_flags+0x24>
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
 8007ff4:	7fa3      	ldrb	r3, [r4, #30]
 8007ff6:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8007ffa:	77a3      	strb	r3, [r4, #30]
    return ERR_MEM;
 8007ffc:	f04f 30ff 	mov.w	r0, #4294967295
 8008000:	e038      	b.n	8008074 <tcp_enqueue_flags+0x96>
 8008002:	f005 0302 	and.w	r3, r5, #2
  if (flags & TCP_SYN) {
 8008006:	2b00      	cmp	r3, #0
  if (pcb->snd_buf == 0) {
 8008008:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
  u8_t optflags = 0;
 800800c:	bf15      	itete	ne
 800800e:	2701      	movne	r7, #1
 8008010:	2700      	moveq	r7, #0
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
 8008012:	2104      	movne	r1, #4
 8008014:	2100      	moveq	r1, #0
  if (pcb->snd_buf == 0) {
 8008016:	2b00      	cmp	r3, #0
 8008018:	d0f0      	beq.n	8007ffc <tcp_enqueue_flags+0x1e>
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 800801a:	2200      	movs	r2, #0
 800801c:	4610      	mov	r0, r2
 800801e:	f7fd fe11 	bl	8005c44 <pbuf_alloc>
 8008022:	4601      	mov	r1, r0
 8008024:	2800      	cmp	r0, #0
 8008026:	d0e5      	beq.n	8007ff4 <tcp_enqueue_flags+0x16>
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 8008028:	9700      	str	r7, [sp, #0]
 800802a:	462a      	mov	r2, r5
 800802c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800802e:	4620      	mov	r0, r4
 8008030:	f7ff fdc2 	bl	8007bb8 <tcp_create_segment>
 8008034:	2800      	cmp	r0, #0
 8008036:	d0dd      	beq.n	8007ff4 <tcp_enqueue_flags+0x16>
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 8008038:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800803a:	b9f3      	cbnz	r3, 800807a <tcp_enqueue_flags+0x9c>
    pcb->unsent = seg;
 800803c:	66e0      	str	r0, [r4, #108]	; 0x6c
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
    useg->next = seg;
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
 800803e:	2300      	movs	r3, #0
 8008040:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 8008044:	b13e      	cbz	r6, 8008056 <tcp_enqueue_flags+0x78>
    pcb->snd_lbb++;
 8008046:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8008048:	3301      	adds	r3, #1
 800804a:	65e3      	str	r3, [r4, #92]	; 0x5c
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 800804c:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
 8008050:	3b01      	subs	r3, #1
 8008052:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
  }
  if (flags & TCP_FIN) {
 8008056:	07eb      	lsls	r3, r5, #31
    pcb->flags |= TF_FIN;
 8008058:	bf42      	ittt	mi
 800805a:	7fa3      	ldrbmi	r3, [r4, #30]
 800805c:	f043 0320 	orrmi.w	r3, r3, #32
 8008060:	77a3      	strbmi	r3, [r4, #30]
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 8008062:	6840      	ldr	r0, [r0, #4]
 8008064:	f7fd fe9f 	bl	8005da6 <pbuf_clen>
 8008068:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 800806c:	4418      	add	r0, r3
 800806e:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 8008072:	2000      	movs	r0, #0
}
 8008074:	b003      	add	sp, #12
 8008076:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008078:	4613      	mov	r3, r2
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 800807a:	681a      	ldr	r2, [r3, #0]
 800807c:	2a00      	cmp	r2, #0
 800807e:	d1fb      	bne.n	8008078 <tcp_enqueue_flags+0x9a>
    useg->next = seg;
 8008080:	6018      	str	r0, [r3, #0]
 8008082:	e7dc      	b.n	800803e <tcp_enqueue_flags+0x60>

08008084 <tcp_send_fin>:
{
 8008084:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (pcb->unsent != NULL) {
 8008086:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
{
 8008088:	4605      	mov	r5, r0
  if (pcb->unsent != NULL) {
 800808a:	b934      	cbnz	r4, 800809a <tcp_send_fin+0x16>
  return tcp_enqueue_flags(pcb, TCP_FIN);
 800808c:	4628      	mov	r0, r5
 800808e:	2101      	movs	r1, #1
}
 8008090:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  return tcp_enqueue_flags(pcb, TCP_FIN);
 8008094:	f7ff bfa3 	b.w	8007fde <tcp_enqueue_flags>
 8008098:	461c      	mov	r4, r3
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 800809a:	6823      	ldr	r3, [r4, #0]
 800809c:	2b00      	cmp	r3, #0
 800809e:	d1fb      	bne.n	8008098 <tcp_send_fin+0x14>
    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 80080a0:	68e3      	ldr	r3, [r4, #12]
 80080a2:	8998      	ldrh	r0, [r3, #12]
 80080a4:	f7fc fd9f 	bl	8004be6 <lwip_ntohs>
 80080a8:	f010 0707 	ands.w	r7, r0, #7
 80080ac:	d1ee      	bne.n	800808c <tcp_send_fin+0x8>
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 80080ae:	68e6      	ldr	r6, [r4, #12]
 80080b0:	2001      	movs	r0, #1
 80080b2:	89b4      	ldrh	r4, [r6, #12]
 80080b4:	f7fc fd94 	bl	8004be0 <lwip_htons>
 80080b8:	4320      	orrs	r0, r4
 80080ba:	81b0      	strh	r0, [r6, #12]
}
 80080bc:	4638      	mov	r0, r7
      pcb->flags |= TF_FIN;
 80080be:	7fab      	ldrb	r3, [r5, #30]
 80080c0:	f043 0320 	orr.w	r3, r3, #32
 80080c4:	77ab      	strb	r3, [r5, #30]
}
 80080c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080080c8 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 80080c8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 80080ca:	4604      	mov	r4, r0
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
 80080cc:	6d00      	ldr	r0, [r0, #80]	; 0x50
 80080ce:	f7fc fd8d 	bl	8004bec <lwip_htonl>
 80080d2:	2100      	movs	r1, #0
 80080d4:	4602      	mov	r2, r0
 80080d6:	4620      	mov	r0, r4
 80080d8:	f7ff fdc4 	bl	8007c64 <tcp_output_alloc_header.constprop.0>
  if (p == NULL) {
 80080dc:	4606      	mov	r6, r0
 80080de:	b940      	cbnz	r0, 80080f2 <tcp_send_empty_ack+0x2a>
    /* let tcp_fasttmr retry sending this ACK */
    pcb->flags |= (TF_ACK_DELAY | TF_ACK_NOW);
 80080e0:	7fa3      	ldrb	r3, [r4, #30]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
 80080e2:	f06f 0501 	mvn.w	r5, #1
    pcb->flags |= (TF_ACK_DELAY | TF_ACK_NOW);
 80080e6:	f043 0303 	orr.w	r3, r3, #3
 80080ea:	77a3      	strb	r3, [r4, #30]
    /* remove ACK flags from the PCB, as we sent an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  }

  return err;
}
 80080ec:	4628      	mov	r0, r5
 80080ee:	b004      	add	sp, #16
 80080f0:	bd70      	pop	{r4, r5, r6, pc}
  netif = ip_route(PCB_ISIPV6(pcb), &pcb->local_ip, &pcb->remote_ip);
 80080f2:	1d25      	adds	r5, r4, #4
 80080f4:	4628      	mov	r0, r5
 80080f6:	f7fc fe49 	bl	8004d8c <ip4_route>
  if (netif == NULL) {
 80080fa:	b1a0      	cbz	r0, 8008126 <tcp_send_empty_ack+0x5e>
    err = ip_output_if(PCB_ISIPV6(pcb), p, &pcb->local_ip, &pcb->remote_ip,
 80080fc:	2206      	movs	r2, #6
 80080fe:	9002      	str	r0, [sp, #8]
 8008100:	7aa3      	ldrb	r3, [r4, #10]
 8008102:	4621      	mov	r1, r4
 8008104:	9201      	str	r2, [sp, #4]
 8008106:	4630      	mov	r0, r6
 8008108:	7a62      	ldrb	r2, [r4, #9]
 800810a:	9200      	str	r2, [sp, #0]
 800810c:	462a      	mov	r2, r5
 800810e:	f7fc ff73 	bl	8004ff8 <ip4_output_if>
 8008112:	4605      	mov	r5, r0
  pbuf_free(p);
 8008114:	4630      	mov	r0, r6
 8008116:	f7fd fd6e 	bl	8005bf6 <pbuf_free>
 800811a:	7fa3      	ldrb	r3, [r4, #30]
  if (err != ERR_OK) {
 800811c:	b135      	cbz	r5, 800812c <tcp_send_empty_ack+0x64>
    pcb->flags |= (TF_ACK_DELAY | TF_ACK_NOW);
 800811e:	f043 0303 	orr.w	r3, r3, #3
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8008122:	77a3      	strb	r3, [r4, #30]
 8008124:	e7e2      	b.n	80080ec <tcp_send_empty_ack+0x24>
    err = ERR_RTE;
 8008126:	f06f 0503 	mvn.w	r5, #3
 800812a:	e7f3      	b.n	8008114 <tcp_send_empty_ack+0x4c>
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 800812c:	f023 0303 	bic.w	r3, r3, #3
 8008130:	e7f7      	b.n	8008122 <tcp_send_empty_ack+0x5a>
	...

08008134 <tcp_output>:

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 8008134:	4b9a      	ldr	r3, [pc, #616]	; (80083a0 <tcp_output+0x26c>)
 8008136:	681b      	ldr	r3, [r3, #0]
 8008138:	4298      	cmp	r0, r3
{
 800813a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800813e:	4604      	mov	r4, r0
 8008140:	b085      	sub	sp, #20
  if (tcp_input_pcb == pcb) {
 8008142:	d02b      	beq.n	800819c <tcp_output+0x68>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 8008144:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
 8008148:	f8b0 7060 	ldrh.w	r7, [r0, #96]	; 0x60

  seg = pcb->unsent;
 800814c:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 800814e:	429f      	cmp	r7, r3
 8008150:	bf28      	it	cs
 8008152:	461f      	movcs	r7, r3
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
 8008154:	7f83      	ldrb	r3, [r0, #30]
 8008156:	079a      	lsls	r2, r3, #30
 8008158:	d510      	bpl.n	800817c <tcp_output+0x48>
 800815a:	b92d      	cbnz	r5, 8008168 <tcp_output+0x34>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
 800815c:	4620      	mov	r0, r4
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
 800815e:	b005      	add	sp, #20
 8008160:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     return tcp_send_empty_ack(pcb);
 8008164:	f7ff bfb0 	b.w	80080c8 <tcp_send_empty_ack>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
 8008168:	68eb      	ldr	r3, [r5, #12]
 800816a:	6858      	ldr	r0, [r3, #4]
 800816c:	f7fc fd40 	bl	8004bf0 <lwip_ntohl>
 8008170:	892b      	ldrh	r3, [r5, #8]
 8008172:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8008174:	1a9b      	subs	r3, r3, r2
 8008176:	4418      	add	r0, r3
     (seg == NULL ||
 8008178:	4287      	cmp	r7, r0
 800817a:	d3ef      	bcc.n	800815c <tcp_output+0x28>
  useg = pcb->unacked;
 800817c:	6f26      	ldr	r6, [r4, #112]	; 0x70
  if (useg != NULL) {
 800817e:	b986      	cbnz	r6, 80081a2 <tcp_output+0x6e>
 8008180:	f104 0804 	add.w	r8, r4, #4
    }
    ip_addr_copy(pcb->local_ip, *local_ip);
  }

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
 8008184:	f8df 921c 	ldr.w	r9, [pc, #540]	; 80083a4 <tcp_output+0x270>
  while (seg != NULL &&
 8008188:	2d00      	cmp	r5, #0
 800818a:	d173      	bne.n	8008274 <tcp_output+0x140>
  if (pcb->unsent == NULL) {
 800818c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800818e:	b90b      	cbnz	r3, 8008194 <tcp_output+0x60>
    pcb->unsent_oversize = 0;
 8008190:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
  pcb->flags &= ~TF_NAGLEMEMERR;
 8008194:	7fa3      	ldrb	r3, [r4, #30]
 8008196:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800819a:	77a3      	strb	r3, [r4, #30]
    return ERR_OK;
 800819c:	2000      	movs	r0, #0
 800819e:	e0f8      	b.n	8008392 <tcp_output+0x25e>
 80081a0:	461e      	mov	r6, r3
    for (; useg->next != NULL; useg = useg->next);
 80081a2:	6833      	ldr	r3, [r6, #0]
 80081a4:	2b00      	cmp	r3, #0
 80081a6:	d1fb      	bne.n	80081a0 <tcp_output+0x6c>
 80081a8:	e7ea      	b.n	8008180 <tcp_output+0x4c>
    return ERR_RTE;
 80081aa:	f06f 0003 	mvn.w	r0, #3
 80081ae:	e0ec      	b.n	800838a <tcp_output+0x256>
    pcb->unsent = seg->next;
 80081b0:	682b      	ldr	r3, [r5, #0]
 80081b2:	66e3      	str	r3, [r4, #108]	; 0x6c
    if (pcb->state != SYN_SENT) {
 80081b4:	7e23      	ldrb	r3, [r4, #24]
 80081b6:	2b02      	cmp	r3, #2
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 80081b8:	bf1e      	ittt	ne
 80081ba:	7fa3      	ldrbne	r3, [r4, #30]
 80081bc:	f023 0303 	bicne.w	r3, r3, #3
 80081c0:	77a3      	strbne	r3, [r4, #30]
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 80081c2:	68eb      	ldr	r3, [r5, #12]
 80081c4:	6858      	ldr	r0, [r3, #4]
 80081c6:	f7fc fd13 	bl	8004bf0 <lwip_ntohl>
 80081ca:	68eb      	ldr	r3, [r5, #12]
 80081cc:	4682      	mov	sl, r0
 80081ce:	f8b5 b008 	ldrh.w	fp, [r5, #8]
 80081d2:	8998      	ldrh	r0, [r3, #12]
 80081d4:	f7fc fd07 	bl	8004be6 <lwip_ntohs>
 80081d8:	f010 0003 	ands.w	r0, r0, #3
 80081dc:	44da      	add	sl, fp
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 80081de:	6d23      	ldr	r3, [r4, #80]	; 0x50
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 80081e0:	bf18      	it	ne
 80081e2:	2001      	movne	r0, #1
 80081e4:	4450      	add	r0, sl
    if (TCP_TCPLEN(seg) > 0) {
 80081e6:	f8b5 a008 	ldrh.w	sl, [r5, #8]
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 80081ea:	1a1b      	subs	r3, r3, r0
 80081ec:	2b00      	cmp	r3, #0
    if (TCP_TCPLEN(seg) > 0) {
 80081ee:	68eb      	ldr	r3, [r5, #12]
      pcb->snd_nxt = snd_nxt;
 80081f0:	bfb8      	it	lt
 80081f2:	6520      	strlt	r0, [r4, #80]	; 0x50
    if (TCP_TCPLEN(seg) > 0) {
 80081f4:	8998      	ldrh	r0, [r3, #12]
 80081f6:	f7fc fcf6 	bl	8004be6 <lwip_ntohs>
 80081fa:	f010 0003 	ands.w	r0, r0, #3
 80081fe:	bf18      	it	ne
 8008200:	2001      	movne	r0, #1
 8008202:	eb10 0f0a 	cmn.w	r0, sl
 8008206:	d031      	beq.n	800826c <tcp_output+0x138>
      seg->next = NULL;
 8008208:	2300      	movs	r3, #0
 800820a:	602b      	str	r3, [r5, #0]
      if (pcb->unacked == NULL) {
 800820c:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800820e:	b913      	cbnz	r3, 8008216 <tcp_output+0xe2>
        pcb->unacked = seg;
 8008210:	6725      	str	r5, [r4, #112]	; 0x70
          useg->next = seg;
 8008212:	462e      	mov	r6, r5
 8008214:	e016      	b.n	8008244 <tcp_output+0x110>
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
 8008216:	68eb      	ldr	r3, [r5, #12]
 8008218:	6858      	ldr	r0, [r3, #4]
 800821a:	f7fc fce9 	bl	8004bf0 <lwip_ntohl>
 800821e:	68f3      	ldr	r3, [r6, #12]
 8008220:	4682      	mov	sl, r0
 8008222:	6858      	ldr	r0, [r3, #4]
 8008224:	f7fc fce4 	bl	8004bf0 <lwip_ntohl>
 8008228:	ebaa 0000 	sub.w	r0, sl, r0
 800822c:	2800      	cmp	r0, #0
 800822e:	da1b      	bge.n	8008268 <tcp_output+0x134>
          struct tcp_seg **cur_seg = &(pcb->unacked);
 8008230:	f104 0a70 	add.w	sl, r4, #112	; 0x70
          while (*cur_seg &&
 8008234:	f8da 3000 	ldr.w	r3, [sl]
 8008238:	b933      	cbnz	r3, 8008248 <tcp_output+0x114>
          seg->next = (*cur_seg);
 800823a:	f8da 3000 	ldr.w	r3, [sl]
 800823e:	602b      	str	r3, [r5, #0]
          (*cur_seg) = seg;
 8008240:	f8ca 5000 	str.w	r5, [sl]
    seg = pcb->unsent;
 8008244:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
 8008246:	e79f      	b.n	8008188 <tcp_output+0x54>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 8008248:	68db      	ldr	r3, [r3, #12]
 800824a:	6858      	ldr	r0, [r3, #4]
 800824c:	f7fc fcd0 	bl	8004bf0 <lwip_ntohl>
 8008250:	68eb      	ldr	r3, [r5, #12]
 8008252:	4683      	mov	fp, r0
 8008254:	6858      	ldr	r0, [r3, #4]
 8008256:	f7fc fccb 	bl	8004bf0 <lwip_ntohl>
 800825a:	ebab 0000 	sub.w	r0, fp, r0
          while (*cur_seg &&
 800825e:	2800      	cmp	r0, #0
 8008260:	daeb      	bge.n	800823a <tcp_output+0x106>
              cur_seg = &((*cur_seg)->next );
 8008262:	f8da a000 	ldr.w	sl, [sl]
 8008266:	e7e5      	b.n	8008234 <tcp_output+0x100>
          useg->next = seg;
 8008268:	6035      	str	r5, [r6, #0]
 800826a:	e7d2      	b.n	8008212 <tcp_output+0xde>
      tcp_seg_free(seg);
 800826c:	4628      	mov	r0, r5
 800826e:	f7fd ff21 	bl	80060b4 <tcp_seg_free>
 8008272:	e7e7      	b.n	8008244 <tcp_output+0x110>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 8008274:	68eb      	ldr	r3, [r5, #12]
 8008276:	6858      	ldr	r0, [r3, #4]
 8008278:	f7fc fcba 	bl	8004bf0 <lwip_ntohl>
 800827c:	892b      	ldrh	r3, [r5, #8]
 800827e:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8008280:	1a9b      	subs	r3, r3, r2
 8008282:	4418      	add	r0, r3
  while (seg != NULL &&
 8008284:	4287      	cmp	r7, r0
 8008286:	d381      	bcc.n	800818c <tcp_output+0x58>
    LWIP_ASSERT("RST not expected here!",
 8008288:	68eb      	ldr	r3, [r5, #12]
 800828a:	8998      	ldrh	r0, [r3, #12]
 800828c:	f7fc fcab 	bl	8004be6 <lwip_ntohs>
    if((tcp_do_output_nagle(pcb) == 0) &&
 8008290:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8008292:	b193      	cbz	r3, 80082ba <tcp_output+0x186>
 8008294:	7fa2      	ldrb	r2, [r4, #30]
 8008296:	f012 0f44 	tst.w	r2, #68	; 0x44
 800829a:	d10e      	bne.n	80082ba <tcp_output+0x186>
 800829c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800829e:	b12b      	cbz	r3, 80082ac <tcp_output+0x178>
 80082a0:	6819      	ldr	r1, [r3, #0]
 80082a2:	b951      	cbnz	r1, 80082ba <tcp_output+0x186>
 80082a4:	8919      	ldrh	r1, [r3, #8]
 80082a6:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80082a8:	4299      	cmp	r1, r3
 80082aa:	d206      	bcs.n	80082ba <tcp_output+0x186>
 80082ac:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
 80082b0:	b11b      	cbz	r3, 80082ba <tcp_output+0x186>
 80082b2:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 80082b6:	2b08      	cmp	r3, #8
 80082b8:	d96e      	bls.n	8008398 <tcp_output+0x264>
    if (pcb->state != SYN_SENT) {
 80082ba:	7e23      	ldrb	r3, [r4, #24]
 80082bc:	2b02      	cmp	r3, #2
 80082be:	d00a      	beq.n	80082d6 <tcp_output+0x1a2>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 80082c0:	f8d5 b00c 	ldr.w	fp, [r5, #12]
 80082c4:	2010      	movs	r0, #16
 80082c6:	f8bb a00c 	ldrh.w	sl, [fp, #12]
 80082ca:	f7fc fc89 	bl	8004be0 <lwip_htons>
 80082ce:	ea4a 0000 	orr.w	r0, sl, r0
 80082d2:	f8ab 000c 	strh.w	r0, [fp, #12]
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
 80082d6:	f8d5 a00c 	ldr.w	sl, [r5, #12]
 80082da:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80082dc:	f7fc fc86 	bl	8004bec <lwip_htonl>
 80082e0:	f8ca 0008 	str.w	r0, [sl, #8]
    seg->tcphdr->wnd = htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 80082e4:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
 80082e6:	f8d5 a00c 	ldr.w	sl, [r5, #12]
 80082ea:	f7fc fc79 	bl	8004be0 <lwip_htons>
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 80082ee:	8de2      	ldrh	r2, [r4, #46]	; 0x2e
 80082f0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    seg->tcphdr->wnd = htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 80082f2:	f8aa 000e 	strh.w	r0, [sl, #14]
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 80082f6:	4413      	add	r3, r2
 80082f8:	6323      	str	r3, [r4, #48]	; 0x30
  if (seg->flags & TF_SEG_OPTS_MSS) {
 80082fa:	7aab      	ldrb	r3, [r5, #10]
 80082fc:	07db      	lsls	r3, r3, #31
 80082fe:	d50c      	bpl.n	800831a <tcp_output+0x1e6>
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 8008300:	f8d5 a00c 	ldr.w	sl, [r5, #12]
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->local_ip, &pcb->remote_ip, PCB_ISIPV6(pcb));
 8008304:	4641      	mov	r1, r8
 8008306:	f44f 7006 	mov.w	r0, #536	; 0x218
 800830a:	f7fe fb74 	bl	80069f6 <tcp_eff_send_mss_impl>
    *opts = TCP_BUILD_MSS_OPTION(mss);
 800830e:	f040 7001 	orr.w	r0, r0, #33816576	; 0x2040000
 8008312:	f7fc fc6b 	bl	8004bec <lwip_htonl>
 8008316:	f8ca 0014 	str.w	r0, [sl, #20]
  if (pcb->rtime == -1) {
 800831a:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
  netif = ip_route(PCB_ISIPV6(pcb), &pcb->local_ip, &pcb->remote_ip);
 800831e:	4640      	mov	r0, r8
  if (pcb->rtime == -1) {
 8008320:	3301      	adds	r3, #1
    pcb->rtime = 0;
 8008322:	bf04      	itt	eq
 8008324:	2300      	moveq	r3, #0
 8008326:	86a3      	strheq	r3, [r4, #52]	; 0x34
  netif = ip_route(PCB_ISIPV6(pcb), &pcb->local_ip, &pcb->remote_ip);
 8008328:	f7fc fd30 	bl	8004d8c <ip4_route>
  if (netif == NULL) {
 800832c:	4682      	mov	sl, r0
 800832e:	2800      	cmp	r0, #0
 8008330:	f43f af3b 	beq.w	80081aa <tcp_output+0x76>
  if (ip_addr_isany(&pcb->local_ip)) {
 8008334:	6823      	ldr	r3, [r4, #0]
 8008336:	b90b      	cbnz	r3, 800833c <tcp_output+0x208>
    ip_addr_copy(pcb->local_ip, *local_ip);
 8008338:	6843      	ldr	r3, [r0, #4]
 800833a:	6023      	str	r3, [r4, #0]
  if (pcb->rttest == 0) {
 800833c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800833e:	b93b      	cbnz	r3, 8008350 <tcp_output+0x21c>
    pcb->rttest = tcp_ticks;
 8008340:	f8d9 3000 	ldr.w	r3, [r9]
 8008344:	63a3      	str	r3, [r4, #56]	; 0x38
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
 8008346:	68eb      	ldr	r3, [r5, #12]
 8008348:	6858      	ldr	r0, [r3, #4]
 800834a:	f7fc fc51 	bl	8004bf0 <lwip_ntohl>
 800834e:	63e0      	str	r0, [r4, #60]	; 0x3c
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 8008350:	6868      	ldr	r0, [r5, #4]
 8008352:	68ea      	ldr	r2, [r5, #12]
 8008354:	6843      	ldr	r3, [r0, #4]

  seg->p->len -= len;
 8008356:	8941      	ldrh	r1, [r0, #10]
  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 8008358:	1ad3      	subs	r3, r2, r3
  seg->p->tot_len -= len;

  seg->p->payload = seg->tcphdr;
 800835a:	6042      	str	r2, [r0, #4]
  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 800835c:	b29b      	uxth	r3, r3
  seg->p->len -= len;
 800835e:	1ac9      	subs	r1, r1, r3
 8008360:	8141      	strh	r1, [r0, #10]
  seg->p->tot_len -= len;
 8008362:	8901      	ldrh	r1, [r0, #8]
 8008364:	1acb      	subs	r3, r1, r3
  }
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);

  NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
  err = ip_output_if(PCB_ISIPV6(pcb), seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 8008366:	4621      	mov	r1, r4
  seg->p->tot_len -= len;
 8008368:	8103      	strh	r3, [r0, #8]
  seg->tcphdr->chksum = 0;
 800836a:	2300      	movs	r3, #0
 800836c:	7413      	strb	r3, [r2, #16]
 800836e:	7453      	strb	r3, [r2, #17]
  err = ip_output_if(PCB_ISIPV6(pcb), seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 8008370:	2206      	movs	r2, #6
 8008372:	7aa3      	ldrb	r3, [r4, #10]
 8008374:	9201      	str	r2, [sp, #4]
 8008376:	7a62      	ldrb	r2, [r4, #9]
 8008378:	f8cd a008 	str.w	sl, [sp, #8]
 800837c:	9200      	str	r2, [sp, #0]
 800837e:	4642      	mov	r2, r8
 8008380:	f7fc fe3a 	bl	8004ff8 <ip4_output_if>
    if (err != ERR_OK) {
 8008384:	2800      	cmp	r0, #0
 8008386:	f43f af13 	beq.w	80081b0 <tcp_output+0x7c>
      pcb->flags |= TF_NAGLEMEMERR;
 800838a:	7fa3      	ldrb	r3, [r4, #30]
 800838c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8008390:	77a3      	strb	r3, [r4, #30]
}
 8008392:	b005      	add	sp, #20
 8008394:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if((tcp_do_output_nagle(pcb) == 0) &&
 8008398:	f012 0fa0 	tst.w	r2, #160	; 0xa0
 800839c:	d18d      	bne.n	80082ba <tcp_output+0x186>
 800839e:	e6f5      	b.n	800818c <tcp_output+0x58>
 80083a0:	2000767c 	.word	0x2000767c
 80083a4:	2000766c 	.word	0x2000766c

080083a8 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
 80083a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80083ac:	b085      	sub	sp, #20
 80083ae:	4681      	mov	r9, r0
 80083b0:	460d      	mov	r5, r1
 80083b2:	4690      	mov	r8, r2
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  struct netif *netif;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 80083b4:	2114      	movs	r1, #20
 80083b6:	2200      	movs	r2, #0
 80083b8:	2001      	movs	r0, #1
{
 80083ba:	461f      	mov	r7, r3
 80083bc:	f8bd b038 	ldrh.w	fp, [sp, #56]	; 0x38
 80083c0:	f8bd a03c 	ldrh.w	sl, [sp, #60]	; 0x3c
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 80083c4:	f7fd fc3e 	bl	8005c44 <pbuf_alloc>
  if (p == NULL) {
 80083c8:	4606      	mov	r6, r0
 80083ca:	b390      	cbz	r0, 8008432 <tcp_rst+0x8a>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
 80083cc:	6844      	ldr	r4, [r0, #4]
  tcphdr->src = htons(local_port);
 80083ce:	4658      	mov	r0, fp
 80083d0:	f7fc fc06 	bl	8004be0 <lwip_htons>
 80083d4:	8020      	strh	r0, [r4, #0]
  tcphdr->dest = htons(remote_port);
 80083d6:	4650      	mov	r0, sl
 80083d8:	f7fc fc02 	bl	8004be0 <lwip_htons>
 80083dc:	8060      	strh	r0, [r4, #2]
  tcphdr->seqno = htonl(seqno);
 80083de:	4648      	mov	r0, r9
 80083e0:	f7fc fc04 	bl	8004bec <lwip_htonl>
 80083e4:	6060      	str	r0, [r4, #4]
  tcphdr->ackno = htonl(ackno);
 80083e6:	4628      	mov	r0, r5
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
#if LWIP_WND_SCALE
  tcphdr->wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
#else
  tcphdr->wnd = PP_HTONS(TCP_WND);
 80083e8:	2500      	movs	r5, #0
  tcphdr->ackno = htonl(ackno);
 80083ea:	f7fc fbff 	bl	8004bec <lwip_htonl>
 80083ee:	60a0      	str	r0, [r4, #8]
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 80083f0:	f245 0014 	movw	r0, #20500	; 0x5014
 80083f4:	f7fc fbf4 	bl	8004be0 <lwip_htons>
  tcphdr->wnd = PP_HTONS(TCP_WND);
 80083f8:	2308      	movs	r3, #8
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 80083fa:	81a0      	strh	r0, [r4, #12]
  tcphdr->urgp = 0;

  TCP_STATS_INC(tcp.xmit);
  MIB2_STATS_INC(mib2.tcpoutrsts);

  netif = ip_route(IP_IS_V6(remote_ip), local_ip, remote_ip);
 80083fc:	4638      	mov	r0, r7
  tcphdr->wnd = PP_HTONS(TCP_WND);
 80083fe:	73a3      	strb	r3, [r4, #14]
 8008400:	2360      	movs	r3, #96	; 0x60
  tcphdr->chksum = 0;
 8008402:	7425      	strb	r5, [r4, #16]
  tcphdr->wnd = PP_HTONS(TCP_WND);
 8008404:	73e3      	strb	r3, [r4, #15]
  tcphdr->chksum = 0;
 8008406:	7465      	strb	r5, [r4, #17]
  tcphdr->urgp = 0;
 8008408:	74a5      	strb	r5, [r4, #18]
 800840a:	74e5      	strb	r5, [r4, #19]
  netif = ip_route(IP_IS_V6(remote_ip), local_ip, remote_ip);
 800840c:	f7fc fcbe 	bl	8004d8c <ip4_route>
  if (netif != NULL) {
 8008410:	b148      	cbz	r0, 8008426 <tcp_rst+0x7e>
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
                                        local_ip, remote_ip);
    }
#endif
    /* Send output with hardcoded TTL/HL since we have no access to the pcb */
    ip_output_if(IP_IS_V6(remote_ip), p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP, netif);
 8008412:	2306      	movs	r3, #6
 8008414:	9002      	str	r0, [sp, #8]
 8008416:	9500      	str	r5, [sp, #0]
 8008418:	463a      	mov	r2, r7
 800841a:	9301      	str	r3, [sp, #4]
 800841c:	4641      	mov	r1, r8
 800841e:	23ff      	movs	r3, #255	; 0xff
 8008420:	4630      	mov	r0, r6
 8008422:	f7fc fde9 	bl	8004ff8 <ip4_output_if>
  }
  pbuf_free(p);
 8008426:	4630      	mov	r0, r6
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 8008428:	b005      	add	sp, #20
 800842a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  pbuf_free(p);
 800842e:	f7fd bbe2 	b.w	8005bf6 <pbuf_free>
}
 8008432:	b005      	add	sp, #20
 8008434:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08008438 <tcp_rexmit_rto>:
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
 8008438:	6f02      	ldr	r2, [r0, #112]	; 0x70
{
 800843a:	b410      	push	{r4}
  if (pcb->unacked == NULL) {
 800843c:	b192      	cbz	r2, 8008464 <tcp_rexmit_rto+0x2c>
 800843e:	4611      	mov	r1, r2
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
 8008440:	680b      	ldr	r3, [r1, #0]
 8008442:	b96b      	cbnz	r3, 8008460 <tcp_rexmit_rto+0x28>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 8008444:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
 8008446:	600c      	str	r4, [r1, #0]
  if (pcb->unsent == NULL) {
    pcb->unsent_oversize = seg->oversize_left;
  }
#endif /* TCP_OVERSIZE_DBGCHECK */
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 8008448:	66c2      	str	r2, [r0, #108]	; 0x6c
  /* unacked queue is now empty */
  pcb->unacked = NULL;

  /* increment number of retransmissions */
  ++pcb->nrtx;
 800844a:	f890 2046 	ldrb.w	r2, [r0, #70]	; 0x46
  pcb->unacked = NULL;
 800844e:	6703      	str	r3, [r0, #112]	; 0x70
  ++pcb->nrtx;
 8008450:	3201      	adds	r2, #1

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 8008452:	6383      	str	r3, [r0, #56]	; 0x38
  ++pcb->nrtx;
 8008454:	f880 2046 	strb.w	r2, [r0, #70]	; 0x46

  /* Do the actual retransmission */
  tcp_output(pcb);
}
 8008458:	f85d 4b04 	ldr.w	r4, [sp], #4
  tcp_output(pcb);
 800845c:	f7ff be6a 	b.w	8008134 <tcp_output>
 8008460:	4619      	mov	r1, r3
 8008462:	e7ed      	b.n	8008440 <tcp_rexmit_rto+0x8>
}
 8008464:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008468:	4770      	bx	lr

0800846a <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
 800846a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
 800846c:	6f05      	ldr	r5, [r0, #112]	; 0x70
{
 800846e:	4604      	mov	r4, r0
  if (pcb->unacked == NULL) {
 8008470:	b19d      	cbz	r5, 800849a <tcp_rexmit+0x30>
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;
 8008472:	682b      	ldr	r3, [r5, #0]

  cur_seg = &(pcb->unsent);
 8008474:	f100 066c 	add.w	r6, r0, #108	; 0x6c
  pcb->unacked = seg->next;
 8008478:	6703      	str	r3, [r0, #112]	; 0x70
  while (*cur_seg &&
 800847a:	6833      	ldr	r3, [r6, #0]
 800847c:	b973      	cbnz	r3, 800849c <tcp_rexmit+0x32>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
 800847e:	6833      	ldr	r3, [r6, #0]
 8008480:	602b      	str	r3, [r5, #0]
  *cur_seg = seg;
 8008482:	6035      	str	r5, [r6, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 8008484:	682b      	ldr	r3, [r5, #0]
 8008486:	b90b      	cbnz	r3, 800848c <tcp_rexmit+0x22>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
 8008488:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
 800848c:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8008490:	3301      	adds	r3, #1
 8008492:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 8008496:	2300      	movs	r3, #0
 8008498:	63a3      	str	r3, [r4, #56]	; 0x38
 800849a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 800849c:	68db      	ldr	r3, [r3, #12]
 800849e:	6858      	ldr	r0, [r3, #4]
 80084a0:	f7fc fba6 	bl	8004bf0 <lwip_ntohl>
 80084a4:	68eb      	ldr	r3, [r5, #12]
 80084a6:	4607      	mov	r7, r0
 80084a8:	6858      	ldr	r0, [r3, #4]
 80084aa:	f7fc fba1 	bl	8004bf0 <lwip_ntohl>
 80084ae:	1a38      	subs	r0, r7, r0
  while (*cur_seg &&
 80084b0:	2800      	cmp	r0, #0
 80084b2:	dae4      	bge.n	800847e <tcp_rexmit+0x14>
      cur_seg = &((*cur_seg)->next );
 80084b4:	6836      	ldr	r6, [r6, #0]
 80084b6:	e7e0      	b.n	800847a <tcp_rexmit+0x10>

080084b8 <tcp_rexmit_fast>:
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 80084b8:	6f03      	ldr	r3, [r0, #112]	; 0x70
{
 80084ba:	b510      	push	{r4, lr}
 80084bc:	4604      	mov	r4, r0
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 80084be:	b31b      	cbz	r3, 8008508 <tcp_rexmit_fast+0x50>
 80084c0:	7f83      	ldrb	r3, [r0, #30]
 80084c2:	075b      	lsls	r3, r3, #29
 80084c4:	d420      	bmi.n	8008508 <tcp_rexmit_fast+0x50>
    LWIP_DEBUGF(TCP_FR_DEBUG,
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
 80084c6:	f7ff ffd0 	bl	800846a <tcp_rexmit>

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
 80084ca:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
 80084ce:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
 80084d2:	4293      	cmp	r3, r2
      pcb->ssthresh = pcb->snd_wnd / 2;
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
 80084d4:	bf96      	itet	ls
 80084d6:	085b      	lsrls	r3, r3, #1
      pcb->ssthresh = pcb->snd_wnd / 2;
 80084d8:	0852      	lsrhi	r2, r2, #1
      pcb->ssthresh = pcb->cwnd / 2;
 80084da:	f8a4 304e 	strhls.w	r3, [r4, #78]	; 0x4e
    }

    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < (2U * pcb->mss)) {
 80084de:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
      pcb->ssthresh = pcb->snd_wnd / 2;
 80084e0:	bf88      	it	hi
 80084e2:	f8a4 204e 	strhhi.w	r2, [r4, #78]	; 0x4e
    if (pcb->ssthresh < (2U * pcb->mss)) {
 80084e6:	005a      	lsls	r2, r3, #1
 80084e8:	f8b4 104e 	ldrh.w	r1, [r4, #78]	; 0x4e
 80084ec:	4291      	cmp	r1, r2
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
    }

    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 80084ee:	4413      	add	r3, r2
      pcb->ssthresh = 2*pcb->mss;
 80084f0:	bf38      	it	cc
 80084f2:	f8a4 204e 	strhcc.w	r2, [r4, #78]	; 0x4e
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 80084f6:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
 80084fa:	4413      	add	r3, r2
 80084fc:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    pcb->flags |= TF_INFR;
 8008500:	7fa3      	ldrb	r3, [r4, #30]
 8008502:	f043 0304 	orr.w	r3, r3, #4
 8008506:	77a3      	strb	r3, [r4, #30]
 8008508:	bd10      	pop	{r4, pc}

0800850a <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
err_t
tcp_keepalive(struct tcp_pcb *pcb)
{
 800850a:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 800850c:	4604      	mov	r4, r0
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
 800850e:	6d00      	ldr	r0, [r0, #80]	; 0x50
 8008510:	3801      	subs	r0, #1
 8008512:	f7fc fb6b 	bl	8004bec <lwip_htonl>
 8008516:	2100      	movs	r1, #0
 8008518:	4602      	mov	r2, r0
 800851a:	4620      	mov	r0, r4
 800851c:	f7ff fba2 	bl	8007c64 <tcp_output_alloc_header.constprop.0>
  if (p == NULL) {
 8008520:	4605      	mov	r5, r0
 8008522:	b1c8      	cbz	r0, 8008558 <tcp_keepalive+0x4e>
    LWIP_DEBUGF(TCP_DEBUG,
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return ERR_MEM;
  }
  netif = ip_route(PCB_ISIPV6(pcb), &pcb->local_ip, &pcb->remote_ip);
 8008524:	1d26      	adds	r6, r4, #4
 8008526:	4630      	mov	r0, r6
 8008528:	f7fc fc30 	bl	8004d8c <ip4_route>
  if (netif == NULL) {
 800852c:	b188      	cbz	r0, 8008552 <tcp_keepalive+0x48>
#endif /* CHECKSUM_GEN_TCP */
    TCP_STATS_INC(tcp.xmit);

    /* Send output to IP */
    NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
    err = ip_output_if(PCB_ISIPV6(pcb), p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 800852e:	2100      	movs	r1, #0
 8008530:	2206      	movs	r2, #6
 8008532:	7aa3      	ldrb	r3, [r4, #10]
 8008534:	9002      	str	r0, [sp, #8]
 8008536:	4628      	mov	r0, r5
 8008538:	e88d 0006 	stmia.w	sp, {r1, r2}
 800853c:	4621      	mov	r1, r4
 800853e:	4632      	mov	r2, r6
 8008540:	f7fc fd5a 	bl	8004ff8 <ip4_output_if>
 8008544:	4604      	mov	r4, r0
      0, IP_PROTO_TCP, netif);
    NETIF_SET_HWADDRHINT(netif, NULL);
  }
  pbuf_free(p);
 8008546:	4628      	mov	r0, r5
 8008548:	f7fd fb55 	bl	8005bf6 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
}
 800854c:	4620      	mov	r0, r4
 800854e:	b004      	add	sp, #16
 8008550:	bd70      	pop	{r4, r5, r6, pc}
    err = ERR_RTE;
 8008552:	f06f 0403 	mvn.w	r4, #3
 8008556:	e7f6      	b.n	8008546 <tcp_keepalive+0x3c>
    return ERR_MEM;
 8008558:	f04f 34ff 	mov.w	r4, #4294967295
 800855c:	e7f6      	b.n	800854c <tcp_keepalive+0x42>

0800855e <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
err_t
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 800855e:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
  LWIP_DEBUGF(TCP_DEBUG,
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
 8008562:	6f04      	ldr	r4, [r0, #112]	; 0x70
{
 8008564:	4606      	mov	r6, r0

  if (seg == NULL) {
 8008566:	b90c      	cbnz	r4, 800856c <tcp_zero_window_probe+0xe>
    seg = pcb->unsent;
 8008568:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
  }
  if (seg == NULL) {
 800856a:	b3b4      	cbz	r4, 80085da <tcp_zero_window_probe+0x7c>
    /* nothing to send, zero window probe not needed */
    return ERR_OK;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 800856c:	68e3      	ldr	r3, [r4, #12]
 800856e:	8998      	ldrh	r0, [r3, #12]
 8008570:	f7fc fb39 	bl	8004be6 <lwip_ntohs>
 8008574:	f010 0501 	ands.w	r5, r0, #1
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 8008578:	68e3      	ldr	r3, [r4, #12]
 800857a:	4630      	mov	r0, r6
  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 800857c:	bf18      	it	ne
 800857e:	8925      	ldrhne	r5, [r4, #8]
  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 8008580:	685a      	ldr	r2, [r3, #4]
  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 8008582:	bf1c      	itt	ne
 8008584:	fab5 f585 	clzne	r5, r5
 8008588:	096d      	lsrne	r5, r5, #5
  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 800858a:	f085 0101 	eor.w	r1, r5, #1
 800858e:	f7ff fb69 	bl	8007c64 <tcp_output_alloc_header.constprop.0>
  if (p == NULL) {
 8008592:	4607      	mov	r7, r0
 8008594:	b398      	cbz	r0, 80085fe <tcp_zero_window_probe+0xa0>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return ERR_MEM;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 8008596:	f8d0 8004 	ldr.w	r8, [r0, #4]

  if (is_fin) {
 800859a:	b315      	cbz	r5, 80085e2 <tcp_zero_window_probe+0x84>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 800859c:	f8b8 400c 	ldrh.w	r4, [r8, #12]
 80085a0:	2011      	movs	r0, #17
 80085a2:	f7fc fb1d 	bl	8004be0 <lwip_htons>
 80085a6:	f424 547c 	bic.w	r4, r4, #16128	; 0x3f00
 80085aa:	b2a4      	uxth	r4, r4
 80085ac:	4320      	orrs	r0, r4
 80085ae:	f8a8 000c 	strh.w	r0, [r8, #12]
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
  }

  netif = ip_route(PCB_ISIPV6(pcb), &pcb->local_ip, &pcb->remote_ip);
 80085b2:	1d34      	adds	r4, r6, #4
 80085b4:	4620      	mov	r0, r4
 80085b6:	f7fc fbe9 	bl	8004d8c <ip4_route>
  if (netif == NULL) {
 80085ba:	b1e8      	cbz	r0, 80085f8 <tcp_zero_window_probe+0x9a>
#endif
    TCP_STATS_INC(tcp.xmit);

    /* Send output to IP */
    NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
    err = ip_output_if(PCB_ISIPV6(pcb), p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 80085bc:	2100      	movs	r1, #0
 80085be:	2206      	movs	r2, #6
 80085c0:	9002      	str	r0, [sp, #8]
 80085c2:	4638      	mov	r0, r7
 80085c4:	7ab3      	ldrb	r3, [r6, #10]
 80085c6:	e88d 0006 	stmia.w	sp, {r1, r2}
 80085ca:	4622      	mov	r2, r4
 80085cc:	4631      	mov	r1, r6
 80085ce:	f7fc fd13 	bl	8004ff8 <ip4_output_if>
 80085d2:	4604      	mov	r4, r0
      0, IP_PROTO_TCP, netif);
    NETIF_SET_HWADDRHINT(netif, NULL);
  }

  pbuf_free(p);
 80085d4:	4638      	mov	r0, r7
 80085d6:	f7fd fb0e 	bl	8005bf6 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
}
 80085da:	4620      	mov	r0, r4
 80085dc:	b004      	add	sp, #16
 80085de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 80085e2:	6860      	ldr	r0, [r4, #4]
 80085e4:	f108 0114 	add.w	r1, r8, #20
 80085e8:	8922      	ldrh	r2, [r4, #8]
 80085ea:	8903      	ldrh	r3, [r0, #8]
 80085ec:	1a9b      	subs	r3, r3, r2
 80085ee:	2201      	movs	r2, #1
 80085f0:	b29b      	uxth	r3, r3
 80085f2:	f7fd fc49 	bl	8005e88 <pbuf_copy_partial>
 80085f6:	e7dc      	b.n	80085b2 <tcp_zero_window_probe+0x54>
    err = ERR_RTE;
 80085f8:	f06f 0403 	mvn.w	r4, #3
 80085fc:	e7ea      	b.n	80085d4 <tcp_zero_window_probe+0x76>
    return ERR_MEM;
 80085fe:	f04f 34ff 	mov.w	r4, #4294967295
 8008602:	e7ea      	b.n	80085da <tcp_zero_window_probe+0x7c>

08008604 <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
 8008604:	4770      	bx	lr
	...

08008608 <udp_input>:
  PERF_START;

  UDP_STATS_INC(udp.recv);

  /* Check minimum length (UDP header) */
  if (p->len < UDP_HLEN) {
 8008608:	8943      	ldrh	r3, [r0, #10]
 800860a:	2b07      	cmp	r3, #7
{
 800860c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008610:	4606      	mov	r6, r0
 8008612:	b085      	sub	sp, #20
 8008614:	4689      	mov	r9, r1
  if (p->len < UDP_HLEN) {
 8008616:	d805      	bhi.n	8008624 <udp_input+0x1c>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    MIB2_STATS_INC(mib2.udpinerrors);
    pbuf_free(p);
 8008618:	4630      	mov	r0, r6
  UDP_STATS_INC(udp.drop);
  MIB2_STATS_INC(mib2.udpinerrors);
  pbuf_free(p);
  PERF_STOP("udp_input");
#endif /* CHECKSUM_CHECK_UDP */
}
 800861a:	b005      	add	sp, #20
 800861c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    pbuf_free(p);
 8008620:	f7fd bae9 	b.w	8005bf6 <pbuf_free>
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
 8008624:	4d39      	ldr	r5, [pc, #228]	; (800870c <udp_input+0x104>)
  udphdr = (struct udp_hdr *)p->payload;
 8008626:	6844      	ldr	r4, [r0, #4]
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
 8008628:	6829      	ldr	r1, [r5, #0]
 800862a:	6968      	ldr	r0, [r5, #20]
 800862c:	f7fc fcf5 	bl	800501a <ip4_addr_isbroadcast_u32>
 8008630:	4607      	mov	r7, r0
  src = ntohs(udphdr->src);
 8008632:	8820      	ldrh	r0, [r4, #0]
 8008634:	f7fc fad7 	bl	8004be6 <lwip_ntohs>
 8008638:	4680      	mov	r8, r0
  dest = ntohs(udphdr->dest);
 800863a:	8860      	ldrh	r0, [r4, #2]
    uncon_pcb = NULL;
 800863c:	2400      	movs	r4, #0
  dest = ntohs(udphdr->dest);
 800863e:	f7fc fad2 	bl	8004be6 <lwip_ntohs>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8008642:	4a33      	ldr	r2, [pc, #204]	; (8008710 <udp_input+0x108>)
              ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 8008644:	692b      	ldr	r3, [r5, #16]
  dest = ntohs(udphdr->dest);
 8008646:	4682      	mov	sl, r0
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8008648:	6810      	ldr	r0, [r2, #0]
    prev = NULL;
 800864a:	46a4      	mov	ip, r4
              ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 800864c:	9303      	str	r3, [sp, #12]
 800864e:	4693      	mov	fp, r2
            ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr()) ||
 8008650:	f8d5 e014 	ldr.w	lr, [r5, #20]
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8008654:	4603      	mov	r3, r0
 8008656:	b92b      	cbnz	r3, 8008664 <udp_input+0x5c>
  if (pcb != NULL) {
 8008658:	bb1c      	cbnz	r4, 80086a2 <udp_input+0x9a>
  if (for_us) {
 800865a:	f8d9 3004 	ldr.w	r3, [r9, #4]
 800865e:	459e      	cmp	lr, r3
 8008660:	d1da      	bne.n	8008618 <udp_input+0x10>
 8008662:	e01e      	b.n	80086a2 <udp_input+0x9a>
      if (pcb->local_port == dest) {
 8008664:	8a5a      	ldrh	r2, [r3, #18]
 8008666:	4552      	cmp	r2, sl
 8008668:	d133      	bne.n	80086d2 <udp_input+0xca>
 800866a:	6819      	ldr	r1, [r3, #0]
        if (
 800866c:	b907      	cbnz	r7, 8008670 <udp_input+0x68>
            ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 800866e:	b149      	cbz	r1, 8008684 <udp_input+0x7c>
 8008670:	4571      	cmp	r1, lr
 8008672:	d007      	beq.n	8008684 <udp_input+0x7c>
            ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr()) ||
 8008674:	b36f      	cbz	r7, 80086d2 <udp_input+0xca>
             (ip_addr_isany(&pcb->local_ip) ||
 8008676:	b129      	cbz	r1, 8008684 <udp_input+0x7c>
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), netif_ip4_netmask(inp))))))
 8008678:	ea81 010e 	eor.w	r1, r1, lr
 800867c:	f8d9 2008 	ldr.w	r2, [r9, #8]
             (ip_addr_isany(&pcb->local_ip) ||
 8008680:	4211      	tst	r1, r2
 8008682:	d126      	bne.n	80086d2 <udp_input+0xca>
          if ((uncon_pcb == NULL) &&
 8008684:	b924      	cbnz	r4, 8008690 <udp_input+0x88>
 8008686:	7c1a      	ldrb	r2, [r3, #16]
 8008688:	f012 0f04 	tst.w	r2, #4
 800868c:	bf08      	it	eq
 800868e:	461c      	moveq	r4, r3
          (pcb->remote_port == src) && IP_PCB_IPVER_INPUT_MATCH(pcb) &&
 8008690:	8a9a      	ldrh	r2, [r3, #20]
 8008692:	4542      	cmp	r2, r8
 8008694:	d11d      	bne.n	80086d2 <udp_input+0xca>
            (ip_addr_isany_val(pcb->remote_ip) ||
 8008696:	685a      	ldr	r2, [r3, #4]
          (pcb->remote_port == src) && IP_PCB_IPVER_INPUT_MATCH(pcb) &&
 8008698:	b9c2      	cbnz	r2, 80086cc <udp_input+0xc4>
        if (prev != NULL) {
 800869a:	f1bc 0f00 	cmp.w	ip, #0
 800869e:	d11b      	bne.n	80086d8 <udp_input+0xd0>
 80086a0:	461c      	mov	r4, r3
    if (pbuf_header(p, -UDP_HLEN)) {
 80086a2:	f06f 0107 	mvn.w	r1, #7
 80086a6:	4630      	mov	r0, r6
 80086a8:	f7fd fa97 	bl	8005bda <pbuf_header>
 80086ac:	2800      	cmp	r0, #0
 80086ae:	d1b3      	bne.n	8008618 <udp_input+0x10>
    if (pcb != NULL) {
 80086b0:	b1cc      	cbz	r4, 80086e6 <udp_input+0xde>
      if (pcb->recv != NULL) {
 80086b2:	69a5      	ldr	r5, [r4, #24]
 80086b4:	2d00      	cmp	r5, #0
 80086b6:	d0af      	beq.n	8008618 <udp_input+0x10>
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 80086b8:	f8cd 8000 	str.w	r8, [sp]
 80086bc:	4632      	mov	r2, r6
 80086be:	4b15      	ldr	r3, [pc, #84]	; (8008714 <udp_input+0x10c>)
 80086c0:	4621      	mov	r1, r4
 80086c2:	69e0      	ldr	r0, [r4, #28]
 80086c4:	47a8      	blx	r5
}
 80086c6:	b005      	add	sp, #20
 80086c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            (ip_addr_isany_val(pcb->remote_ip) ||
 80086cc:	9903      	ldr	r1, [sp, #12]
 80086ce:	428a      	cmp	r2, r1
 80086d0:	d0e3      	beq.n	800869a <udp_input+0x92>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 80086d2:	469c      	mov	ip, r3
 80086d4:	68db      	ldr	r3, [r3, #12]
 80086d6:	e7be      	b.n	8008656 <udp_input+0x4e>
          prev->next = pcb->next;
 80086d8:	68da      	ldr	r2, [r3, #12]
          udp_pcbs = pcb;
 80086da:	f8cb 3000 	str.w	r3, [fp]
          prev->next = pcb->next;
 80086de:	f8cc 200c 	str.w	r2, [ip, #12]
          pcb->next = udp_pcbs;
 80086e2:	60d8      	str	r0, [r3, #12]
 80086e4:	e7dc      	b.n	80086a0 <udp_input+0x98>
      if (
 80086e6:	2f00      	cmp	r7, #0
 80086e8:	d196      	bne.n	8008618 <udp_input+0x10>
          !broadcast && !ip_addr_ismulticast(ip_current_dest_addr())
 80086ea:	696b      	ldr	r3, [r5, #20]
 80086ec:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80086f0:	2be0      	cmp	r3, #224	; 0xe0
 80086f2:	d091      	beq.n	8008618 <udp_input+0x10>
        pbuf_header_force(p, ip_current_header_tot_len() + UDP_HLEN);
 80086f4:	89a9      	ldrh	r1, [r5, #12]
 80086f6:	4630      	mov	r0, r6
 80086f8:	3108      	adds	r1, #8
 80086fa:	b209      	sxth	r1, r1
 80086fc:	f7fd fa74 	bl	8005be8 <pbuf_header_force>
        icmp_port_unreach(ip_current_is_v6(), p);
 8008700:	2103      	movs	r1, #3
 8008702:	4630      	mov	r0, r6
 8008704:	f7fc fb38 	bl	8004d78 <icmp_dest_unreach>
 8008708:	e786      	b.n	8008618 <udp_input+0x10>
 800870a:	bf00      	nop
 800870c:	20003f8c 	.word	0x20003f8c
 8008710:	20007680 	.word	0x20007680
 8008714:	20003f9c 	.word	0x20003f9c

08008718 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
 8008718:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  struct udp_pcb *ipcb;
  u8_t rebind;

  if ((pcb == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, ipaddr)) {
 800871c:	2800      	cmp	r0, #0
 800871e:	d04c      	beq.n	80087ba <udp_bind+0xa2>
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8008720:	4e28      	ldr	r6, [pc, #160]	; (80087c4 <udp_bind+0xac>)
 8008722:	6837      	ldr	r7, [r6, #0]
 8008724:	463d      	mov	r5, r7
 8008726:	b9bd      	cbnz	r5, 8008758 <udp_bind+0x40>
      break;
    }
  }

  /* no port specified? */
  if (port == 0) {
 8008728:	b1e2      	cbz	r2, 8008764 <udp_bind+0x4c>
 800872a:	463b      	mov	r3, r7
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  } else {
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 800872c:	b35b      	cbz	r3, 8008786 <udp_bind+0x6e>
      if (pcb != ipcb) {
 800872e:	4283      	cmp	r3, r0
 8008730:	d010      	beq.n	8008754 <udp_bind+0x3c>
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
            !ip_get_option(ipcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          /* port matches that of PCB in list and REUSEADDR not set -> reject */
          if ((ipcb->local_port == port) && IP_PCB_IPVER_EQ(pcb, ipcb) &&
 8008732:	8a5c      	ldrh	r4, [r3, #18]
 8008734:	4294      	cmp	r4, r2
 8008736:	d10d      	bne.n	8008754 <udp_bind+0x3c>
 8008738:	2b00      	cmp	r3, #0
 800873a:	d037      	beq.n	80087ac <udp_bind+0x94>
              /* IP address matches, or one is IP_ADDR_ANY? */
                (ip_addr_isany(&ipcb->local_ip) ||
 800873c:	f8d3 e000 	ldr.w	lr, [r3]
 8008740:	f1be 0f00 	cmp.w	lr, #0
 8008744:	d032      	beq.n	80087ac <udp_bind+0x94>
 8008746:	2900      	cmp	r1, #0
 8008748:	d030      	beq.n	80087ac <udp_bind+0x94>
                 ip_addr_isany(ipaddr) ||
 800874a:	680c      	ldr	r4, [r1, #0]
 800874c:	2c00      	cmp	r4, #0
 800874e:	d02d      	beq.n	80087ac <udp_bind+0x94>
 8008750:	45a6      	cmp	lr, r4
 8008752:	d02b      	beq.n	80087ac <udp_bind+0x94>
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8008754:	68db      	ldr	r3, [r3, #12]
 8008756:	e7e9      	b.n	800872c <udp_bind+0x14>
    if (pcb == ipcb) {
 8008758:	4285      	cmp	r5, r0
 800875a:	d001      	beq.n	8008760 <udp_bind+0x48>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 800875c:	68ed      	ldr	r5, [r5, #12]
 800875e:	e7e2      	b.n	8008726 <udp_bind+0xe>
      rebind = 1;
 8008760:	2501      	movs	r5, #1
 8008762:	e7e1      	b.n	8008728 <udp_bind+0x10>
 8008764:	4b18      	ldr	r3, [pc, #96]	; (80087c8 <udp_bind+0xb0>)
  if (port == 0) {
 8008766:	f44f 4480 	mov.w	r4, #16384	; 0x4000
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 800876a:	f64f 7cff 	movw	ip, #65535	; 0xffff
 800876e:	881a      	ldrh	r2, [r3, #0]
 8008770:	4562      	cmp	r2, ip
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8008772:	46be      	mov	lr, r7
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 8008774:	bf16      	itet	ne
 8008776:	3201      	addne	r2, #1
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 8008778:	f44f 4240 	moveq.w	r2, #49152	; 0xc000
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 800877c:	b292      	uxthne	r2, r2
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 800877e:	f1be 0f00 	cmp.w	lr, #0
 8008782:	d10a      	bne.n	800879a <udp_bind+0x82>
 8008784:	801a      	strh	r2, [r3, #0]
        }
      }
    }
  }

  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
 8008786:	b101      	cbz	r1, 800878a <udp_bind+0x72>
 8008788:	6809      	ldr	r1, [r1, #0]
 800878a:	6001      	str	r1, [r0, #0]

  pcb->local_port = port;
 800878c:	8242      	strh	r2, [r0, #18]
  mib2_udp_bind(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 800878e:	b90d      	cbnz	r5, 8008794 <udp_bind+0x7c>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 8008790:	60c7      	str	r7, [r0, #12]
    udp_pcbs = pcb;
 8008792:	6030      	str	r0, [r6, #0]
  }
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_bind: bound to "));
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, &pcb->local_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->local_port));
  return ERR_OK;
 8008794:	2000      	movs	r0, #0
}
 8008796:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (pcb->local_port == udp_port) {
 800879a:	f8be 8012 	ldrh.w	r8, [lr, #18]
 800879e:	4590      	cmp	r8, r2
 80087a0:	d108      	bne.n	80087b4 <udp_bind+0x9c>
 80087a2:	3c01      	subs	r4, #1
 80087a4:	b2a4      	uxth	r4, r4
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 80087a6:	2c00      	cmp	r4, #0
 80087a8:	d1e2      	bne.n	8008770 <udp_bind+0x58>
 80087aa:	801a      	strh	r2, [r3, #0]
      return ERR_USE;
 80087ac:	f06f 0007 	mvn.w	r0, #7
 80087b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 80087b4:	f8de e00c 	ldr.w	lr, [lr, #12]
 80087b8:	e7e1      	b.n	800877e <udp_bind+0x66>
    return ERR_VAL;
 80087ba:	f06f 0005 	mvn.w	r0, #5
 80087be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80087c2:	bf00      	nop
 80087c4:	20007680 	.word	0x20007680
 80087c8:	20000044 	.word	0x20000044

080087cc <udp_sendto_if_src>:
{
 80087cc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80087d0:	460e      	mov	r6, r1
 80087d2:	b085      	sub	sp, #20
 80087d4:	4690      	mov	r8, r2
 80087d6:	4699      	mov	r9, r3
  if ((pcb == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, src_ip) ||
 80087d8:	4607      	mov	r7, r0
 80087da:	2800      	cmp	r0, #0
 80087dc:	d042      	beq.n	8008864 <udp_sendto_if_src+0x98>
  if (pcb->local_port == 0) {
 80087de:	8a42      	ldrh	r2, [r0, #18]
 80087e0:	b342      	cbz	r2, 8008834 <udp_sendto_if_src+0x68>
  if (pbuf_header(p, UDP_HLEN)) {
 80087e2:	2108      	movs	r1, #8
 80087e4:	4630      	mov	r0, r6
 80087e6:	f7fd f9f8 	bl	8005bda <pbuf_header>
 80087ea:	bb68      	cbnz	r0, 8008848 <udp_sendto_if_src+0x7c>
 80087ec:	4634      	mov	r4, r6
  udphdr = (struct udp_hdr *)q->payload;
 80087ee:	6865      	ldr	r5, [r4, #4]
  udphdr->src = htons(pcb->local_port);
 80087f0:	8a78      	ldrh	r0, [r7, #18]
 80087f2:	f7fc f9f5 	bl	8004be0 <lwip_htons>
 80087f6:	8028      	strh	r0, [r5, #0]
  udphdr->dest = htons(dst_port);
 80087f8:	4648      	mov	r0, r9
 80087fa:	f7fc f9f1 	bl	8004be0 <lwip_htons>
  udphdr->chksum = 0x0000;
 80087fe:	2300      	movs	r3, #0
  udphdr->dest = htons(dst_port);
 8008800:	8068      	strh	r0, [r5, #2]
  udphdr->chksum = 0x0000;
 8008802:	71ab      	strb	r3, [r5, #6]
 8008804:	71eb      	strb	r3, [r5, #7]
    udphdr->len = htons(q->tot_len);
 8008806:	8920      	ldrh	r0, [r4, #8]
 8008808:	f7fc f9ea 	bl	8004be0 <lwip_htons>
  err = ip_output_if_src(PCB_ISIPV6(pcb), q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 800880c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    udphdr->len = htons(q->tot_len);
 800880e:	80a8      	strh	r0, [r5, #4]
  err = ip_output_if_src(PCB_ISIPV6(pcb), q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 8008810:	4620      	mov	r0, r4
 8008812:	7abb      	ldrb	r3, [r7, #10]
 8008814:	9202      	str	r2, [sp, #8]
 8008816:	2211      	movs	r2, #17
 8008818:	990d      	ldr	r1, [sp, #52]	; 0x34
 800881a:	9201      	str	r2, [sp, #4]
 800881c:	7a7a      	ldrb	r2, [r7, #9]
 800881e:	9200      	str	r2, [sp, #0]
 8008820:	4642      	mov	r2, r8
 8008822:	f7fc fb8d 	bl	8004f40 <ip4_output_if_src>
  if (q != p) {
 8008826:	42b4      	cmp	r4, r6
  err = ip_output_if_src(PCB_ISIPV6(pcb), q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 8008828:	4605      	mov	r5, r0
  if (q != p) {
 800882a:	d009      	beq.n	8008840 <udp_sendto_if_src+0x74>
    pbuf_free(q);
 800882c:	4620      	mov	r0, r4
 800882e:	f7fd f9e2 	bl	8005bf6 <pbuf_free>
 8008832:	e005      	b.n	8008840 <udp_sendto_if_src+0x74>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 8008834:	4601      	mov	r1, r0
 8008836:	f7ff ff6f 	bl	8008718 <udp_bind>
    if (err != ERR_OK) {
 800883a:	4605      	mov	r5, r0
 800883c:	2800      	cmp	r0, #0
 800883e:	d0d0      	beq.n	80087e2 <udp_sendto_if_src+0x16>
}
 8008840:	4628      	mov	r0, r5
 8008842:	b005      	add	sp, #20
 8008844:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 8008848:	2200      	movs	r2, #0
 800884a:	2108      	movs	r1, #8
 800884c:	2001      	movs	r0, #1
 800884e:	f7fd f9f9 	bl	8005c44 <pbuf_alloc>
    if (q == NULL) {
 8008852:	4604      	mov	r4, r0
 8008854:	b148      	cbz	r0, 800886a <udp_sendto_if_src+0x9e>
    if (p->tot_len != 0) {
 8008856:	8933      	ldrh	r3, [r6, #8]
 8008858:	2b00      	cmp	r3, #0
 800885a:	d0c8      	beq.n	80087ee <udp_sendto_if_src+0x22>
      pbuf_chain(q, p);
 800885c:	4631      	mov	r1, r6
 800885e:	f7fd fabd 	bl	8005ddc <pbuf_chain>
 8008862:	e7c4      	b.n	80087ee <udp_sendto_if_src+0x22>
    return ERR_VAL;
 8008864:	f06f 0505 	mvn.w	r5, #5
 8008868:	e7ea      	b.n	8008840 <udp_sendto_if_src+0x74>
      return ERR_MEM;
 800886a:	f04f 35ff 	mov.w	r5, #4294967295
 800886e:	e7e7      	b.n	8008840 <udp_sendto_if_src+0x74>

08008870 <udp_sendto_if>:
{
 8008870:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8008872:	9c06      	ldr	r4, [sp, #24]
  if ((pcb == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
 8008874:	b168      	cbz	r0, 8008892 <udp_sendto_if+0x22>
  if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip))) {
 8008876:	6805      	ldr	r5, [r0, #0]
 8008878:	b935      	cbnz	r5, 8008888 <udp_sendto_if+0x18>
    src_ip = netif_ip_addr4(netif);
 800887a:	1d25      	adds	r5, r4, #4
  return udp_sendto_if_src(pcb, p, dst_ip, dst_port, netif, src_ip);
 800887c:	e88d 0030 	stmia.w	sp, {r4, r5}
 8008880:	f7ff ffa4 	bl	80087cc <udp_sendto_if_src>
}
 8008884:	b002      	add	sp, #8
 8008886:	bd70      	pop	{r4, r5, r6, pc}
    if (!ip4_addr_cmp(ip_2_ip4(&(pcb->local_ip)), netif_ip4_addr(netif))) {
 8008888:	6866      	ldr	r6, [r4, #4]
 800888a:	42b5      	cmp	r5, r6
 800888c:	d101      	bne.n	8008892 <udp_sendto_if+0x22>
  if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip))) {
 800888e:	4605      	mov	r5, r0
 8008890:	e7f4      	b.n	800887c <udp_sendto_if+0xc>
    return ERR_VAL;
 8008892:	f06f 0005 	mvn.w	r0, #5
 8008896:	e7f5      	b.n	8008884 <udp_sendto_if+0x14>

08008898 <udp_sendto>:
{
 8008898:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800889a:	460e      	mov	r6, r1
 800889c:	4615      	mov	r5, r2
 800889e:	461f      	mov	r7, r3
  if ((pcb == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
 80088a0:	4604      	mov	r4, r0
 80088a2:	b160      	cbz	r0, 80088be <udp_sendto+0x26>
  netif = ip_route(PCB_ISIPV6(pcb), &pcb->local_ip, dst_ip_route);
 80088a4:	4610      	mov	r0, r2
 80088a6:	f7fc fa71 	bl	8004d8c <ip4_route>
  if (netif == NULL) {
 80088aa:	b158      	cbz	r0, 80088c4 <udp_sendto+0x2c>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
 80088ac:	9000      	str	r0, [sp, #0]
 80088ae:	463b      	mov	r3, r7
 80088b0:	462a      	mov	r2, r5
 80088b2:	4631      	mov	r1, r6
 80088b4:	4620      	mov	r0, r4
 80088b6:	f7ff ffdb 	bl	8008870 <udp_sendto_if>
}
 80088ba:	b003      	add	sp, #12
 80088bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return ERR_VAL;
 80088be:	f06f 0005 	mvn.w	r0, #5
 80088c2:	e7fa      	b.n	80088ba <udp_sendto+0x22>
    return ERR_RTE;
 80088c4:	f06f 0003 	mvn.w	r0, #3
 80088c8:	e7f7      	b.n	80088ba <udp_sendto+0x22>

080088ca <udp_send>:
{
 80088ca:	4602      	mov	r2, r0
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
 80088cc:	8a83      	ldrh	r3, [r0, #20]
 80088ce:	3204      	adds	r2, #4
 80088d0:	f7ff bfe2 	b.w	8008898 <udp_sendto>

080088d4 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
 80088d4:	b570      	push	{r4, r5, r6, lr}
 80088d6:	460d      	mov	r5, r1
 80088d8:	4616      	mov	r6, r2
  struct udp_pcb *ipcb;

  if ((pcb == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, ipaddr)) {
 80088da:	4604      	mov	r4, r0
 80088dc:	b1d8      	cbz	r0, 8008916 <udp_connect+0x42>
    return ERR_VAL;
  }

  if (pcb->local_port == 0) {
 80088de:	8a42      	ldrh	r2, [r0, #18]
 80088e0:	b16a      	cbz	r2, 80088fe <udp_connect+0x2a>
    if (err != ERR_OK) {
      return err;
    }
  }

  ip_addr_set_ipaddr(&pcb->remote_ip, ipaddr);
 80088e2:	b995      	cbnz	r5, 800890a <udp_connect+0x36>
  pcb->remote_port = port;
  pcb->flags |= UDP_FLAGS_CONNECTED;
 80088e4:	7c23      	ldrb	r3, [r4, #16]
  ip_addr_set_ipaddr(&pcb->remote_ip, ipaddr);
 80088e6:	6065      	str	r5, [r4, #4]
  pcb->flags |= UDP_FLAGS_CONNECTED;
 80088e8:	f043 0304 	orr.w	r3, r3, #4
  pcb->remote_port = port;
 80088ec:	82a6      	strh	r6, [r4, #20]
  pcb->flags |= UDP_FLAGS_CONNECTED;
 80088ee:	7423      	strb	r3, [r4, #16]
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                      &pcb->remote_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 80088f0:	4b0b      	ldr	r3, [pc, #44]	; (8008920 <udp_connect+0x4c>)
 80088f2:	681a      	ldr	r2, [r3, #0]
 80088f4:	4610      	mov	r0, r2
 80088f6:	b950      	cbnz	r0, 800890e <udp_connect+0x3a>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
 80088f8:	60e2      	str	r2, [r4, #12]
  udp_pcbs = pcb;
 80088fa:	601c      	str	r4, [r3, #0]
  return ERR_OK;
 80088fc:	bd70      	pop	{r4, r5, r6, pc}
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 80088fe:	4601      	mov	r1, r0
 8008900:	f7ff ff0a 	bl	8008718 <udp_bind>
    if (err != ERR_OK) {
 8008904:	2800      	cmp	r0, #0
 8008906:	d0ec      	beq.n	80088e2 <udp_connect+0xe>
 8008908:	bd70      	pop	{r4, r5, r6, pc}
  ip_addr_set_ipaddr(&pcb->remote_ip, ipaddr);
 800890a:	682d      	ldr	r5, [r5, #0]
 800890c:	e7ea      	b.n	80088e4 <udp_connect+0x10>
    if (pcb == ipcb) {
 800890e:	42a0      	cmp	r0, r4
 8008910:	d004      	beq.n	800891c <udp_connect+0x48>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8008912:	68c0      	ldr	r0, [r0, #12]
 8008914:	e7ef      	b.n	80088f6 <udp_connect+0x22>
    return ERR_VAL;
 8008916:	f06f 0005 	mvn.w	r0, #5
 800891a:	bd70      	pop	{r4, r5, r6, pc}
      return ERR_OK;
 800891c:	2000      	movs	r0, #0
}
 800891e:	bd70      	pop	{r4, r5, r6, pc}
 8008920:	20007680 	.word	0x20007680

08008924 <udp_recv>:
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
  /* remember recv() callback and user data */
  pcb->recv = recv;
 8008924:	6181      	str	r1, [r0, #24]
  pcb->recv_arg = recv_arg;
 8008926:	61c2      	str	r2, [r0, #28]
 8008928:	4770      	bx	lr
	...

0800892c <udp_remove>:
{
  struct udp_pcb *pcb2;

  mib2_udp_unbind(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 800892c:	4a0a      	ldr	r2, [pc, #40]	; (8008958 <udp_remove+0x2c>)
{
 800892e:	4601      	mov	r1, r0
  if (udp_pcbs == pcb) {
 8008930:	6813      	ldr	r3, [r2, #0]
 8008932:	4283      	cmp	r3, r0
 8008934:	d104      	bne.n	8008940 <udp_remove+0x14>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 8008936:	68c3      	ldr	r3, [r0, #12]
 8008938:	6013      	str	r3, [r2, #0]
        pcb2->next = pcb->next;
        break;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 800893a:	2000      	movs	r0, #0
 800893c:	f7fd b840 	b.w	80059c0 <memp_free>
{
 8008940:	461a      	mov	r2, r3
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 8008942:	2b00      	cmp	r3, #0
 8008944:	d0f9      	beq.n	800893a <udp_remove+0xe>
      if (pcb2->next != NULL && pcb2->next == pcb) {
 8008946:	68db      	ldr	r3, [r3, #12]
 8008948:	2b00      	cmp	r3, #0
 800894a:	d0f6      	beq.n	800893a <udp_remove+0xe>
 800894c:	4299      	cmp	r1, r3
 800894e:	d1f7      	bne.n	8008940 <udp_remove+0x14>
        pcb2->next = pcb->next;
 8008950:	68cb      	ldr	r3, [r1, #12]
 8008952:	60d3      	str	r3, [r2, #12]
        break;
 8008954:	e7f1      	b.n	800893a <udp_remove+0xe>
 8008956:	bf00      	nop
 8008958:	20007680 	.word	0x20007680

0800895c <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 800895c:	b510      	push	{r4, lr}
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 800895e:	2000      	movs	r0, #0
 8008960:	f7fd f822 	bl	80059a8 <memp_malloc>
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 8008964:	4604      	mov	r4, r0
 8008966:	b128      	cbz	r0, 8008974 <udp_new+0x18>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 8008968:	2220      	movs	r2, #32
 800896a:	2100      	movs	r1, #0
 800896c:	f001 f954 	bl	8009c18 <memset>
    pcb->ttl = UDP_TTL;
 8008970:	23ff      	movs	r3, #255	; 0xff
 8008972:	72a3      	strb	r3, [r4, #10]
#if LWIP_MULTICAST_TX_OPTIONS
    pcb->mcast_ttl = UDP_TTL;
#endif /* LWIP_MULTICAST_TX_OPTIONS */
  }
  return pcb;
}
 8008974:	4620      	mov	r0, r4
 8008976:	bd10      	pop	{r4, pc}

08008978 <udp_netif_ipv4_addr_changed>:
 *
 * @param old_addr IPv4 address of the netif before change
 * @param new_addr IPv4 address of the netif after change
 */
void udp_netif_ipv4_addr_changed(const ip4_addr_t* old_addr, const ip4_addr_t* new_addr)
{
 8008978:	b510      	push	{r4, lr}
  struct udp_pcb* upcb;

  if (!ip4_addr_isany(new_addr)) {
 800897a:	b121      	cbz	r1, 8008986 <udp_netif_ipv4_addr_changed+0xe>
 800897c:	680b      	ldr	r3, [r1, #0]
 800897e:	b113      	cbz	r3, 8008986 <udp_netif_ipv4_addr_changed+0xe>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 8008980:	4b06      	ldr	r3, [pc, #24]	; (800899c <udp_netif_ipv4_addr_changed+0x24>)
 8008982:	681b      	ldr	r3, [r3, #0]
 8008984:	b903      	cbnz	r3, 8008988 <udp_netif_ipv4_addr_changed+0x10>
 8008986:	bd10      	pop	{r4, pc}
      /* Is this an IPv4 pcb? */
      if (!IP_IS_V6_VAL(upcb->local_ip)) {
        /* PCB bound to current local interface address? */
        if (!ip4_addr_isany(ip_2_ip4(&upcb->local_ip)) &&
 8008988:	681a      	ldr	r2, [r3, #0]
 800898a:	b122      	cbz	r2, 8008996 <udp_netif_ipv4_addr_changed+0x1e>
 800898c:	6804      	ldr	r4, [r0, #0]
 800898e:	42a2      	cmp	r2, r4
            ip4_addr_cmp(ip_2_ip4(&upcb->local_ip), old_addr)) {
          /* The PCB is bound to the old ipaddr and
            * is set to bound to the new one instead */
          ip_addr_copy_from_ip4(upcb->local_ip, *new_addr);
 8008990:	bf04      	itt	eq
 8008992:	680a      	ldreq	r2, [r1, #0]
 8008994:	601a      	streq	r2, [r3, #0]
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 8008996:	68db      	ldr	r3, [r3, #12]
 8008998:	e7f4      	b.n	8008984 <udp_netif_ipv4_addr_changed+0xc>
 800899a:	bf00      	nop
 800899c:	20007680 	.word	0x20007680

080089a0 <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
 80089a0:	b570      	push	{r4, r5, r6, lr}
  /* remove from SNMP ARP index tree */
  mib2_remove_arp_entry(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 80089a2:	2618      	movs	r6, #24
 80089a4:	4c07      	ldr	r4, [pc, #28]	; (80089c4 <etharp_free_entry+0x24>)
{
 80089a6:	4605      	mov	r5, r0
  if (arp_table[i].q != NULL) {
 80089a8:	4346      	muls	r6, r0
 80089aa:	59a0      	ldr	r0, [r4, r6]
 80089ac:	b118      	cbz	r0, 80089b6 <etharp_free_entry+0x16>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 80089ae:	f7fd f922 	bl	8005bf6 <pbuf_free>
    arp_table[i].q = NULL;
 80089b2:	2300      	movs	r3, #0
 80089b4:	51a3      	str	r3, [r4, r6]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 80089b6:	2318      	movs	r3, #24
 80089b8:	fb03 4405 	mla	r4, r3, r5, r4
 80089bc:	2300      	movs	r3, #0
 80089be:	7523      	strb	r3, [r4, #20]
 80089c0:	bd70      	pop	{r4, r5, r6, pc}
 80089c2:	bf00      	nop
 80089c4:	20003e48 	.word	0x20003e48

080089c8 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, const struct eth_addr *dst)
{
 80089c8:	b430      	push	{r4, r5}
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
 80089ca:	684c      	ldr	r4, [r1, #4]
  if (!LWIP_HOOK_VLAN_SET(netif, ethhdr, vlanhdr)) {
    /* packet shall not contain VLAN header, so hide it and set correct ethertype */
    pbuf_header(p, -SIZEOF_VLAN_HDR);
    ethhdr = (struct eth_hdr *)p->payload;
#endif /* ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET) */
    ethhdr->type = PP_HTONS(ETHTYPE_IP);
 80089cc:	2508      	movs	r5, #8
 80089ce:	7325      	strb	r5, [r4, #12]
 80089d0:	2500      	movs	r5, #0
 80089d2:	7365      	strb	r5, [r4, #13]
#if ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET)
  }
#endif /* ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET) */
  ETHADDR32_COPY(&ethhdr->dest, dst);
 80089d4:	681d      	ldr	r5, [r3, #0]
 80089d6:	6025      	str	r5, [r4, #0]
 80089d8:	889b      	ldrh	r3, [r3, #4]
 80089da:	80a3      	strh	r3, [r4, #4]
  ETHADDR16_COPY(&ethhdr->src, src);
 80089dc:	6813      	ldr	r3, [r2, #0]
 80089de:	f8c4 3006 	str.w	r3, [r4, #6]
 80089e2:	8893      	ldrh	r3, [r2, #4]
 80089e4:	8163      	strh	r3, [r4, #10]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 80089e6:	6983      	ldr	r3, [r0, #24]
}
 80089e8:	bc30      	pop	{r4, r5}
  return netif->linkoutput(netif, p);
 80089ea:	4718      	bx	r3

080089ec <etharp_find_entry.isra.0>:
etharp_find_entry(const ip4_addr_t *ipaddr, u8_t flags, struct netif* netif)
 80089ec:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80089f0:	4b30      	ldr	r3, [pc, #192]	; (8008ab4 <etharp_find_entry.isra.0+0xc8>)
  s8_t old_queue = ARP_TABLE_SIZE;
 80089f2:	220a      	movs	r2, #10
etharp_find_entry(const ip4_addr_t *ipaddr, u8_t flags, struct netif* netif)
 80089f4:	4605      	mov	r5, r0
 80089f6:	2000      	movs	r0, #0
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 80089f8:	4616      	mov	r6, r2
 80089fa:	4696      	mov	lr, r2
  u16_t age_queue = 0, age_pending = 0, age_stable = 0;
 80089fc:	4681      	mov	r9, r0
 80089fe:	4684      	mov	ip, r0
 8008a00:	4683      	mov	fp, r0
  s8_t empty = ARP_TABLE_SIZE;
 8008a02:	4614      	mov	r4, r2
 8008a04:	4698      	mov	r8, r3
etharp_find_entry(const ip4_addr_t *ipaddr, u8_t flags, struct netif* netif)
 8008a06:	9101      	str	r1, [sp, #4]
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8008a08:	2c0a      	cmp	r4, #10
    u8_t state = arp_table[i].state;
 8008a0a:	7d1f      	ldrb	r7, [r3, #20]
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8008a0c:	d10f      	bne.n	8008a2e <etharp_find_entry.isra.0+0x42>
 8008a0e:	b987      	cbnz	r7, 8008a32 <etharp_find_entry.isra.0+0x46>
      empty = i;
 8008a10:	b244      	sxtb	r4, r0
 8008a12:	3001      	adds	r0, #1
 8008a14:	3318      	adds	r3, #24
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8008a16:	280a      	cmp	r0, #10
 8008a18:	d1f6      	bne.n	8008a08 <etharp_find_entry.isra.0+0x1c>
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 8008a1a:	9b01      	ldr	r3, [sp, #4]
 8008a1c:	0799      	lsls	r1, r3, #30
 8008a1e:	d403      	bmi.n	8008a28 <etharp_find_entry.isra.0+0x3c>
 8008a20:	2c0a      	cmp	r4, #10
 8008a22:	d11b      	bne.n	8008a5c <etharp_find_entry.isra.0+0x70>
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 8008a24:	07db      	lsls	r3, r3, #31
 8008a26:	d428      	bmi.n	8008a7a <etharp_find_entry.isra.0+0x8e>
    return (s8_t)ERR_MEM;
 8008a28:	f04f 30ff 	mov.w	r0, #4294967295
 8008a2c:	e008      	b.n	8008a40 <etharp_find_entry.isra.0+0x54>
    } else if (state != ETHARP_STATE_EMPTY) {
 8008a2e:	2f00      	cmp	r7, #0
 8008a30:	d0ef      	beq.n	8008a12 <etharp_find_entry.isra.0+0x26>
      if (ipaddr && ip4_addr_cmp(ipaddr, &arp_table[i].ipaddr)
 8008a32:	b39d      	cbz	r5, 8008a9c <etharp_find_entry.isra.0+0xb0>
 8008a34:	6829      	ldr	r1, [r5, #0]
 8008a36:	468a      	mov	sl, r1
 8008a38:	6859      	ldr	r1, [r3, #4]
 8008a3a:	458a      	cmp	sl, r1
 8008a3c:	d12e      	bne.n	8008a9c <etharp_find_entry.isra.0+0xb0>
        return i;
 8008a3e:	b240      	sxtb	r0, r0
}
 8008a40:	b003      	add	sp, #12
 8008a42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          if (arp_table[i].ctime >= age_pending) {
 8008a46:	45e2      	cmp	sl, ip
 8008a48:	d3e3      	bcc.n	8008a12 <etharp_find_entry.isra.0+0x26>
            old_pending = i;
 8008a4a:	b246      	sxtb	r6, r0
 8008a4c:	46d4      	mov	ip, sl
 8008a4e:	e7e0      	b.n	8008a12 <etharp_find_entry.isra.0+0x26>
          if (arp_table[i].ctime >= age_stable) {
 8008a50:	45ca      	cmp	sl, r9
            old_stable = i;
 8008a52:	bf24      	itt	cs
 8008a54:	fa4f fe80 	sxtbcs.w	lr, r0
 8008a58:	46d1      	movcs	r9, sl
 8008a5a:	e7da      	b.n	8008a12 <etharp_find_entry.isra.0+0x26>
    i = empty;
 8008a5c:	b2e4      	uxtb	r4, r4
  if (ipaddr != NULL) {
 8008a5e:	b125      	cbz	r5, 8008a6a <etharp_find_entry.isra.0+0x7e>
    ip4_addr_copy(arp_table[i].ipaddr, *ipaddr);
 8008a60:	2318      	movs	r3, #24
 8008a62:	682a      	ldr	r2, [r5, #0]
 8008a64:	fb03 8304 	mla	r3, r3, r4, r8
 8008a68:	605a      	str	r2, [r3, #4]
  arp_table[i].ctime = 0;
 8008a6a:	2318      	movs	r3, #24
  return (err_t)i;
 8008a6c:	b260      	sxtb	r0, r4
  arp_table[i].ctime = 0;
 8008a6e:	fb03 8804 	mla	r8, r3, r4, r8
 8008a72:	2300      	movs	r3, #0
 8008a74:	f8a8 3012 	strh.w	r3, [r8, #18]
 8008a78:	e7e2      	b.n	8008a40 <etharp_find_entry.isra.0+0x54>
    if (old_stable < ARP_TABLE_SIZE) {
 8008a7a:	f1be 0f0a 	cmp.w	lr, #10
 8008a7e:	d005      	beq.n	8008a8c <etharp_find_entry.isra.0+0xa0>
      i = old_stable;
 8008a80:	fa5f f48e 	uxtb.w	r4, lr
    etharp_free_entry(i);
 8008a84:	4620      	mov	r0, r4
 8008a86:	f7ff ff8b 	bl	80089a0 <etharp_free_entry>
 8008a8a:	e7e8      	b.n	8008a5e <etharp_find_entry.isra.0+0x72>
    } else if (old_pending < ARP_TABLE_SIZE) {
 8008a8c:	2e0a      	cmp	r6, #10
 8008a8e:	d001      	beq.n	8008a94 <etharp_find_entry.isra.0+0xa8>
      i = old_pending;
 8008a90:	b2f4      	uxtb	r4, r6
 8008a92:	e7f7      	b.n	8008a84 <etharp_find_entry.isra.0+0x98>
    } else if (old_queue < ARP_TABLE_SIZE) {
 8008a94:	2a0a      	cmp	r2, #10
 8008a96:	d0c7      	beq.n	8008a28 <etharp_find_entry.isra.0+0x3c>
      i = old_queue;
 8008a98:	b2d4      	uxtb	r4, r2
 8008a9a:	e7f3      	b.n	8008a84 <etharp_find_entry.isra.0+0x98>
      if (state == ETHARP_STATE_PENDING) {
 8008a9c:	2f01      	cmp	r7, #1
 8008a9e:	f8b3 a012 	ldrh.w	sl, [r3, #18]
 8008aa2:	d1d5      	bne.n	8008a50 <etharp_find_entry.isra.0+0x64>
        if (arp_table[i].q != NULL) {
 8008aa4:	681f      	ldr	r7, [r3, #0]
 8008aa6:	2f00      	cmp	r7, #0
 8008aa8:	d0cd      	beq.n	8008a46 <etharp_find_entry.isra.0+0x5a>
          if (arp_table[i].ctime >= age_queue) {
 8008aaa:	45da      	cmp	sl, fp
 8008aac:	d3b1      	bcc.n	8008a12 <etharp_find_entry.isra.0+0x26>
            old_queue = i;
 8008aae:	b242      	sxtb	r2, r0
 8008ab0:	46d3      	mov	fp, sl
 8008ab2:	e7ae      	b.n	8008a12 <etharp_find_entry.isra.0+0x26>
 8008ab4:	20003e48 	.word	0x20003e48

08008ab8 <etharp_raw.constprop.1>:
 */
#if !LWIP_AUTOIP
static
#endif /* LWIP_AUTOIP */
err_t
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
 8008ab8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008abc:	4606      	mov	r6, r0
 8008abe:	460f      	mov	r7, r1
 8008ac0:	4690      	mov	r8, r2
#endif /* LWIP_AUTOIP */

  LWIP_ASSERT("netif != NULL", netif != NULL);

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW_TX, SIZEOF_ETHARP_PACKET_TX, PBUF_RAM);
 8008ac2:	212a      	movs	r1, #42	; 0x2a
 8008ac4:	2200      	movs	r2, #0
 8008ac6:	2003      	movs	r0, #3
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
 8008ac8:	4699      	mov	r9, r3
  p = pbuf_alloc(PBUF_RAW_TX, SIZEOF_ETHARP_PACKET_TX, PBUF_RAM);
 8008aca:	f7fd f8bb 	bl	8005c44 <pbuf_alloc>
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
 8008ace:	4605      	mov	r5, r0
 8008ad0:	2800      	cmp	r0, #0
 8008ad2:	d03a      	beq.n	8008b4a <etharp_raw.constprop.1+0x92>
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
              (p->len >= SIZEOF_ETHARP_PACKET_TX));

  ethhdr = (struct eth_hdr *)p->payload;
 8008ad4:	6844      	ldr	r4, [r0, #4]
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
#else /* ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET) */
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
#endif /* ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET) */
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
 8008ad6:	2001      	movs	r0, #1
 8008ad8:	f7fc f882 	bl	8004be0 <lwip_htons>

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
  hdr->proto = PP_HTONS(ETHTYPE_IP);
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip4_addr_t);
 8008adc:	2104      	movs	r1, #4
  hdr->opcode = htons(opcode);
 8008ade:	82a0      	strh	r0, [r4, #20]
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);

  /* send ARP query */
  result = netif->linkoutput(netif, p);
 8008ae0:	4630      	mov	r0, r6
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 8008ae2:	f8d9 3000 	ldr.w	r3, [r9]
 8008ae6:	f8c4 3016 	str.w	r3, [r4, #22]
 8008aea:	f8b9 3004 	ldrh.w	r3, [r9, #4]
 8008aee:	8363      	strh	r3, [r4, #26]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 8008af0:	4b17      	ldr	r3, [pc, #92]	; (8008b50 <etharp_raw.constprop.1+0x98>)
 8008af2:	681a      	ldr	r2, [r3, #0]
 8008af4:	889b      	ldrh	r3, [r3, #4]
 8008af6:	6222      	str	r2, [r4, #32]
  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 8008af8:	2201      	movs	r2, #1
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 8008afa:	84a3      	strh	r3, [r4, #36]	; 0x24
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
 8008afc:	9b08      	ldr	r3, [sp, #32]
 8008afe:	681b      	ldr	r3, [r3, #0]
 8008b00:	61e3      	str	r3, [r4, #28]
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
 8008b02:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008b04:	681b      	ldr	r3, [r3, #0]
  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 8008b06:	73e2      	strb	r2, [r4, #15]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 8008b08:	2208      	movs	r2, #8
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
 8008b0a:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26
  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 8008b0e:	2300      	movs	r3, #0
  hdr->protolen = sizeof(ip4_addr_t);
 8008b10:	74e1      	strb	r1, [r4, #19]
  result = netif->linkoutput(netif, p);
 8008b12:	4629      	mov	r1, r5
  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 8008b14:	73a3      	strb	r3, [r4, #14]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 8008b16:	7463      	strb	r3, [r4, #17]
  hdr->hwlen = ETHARP_HWADDR_LEN;
 8008b18:	2306      	movs	r3, #6
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 8008b1a:	7422      	strb	r2, [r4, #16]
  hdr->hwlen = ETHARP_HWADDR_LEN;
 8008b1c:	74a3      	strb	r3, [r4, #18]
    ethhdr->type = PP_HTONS(ETHTYPE_ARP);
 8008b1e:	7322      	strb	r2, [r4, #12]
 8008b20:	7363      	strb	r3, [r4, #13]
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 8008b22:	f8d8 3000 	ldr.w	r3, [r8]
 8008b26:	6023      	str	r3, [r4, #0]
 8008b28:	f8b8 3004 	ldrh.w	r3, [r8, #4]
 8008b2c:	80a3      	strh	r3, [r4, #4]
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
 8008b2e:	683b      	ldr	r3, [r7, #0]
 8008b30:	f8c4 3006 	str.w	r3, [r4, #6]
 8008b34:	88bb      	ldrh	r3, [r7, #4]
 8008b36:	8163      	strh	r3, [r4, #10]
  result = netif->linkoutput(netif, p);
 8008b38:	69b3      	ldr	r3, [r6, #24]
 8008b3a:	4798      	blx	r3
 8008b3c:	4604      	mov	r4, r0
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
 8008b3e:	4628      	mov	r0, r5
 8008b40:	f7fd f859 	bl	8005bf6 <pbuf_free>
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
}
 8008b44:	4620      	mov	r0, r4
 8008b46:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return ERR_MEM;
 8008b4a:	f04f 34ff 	mov.w	r4, #4294967295
 8008b4e:	e7f9      	b.n	8008b44 <etharp_raw.constprop.1+0x8c>
 8008b50:	08009d60 	.word	0x08009d60

08008b54 <etharp_cleanup_netif>:
{
 8008b54:	b570      	push	{r4, r5, r6, lr}
 8008b56:	4606      	mov	r6, r0
 8008b58:	4d07      	ldr	r5, [pc, #28]	; (8008b78 <etharp_cleanup_netif+0x24>)
 8008b5a:	2400      	movs	r4, #0
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 8008b5c:	7d2b      	ldrb	r3, [r5, #20]
 8008b5e:	b12b      	cbz	r3, 8008b6c <etharp_cleanup_netif+0x18>
 8008b60:	68ab      	ldr	r3, [r5, #8]
 8008b62:	42b3      	cmp	r3, r6
 8008b64:	d102      	bne.n	8008b6c <etharp_cleanup_netif+0x18>
      etharp_free_entry(i);
 8008b66:	4620      	mov	r0, r4
 8008b68:	f7ff ff1a 	bl	80089a0 <etharp_free_entry>
 8008b6c:	3401      	adds	r4, #1
 8008b6e:	3518      	adds	r5, #24
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8008b70:	2c0a      	cmp	r4, #10
 8008b72:	d1f3      	bne.n	8008b5c <etharp_cleanup_netif+0x8>
}
 8008b74:	bd70      	pop	{r4, r5, r6, pc}
 8008b76:	bf00      	nop
 8008b78:	20003e48 	.word	0x20003e48

08008b7c <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, const ip4_addr_t *ipaddr)
{
 8008b7c:	b507      	push	{r0, r1, r2, lr}
 8008b7e:	4602      	mov	r2, r0
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 8008b80:	f100 0325 	add.w	r3, r0, #37	; 0x25
 8008b84:	9101      	str	r1, [sp, #4]
                    (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 8008b86:	3204      	adds	r2, #4
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 8008b88:	4619      	mov	r1, r3
 8008b8a:	9200      	str	r2, [sp, #0]
 8008b8c:	4a02      	ldr	r2, [pc, #8]	; (8008b98 <etharp_request+0x1c>)
 8008b8e:	f7ff ff93 	bl	8008ab8 <etharp_raw.constprop.1>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_request_dst(netif, ipaddr, &ethbroadcast);
}
 8008b92:	b003      	add	sp, #12
 8008b94:	f85d fb04 	ldr.w	pc, [sp], #4
 8008b98:	08009d66 	.word	0x08009d66

08008b9c <etharp_tmr>:
{
 8008b9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008b9e:	4c13      	ldr	r4, [pc, #76]	; (8008bec <etharp_tmr+0x50>)
 8008ba0:	2500      	movs	r5, #0
        arp_table[i].state = ETHARP_STATE_STABLE;
 8008ba2:	2602      	movs	r6, #2
        arp_table[i].state = ETHARP_STATE_STABLE_REREQUESTING_2;
 8008ba4:	2704      	movs	r7, #4
    u8_t state = arp_table[i].state;
 8008ba6:	7c22      	ldrb	r2, [r4, #16]
    if (state != ETHARP_STATE_EMPTY
 8008ba8:	b16a      	cbz	r2, 8008bc6 <etharp_tmr+0x2a>
      arp_table[i].ctime++;
 8008baa:	89e3      	ldrh	r3, [r4, #14]
 8008bac:	3301      	adds	r3, #1
 8008bae:	b29b      	uxth	r3, r3
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 8008bb0:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
      arp_table[i].ctime++;
 8008bb4:	81e3      	strh	r3, [r4, #14]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 8008bb6:	d203      	bcs.n	8008bc0 <etharp_tmr+0x24>
 8008bb8:	2a01      	cmp	r2, #1
 8008bba:	d109      	bne.n	8008bd0 <etharp_tmr+0x34>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 8008bbc:	2b04      	cmp	r3, #4
 8008bbe:	d90b      	bls.n	8008bd8 <etharp_tmr+0x3c>
        etharp_free_entry(i);
 8008bc0:	4628      	mov	r0, r5
 8008bc2:	f7ff feed 	bl	80089a0 <etharp_free_entry>
 8008bc6:	3501      	adds	r5, #1
 8008bc8:	3418      	adds	r4, #24
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8008bca:	2d0a      	cmp	r5, #10
 8008bcc:	d1eb      	bne.n	8008ba6 <etharp_tmr+0xa>
 8008bce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_1) {
 8008bd0:	2a03      	cmp	r2, #3
 8008bd2:	d106      	bne.n	8008be2 <etharp_tmr+0x46>
        arp_table[i].state = ETHARP_STATE_STABLE_REREQUESTING_2;
 8008bd4:	7427      	strb	r7, [r4, #16]
 8008bd6:	e7f6      	b.n	8008bc6 <etharp_tmr+0x2a>
        etharp_request(arp_table[i].netif, &arp_table[i].ipaddr);
 8008bd8:	4621      	mov	r1, r4
 8008bda:	6860      	ldr	r0, [r4, #4]
 8008bdc:	f7ff ffce 	bl	8008b7c <etharp_request>
 8008be0:	e7f1      	b.n	8008bc6 <etharp_tmr+0x2a>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_2) {
 8008be2:	2a04      	cmp	r2, #4
 8008be4:	d1ef      	bne.n	8008bc6 <etharp_tmr+0x2a>
        arp_table[i].state = ETHARP_STATE_STABLE;
 8008be6:	7426      	strb	r6, [r4, #16]
 8008be8:	e7ed      	b.n	8008bc6 <etharp_tmr+0x2a>
 8008bea:	bf00      	nop
 8008bec:	20003e4c 	.word	0x20003e4c

08008bf0 <etharp_output_to_arp_index>:
{
 8008bf0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8008bf4:	4689      	mov	r9, r1
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 8008bf6:	4d1a      	ldr	r5, [pc, #104]	; (8008c60 <etharp_output_to_arp_index+0x70>)
 8008bf8:	2118      	movs	r1, #24
{
 8008bfa:	4607      	mov	r7, r0
 8008bfc:	4614      	mov	r4, r2
 8008bfe:	f100 0825 	add.w	r8, r0, #37	; 0x25
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 8008c02:	fb01 5602 	mla	r6, r1, r2, r5
  if (arp_table[arp_idx].state == ETHARP_STATE_STABLE) {
 8008c06:	7d33      	ldrb	r3, [r6, #20]
 8008c08:	2b02      	cmp	r3, #2
 8008c0a:	d10a      	bne.n	8008c22 <etharp_output_to_arp_index+0x32>
    if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_BROADCAST) {
 8008c0c:	8a73      	ldrh	r3, [r6, #18]
 8008c0e:	f5b3 7f8e 	cmp.w	r3, #284	; 0x11c
 8008c12:	d912      	bls.n	8008c3a <etharp_output_to_arp_index+0x4a>
      if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 8008c14:	4631      	mov	r1, r6
 8008c16:	3104      	adds	r1, #4
 8008c18:	f7ff ffb0 	bl	8008b7c <etharp_request>
      if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR_OK) {
 8008c1c:	b908      	cbnz	r0, 8008c22 <etharp_output_to_arp_index+0x32>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 8008c1e:	2303      	movs	r3, #3
 8008c20:	7533      	strb	r3, [r6, #20]
    &arp_table[arp_idx].ethaddr);
 8008c22:	2318      	movs	r3, #24
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
 8008c24:	4642      	mov	r2, r8
 8008c26:	4649      	mov	r1, r9
 8008c28:	4638      	mov	r0, r7
    &arp_table[arp_idx].ethaddr);
 8008c2a:	fb03 5304 	mla	r3, r3, r4, r5
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
 8008c2e:	330c      	adds	r3, #12
}
 8008c30:	b003      	add	sp, #12
 8008c32:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
 8008c36:	f7ff bec7 	b.w	80089c8 <etharp_send_ip>
    } else if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_UNICAST) {
 8008c3a:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 8008c3e:	d3f0      	bcc.n	8008c22 <etharp_output_to_arp_index+0x32>
 8008c40:	eb02 0142 	add.w	r1, r2, r2, lsl #1
                    (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 8008c44:	1d03      	adds	r3, r0, #4
 8008c46:	00c9      	lsls	r1, r1, #3
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 8008c48:	9300      	str	r3, [sp, #0]
 8008c4a:	4643      	mov	r3, r8
      if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR_OK) {
 8008c4c:	f101 020c 	add.w	r2, r1, #12
 8008c50:	3104      	adds	r1, #4
 8008c52:	4429      	add	r1, r5
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 8008c54:	442a      	add	r2, r5
 8008c56:	9101      	str	r1, [sp, #4]
 8008c58:	4641      	mov	r1, r8
 8008c5a:	f7ff ff2d 	bl	8008ab8 <etharp_raw.constprop.1>
 8008c5e:	e7dd      	b.n	8008c1c <etharp_output_to_arp_index+0x2c>
 8008c60:	20003e48 	.word	0x20003e48

08008c64 <etharp_query>:
{
 8008c64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008c68:	4688      	mov	r8, r1
 8008c6a:	4607      	mov	r7, r0
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 8008c6c:	4601      	mov	r1, r0
{
 8008c6e:	4614      	mov	r4, r2
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 8008c70:	f8d8 0000 	ldr.w	r0, [r8]
 8008c74:	f7fc f9d1 	bl	800501a <ip4_addr_isbroadcast_u32>
 8008c78:	2800      	cmp	r0, #0
 8008c7a:	d14c      	bne.n	8008d16 <etharp_query+0xb2>
      ip4_addr_ismulticast(ipaddr) ||
 8008c7c:	f8d8 3000 	ldr.w	r3, [r8]
 8008c80:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 8008c84:	2ae0      	cmp	r2, #224	; 0xe0
 8008c86:	d046      	beq.n	8008d16 <etharp_query+0xb2>
      ip4_addr_isany(ipaddr)) {
 8008c88:	2b00      	cmp	r3, #0
 8008c8a:	d044      	beq.n	8008d16 <etharp_query+0xb2>
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD, netif);
 8008c8c:	2101      	movs	r1, #1
 8008c8e:	4640      	mov	r0, r8
 8008c90:	f7ff feac 	bl	80089ec <etharp_find_entry.isra.0>
  if (i < 0) {
 8008c94:	1e06      	subs	r6, r0, #0
 8008c96:	db42      	blt.n	8008d1e <etharp_query+0xba>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 8008c98:	4d2f      	ldr	r5, [pc, #188]	; (8008d58 <etharp_query+0xf4>)
 8008c9a:	2318      	movs	r3, #24
 8008c9c:	fb03 5306 	mla	r3, r3, r6, r5
 8008ca0:	7d1a      	ldrb	r2, [r3, #20]
 8008ca2:	2a00      	cmp	r2, #0
 8008ca4:	d13e      	bne.n	8008d24 <etharp_query+0xc0>
    arp_table[i].state = ETHARP_STATE_PENDING;
 8008ca6:	2201      	movs	r2, #1
    arp_table[i].netif = netif;
 8008ca8:	609f      	str	r7, [r3, #8]
    arp_table[i].state = ETHARP_STATE_PENDING;
 8008caa:	751a      	strb	r2, [r3, #20]
    result = etharp_request(netif, ipaddr);
 8008cac:	4641      	mov	r1, r8
 8008cae:	4638      	mov	r0, r7
 8008cb0:	f7ff ff64 	bl	8008b7c <etharp_request>
    if (q == NULL) {
 8008cb4:	2c00      	cmp	r4, #0
 8008cb6:	d04d      	beq.n	8008d54 <etharp_query+0xf0>
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 8008cb8:	2318      	movs	r3, #24
 8008cba:	fb03 5206 	mla	r2, r3, r6, r5
 8008cbe:	7d12      	ldrb	r2, [r2, #20]
 8008cc0:	2a01      	cmp	r2, #1
 8008cc2:	d90d      	bls.n	8008ce0 <etharp_query+0x7c>
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
 8008cc4:	220c      	movs	r2, #12
    ETHARP_SET_HINT(netif, i);
 8008cc6:	f885 60f0 	strb.w	r6, [r5, #240]	; 0xf0
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
 8008cca:	4621      	mov	r1, r4
 8008ccc:	4638      	mov	r0, r7
 8008cce:	fb13 2306 	smlabb	r3, r3, r6, r2
 8008cd2:	f107 0225 	add.w	r2, r7, #37	; 0x25
 8008cd6:	442b      	add	r3, r5
}
 8008cd8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
 8008cdc:	f7ff be74 	b.w	80089c8 <etharp_send_ip>
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 8008ce0:	d138      	bne.n	8008d54 <etharp_query+0xf0>
 8008ce2:	4623      	mov	r3, r4
    while (p) {
 8008ce4:	b993      	cbnz	r3, 8008d0c <etharp_query+0xa8>
      pbuf_ref(p);
 8008ce6:	4620      	mov	r0, r4
 8008ce8:	f7fd f865 	bl	8005db6 <pbuf_ref>
    if (p != NULL) {
 8008cec:	b374      	cbz	r4, 8008d4c <etharp_query+0xe8>
 8008cee:	4627      	mov	r7, r4
      if (arp_table[i].q != NULL) {
 8008cf0:	2318      	movs	r3, #24
 8008cf2:	fb03 f206 	mul.w	r2, r3, r6
 8008cf6:	461c      	mov	r4, r3
 8008cf8:	58a8      	ldr	r0, [r5, r2]
 8008cfa:	b108      	cbz	r0, 8008d00 <etharp_query+0x9c>
        pbuf_free(arp_table[i].q);
 8008cfc:	f7fc ff7b 	bl	8005bf6 <pbuf_free>
      arp_table[i].q = p;
 8008d00:	fb04 f306 	mul.w	r3, r4, r6
      result = ERR_OK;
 8008d04:	2000      	movs	r0, #0
      arp_table[i].q = p;
 8008d06:	50ef      	str	r7, [r5, r3]
 8008d08:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (p->type != PBUF_ROM) {
 8008d0c:	7b1a      	ldrb	r2, [r3, #12]
 8008d0e:	2a01      	cmp	r2, #1
 8008d10:	d10d      	bne.n	8008d2e <etharp_query+0xca>
      p = p->next;
 8008d12:	681b      	ldr	r3, [r3, #0]
 8008d14:	e7e6      	b.n	8008ce4 <etharp_query+0x80>
    return ERR_ARG;
 8008d16:	f06f 000e 	mvn.w	r0, #14
 8008d1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008d1e:	4630      	mov	r0, r6
 8008d20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (is_new_entry || (q == NULL)) {
 8008d24:	2c00      	cmp	r4, #0
 8008d26:	d0c1      	beq.n	8008cac <etharp_query+0x48>
  err_t result = ERR_MEM;
 8008d28:	f04f 30ff 	mov.w	r0, #4294967295
 8008d2c:	e7c4      	b.n	8008cb8 <etharp_query+0x54>
      p = pbuf_alloc(PBUF_RAW_TX, p->tot_len, PBUF_RAM);
 8008d2e:	2200      	movs	r2, #0
 8008d30:	8919      	ldrh	r1, [r3, #8]
 8008d32:	2003      	movs	r0, #3
 8008d34:	f7fc ff86 	bl	8005c44 <pbuf_alloc>
      if (p != NULL) {
 8008d38:	4607      	mov	r7, r0
 8008d3a:	b138      	cbz	r0, 8008d4c <etharp_query+0xe8>
        if (pbuf_copy(p, q) != ERR_OK) {
 8008d3c:	4621      	mov	r1, r4
 8008d3e:	f7fd f855 	bl	8005dec <pbuf_copy>
 8008d42:	2800      	cmp	r0, #0
 8008d44:	d0d4      	beq.n	8008cf0 <etharp_query+0x8c>
          pbuf_free(p);
 8008d46:	4638      	mov	r0, r7
 8008d48:	f7fc ff55 	bl	8005bf6 <pbuf_free>
      result = ERR_MEM;
 8008d4c:	f04f 30ff 	mov.w	r0, #4294967295
 8008d50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
}
 8008d54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008d58:	20003e48 	.word	0x20003e48

08008d5c <etharp_output>:
{
 8008d5c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8008d5e:	460e      	mov	r6, r1
 8008d60:	4604      	mov	r4, r0
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
 8008d62:	210e      	movs	r1, #14
{
 8008d64:	4615      	mov	r5, r2
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
 8008d66:	4630      	mov	r0, r6
 8008d68:	f7fc ff37 	bl	8005bda <pbuf_header>
 8008d6c:	2800      	cmp	r0, #0
 8008d6e:	d15f      	bne.n	8008e30 <etharp_output+0xd4>
  if (ip4_addr_isbroadcast(ipaddr, netif)) {
 8008d70:	4621      	mov	r1, r4
 8008d72:	6828      	ldr	r0, [r5, #0]
 8008d74:	f7fc f951 	bl	800501a <ip4_addr_isbroadcast_u32>
 8008d78:	2800      	cmp	r0, #0
 8008d7a:	d157      	bne.n	8008e2c <etharp_output+0xd0>
  } else if (ip4_addr_ismulticast(ipaddr)) {
 8008d7c:	682b      	ldr	r3, [r5, #0]
 8008d7e:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8008d82:	2ae0      	cmp	r2, #224	; 0xe0
 8008d84:	d11a      	bne.n	8008dbc <etharp_output+0x60>
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
 8008d86:	2301      	movs	r3, #1
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
 8008d88:	f88d 0001 	strb.w	r0, [sp, #1]
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
 8008d8c:	f88d 3000 	strb.w	r3, [sp]
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
 8008d90:	235e      	movs	r3, #94	; 0x5e
 8008d92:	f88d 3002 	strb.w	r3, [sp, #2]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 8008d96:	786b      	ldrb	r3, [r5, #1]
 8008d98:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8008d9c:	f88d 3003 	strb.w	r3, [sp, #3]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 8008da0:	78ab      	ldrb	r3, [r5, #2]
 8008da2:	f88d 3004 	strb.w	r3, [sp, #4]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 8008da6:	78eb      	ldrb	r3, [r5, #3]
 8008da8:	f88d 3005 	strb.w	r3, [sp, #5]
    dest = &mcastaddr;
 8008dac:	466b      	mov	r3, sp
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
 8008dae:	f104 0225 	add.w	r2, r4, #37	; 0x25
 8008db2:	4631      	mov	r1, r6
 8008db4:	4620      	mov	r0, r4
 8008db6:	f7ff fe07 	bl	80089c8 <etharp_send_ip>
 8008dba:	e01e      	b.n	8008dfa <etharp_output+0x9e>
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
 8008dbc:	6862      	ldr	r2, [r4, #4]
 8008dbe:	68a1      	ldr	r1, [r4, #8]
 8008dc0:	405a      	eors	r2, r3
 8008dc2:	420a      	tst	r2, r1
 8008dc4:	d008      	beq.n	8008dd8 <etharp_output+0x7c>
        !ip4_addr_islinklocal(ipaddr)) {
 8008dc6:	b29b      	uxth	r3, r3
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
 8008dc8:	f64f 62a9 	movw	r2, #65193	; 0xfea9
 8008dcc:	4293      	cmp	r3, r2
 8008dce:	d003      	beq.n	8008dd8 <etharp_output+0x7c>
          if (!ip4_addr_isany_val(*netif_ip4_gw(netif))) {
 8008dd0:	68e3      	ldr	r3, [r4, #12]
 8008dd2:	b383      	cbz	r3, 8008e36 <etharp_output+0xda>
            dst_addr = netif_ip4_gw(netif);
 8008dd4:	f104 050c 	add.w	r5, r4, #12
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 8008dd8:	4b18      	ldr	r3, [pc, #96]	; (8008e3c <etharp_output+0xe0>)
 8008dda:	2118      	movs	r1, #24
 8008ddc:	f893 20f0 	ldrb.w	r2, [r3, #240]	; 0xf0
 8008de0:	fb01 3102 	mla	r1, r1, r2, r3
 8008de4:	7d08      	ldrb	r0, [r1, #20]
 8008de6:	2801      	cmp	r0, #1
 8008de8:	d909      	bls.n	8008dfe <etharp_output+0xa2>
 8008dea:	6828      	ldr	r0, [r5, #0]
 8008dec:	6849      	ldr	r1, [r1, #4]
 8008dee:	4288      	cmp	r0, r1
 8008df0:	d105      	bne.n	8008dfe <etharp_output+0xa2>
        return etharp_output_to_arp_index(netif, q, i);
 8008df2:	4631      	mov	r1, r6
 8008df4:	4620      	mov	r0, r4
 8008df6:	f7ff fefb 	bl	8008bf0 <etharp_output_to_arp_index>
}
 8008dfa:	b003      	add	sp, #12
 8008dfc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008dfe:	490f      	ldr	r1, [pc, #60]	; (8008e3c <etharp_output+0xe0>)
{
 8008e00:	2200      	movs	r2, #0
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 8008e02:	7d08      	ldrb	r0, [r1, #20]
 8008e04:	2801      	cmp	r0, #1
 8008e06:	d907      	bls.n	8008e18 <etharp_output+0xbc>
 8008e08:	682f      	ldr	r7, [r5, #0]
 8008e0a:	6848      	ldr	r0, [r1, #4]
 8008e0c:	4287      	cmp	r7, r0
 8008e0e:	d103      	bne.n	8008e18 <etharp_output+0xbc>
        ETHARP_SET_HINT(netif, i);
 8008e10:	b2d2      	uxtb	r2, r2
 8008e12:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
 8008e16:	e7ec      	b.n	8008df2 <etharp_output+0x96>
 8008e18:	3201      	adds	r2, #1
 8008e1a:	3118      	adds	r1, #24
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 8008e1c:	2a0a      	cmp	r2, #10
 8008e1e:	d1f0      	bne.n	8008e02 <etharp_output+0xa6>
    return etharp_query(netif, dst_addr, q);
 8008e20:	4632      	mov	r2, r6
 8008e22:	4629      	mov	r1, r5
 8008e24:	4620      	mov	r0, r4
 8008e26:	f7ff ff1d 	bl	8008c64 <etharp_query>
 8008e2a:	e7e6      	b.n	8008dfa <etharp_output+0x9e>
    dest = (const struct eth_addr *)&ethbroadcast;
 8008e2c:	4b04      	ldr	r3, [pc, #16]	; (8008e40 <etharp_output+0xe4>)
 8008e2e:	e7be      	b.n	8008dae <etharp_output+0x52>
    return ERR_BUF;
 8008e30:	f06f 0001 	mvn.w	r0, #1
 8008e34:	e7e1      	b.n	8008dfa <etharp_output+0x9e>
            return ERR_RTE;
 8008e36:	f06f 0003 	mvn.w	r0, #3
 8008e3a:	e7de      	b.n	8008dfa <etharp_output+0x9e>
 8008e3c:	20003e48 	.word	0x20003e48
 8008e40:	08009d66 	.word	0x08009d66

08008e44 <ethernet_input>:
 * @param p the received packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 8008e44:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN || LWIP_IPV6
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
 8008e48:	8947      	ldrh	r7, [r0, #10]
{
 8008e4a:	4605      	mov	r5, r0
 8008e4c:	460e      	mov	r6, r1
  if (p->len <= SIZEOF_ETH_HDR) {
 8008e4e:	2f0e      	cmp	r7, #14
 8008e50:	d916      	bls.n	8008e80 <ethernet_input+0x3c>
    MIB2_STATS_NETIF_INC(netif, ifinerrors);
    goto free_and_return;
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
 8008e52:	6844      	ldr	r4, [r0, #4]

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
 8008e54:	7823      	ldrb	r3, [r4, #0]
  type = ethhdr->type;
 8008e56:	f8b4 800c 	ldrh.w	r8, [r4, #12]
  if (ethhdr->dest.addr[0] & 1) {
 8008e5a:	07d8      	lsls	r0, r3, #31
 8008e5c:	d50a      	bpl.n	8008e74 <ethernet_input+0x30>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
 8008e5e:	2b01      	cmp	r3, #1
 8008e60:	d112      	bne.n	8008e88 <ethernet_input+0x44>
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
 8008e62:	7863      	ldrb	r3, [r4, #1]
 8008e64:	b933      	cbnz	r3, 8008e74 <ethernet_input+0x30>
 8008e66:	78a3      	ldrb	r3, [r4, #2]
 8008e68:	2b5e      	cmp	r3, #94	; 0x5e
 8008e6a:	d103      	bne.n	8008e74 <ethernet_input+0x30>
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
 8008e6c:	7b6b      	ldrb	r3, [r5, #13]
 8008e6e:	f043 0310 	orr.w	r3, r3, #16
      }
    } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
 8008e72:	736b      	strb	r3, [r5, #13]
    }
  }

  switch (type) {
 8008e74:	f1b8 0f08 	cmp.w	r8, #8
 8008e78:	d011      	beq.n	8008e9e <ethernet_input+0x5a>
 8008e7a:	f5b8 6fc1 	cmp.w	r8, #1544	; 0x608
 8008e7e:	d021      	beq.n	8008ec4 <ethernet_input+0x80>
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
 8008e80:	4628      	mov	r0, r5
 8008e82:	f7fc feb8 	bl	8005bf6 <pbuf_free>
  return ERR_OK;
 8008e86:	e019      	b.n	8008ebc <ethernet_input+0x78>
    } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 8008e88:	2206      	movs	r2, #6
 8008e8a:	4958      	ldr	r1, [pc, #352]	; (8008fec <ethernet_input+0x1a8>)
 8008e8c:	4620      	mov	r0, r4
 8008e8e:	f000 fea9 	bl	8009be4 <memcmp>
 8008e92:	2800      	cmp	r0, #0
 8008e94:	d1ee      	bne.n	8008e74 <ethernet_input+0x30>
      p->flags |= PBUF_FLAG_LLBCAST;
 8008e96:	7b6b      	ldrb	r3, [r5, #13]
 8008e98:	f043 0308 	orr.w	r3, r3, #8
 8008e9c:	e7e9      	b.n	8008e72 <ethernet_input+0x2e>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 8008e9e:	f896 302b 	ldrb.w	r3, [r6, #43]	; 0x2b
 8008ea2:	0719      	lsls	r1, r3, #28
 8008ea4:	d5ec      	bpl.n	8008e80 <ethernet_input+0x3c>
      if ((p->len < ip_hdr_offset) || pbuf_header(p, (s16_t)-ip_hdr_offset)) {
 8008ea6:	f06f 010d 	mvn.w	r1, #13
 8008eaa:	4628      	mov	r0, r5
 8008eac:	f7fc fe95 	bl	8005bda <pbuf_header>
 8008eb0:	2800      	cmp	r0, #0
 8008eb2:	d1e5      	bne.n	8008e80 <ethernet_input+0x3c>
        ip4_input(p, netif);
 8008eb4:	4631      	mov	r1, r6
 8008eb6:	4628      	mov	r0, r5
 8008eb8:	f7fb ff94 	bl	8004de4 <ip4_input>
}
 8008ebc:	2000      	movs	r0, #0
 8008ebe:	b003      	add	sp, #12
 8008ec0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 8008ec4:	f896 302b 	ldrb.w	r3, [r6, #43]	; 0x2b
 8008ec8:	071a      	lsls	r2, r3, #28
 8008eca:	d5d9      	bpl.n	8008e80 <ethernet_input+0x3c>
  if (p->len < SIZEOF_ETHARP_PACKET) {
 8008ecc:	2f29      	cmp	r7, #41	; 0x29
 8008ece:	d9d7      	bls.n	8008e80 <ethernet_input+0x3c>
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 8008ed0:	89e3      	ldrh	r3, [r4, #14]
 8008ed2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008ed6:	d1d3      	bne.n	8008e80 <ethernet_input+0x3c>
 8008ed8:	7ca3      	ldrb	r3, [r4, #18]
 8008eda:	2b06      	cmp	r3, #6
 8008edc:	d1d0      	bne.n	8008e80 <ethernet_input+0x3c>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
 8008ede:	7ce3      	ldrb	r3, [r4, #19]
 8008ee0:	2b04      	cmp	r3, #4
 8008ee2:	d1cd      	bne.n	8008e80 <ethernet_input+0x3c>
      (hdr->protolen != sizeof(ip4_addr_t)) ||
 8008ee4:	8a23      	ldrh	r3, [r4, #16]
 8008ee6:	2b08      	cmp	r3, #8
 8008ee8:	d1ca      	bne.n	8008e80 <ethernet_input+0x3c>
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 8008eea:	69e0      	ldr	r0, [r4, #28]
  if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 8008eec:	6873      	ldr	r3, [r6, #4]
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 8008eee:	9001      	str	r0, [sp, #4]
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
 8008ef0:	f8d4 8026 	ldr.w	r8, [r4, #38]	; 0x26
  if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 8008ef4:	2b00      	cmp	r3, #0
 8008ef6:	d077      	beq.n	8008fe8 <ethernet_input+0x1a4>
    for_us = (u8_t)ip4_addr_cmp(&dipaddr, netif_ip4_addr(netif));
 8008ef8:	eba8 0303 	sub.w	r3, r8, r3
 8008efc:	f1d3 0800 	rsbs	r8, r3, #0
 8008f00:	eb48 0803 	adc.w	r8, r8, r3
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8008f04:	f1b8 0f00 	cmp.w	r8, #0
 8008f08:	f104 0716 	add.w	r7, r4, #22
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
 8008f0c:	f106 0925 	add.w	r9, r6, #37	; 0x25
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8008f10:	bf14      	ite	ne
 8008f12:	f04f 0a01 	movne.w	sl, #1
 8008f16:	f04f 0a02 	moveq.w	sl, #2
  if (ip4_addr_isany(ipaddr) ||
 8008f1a:	b3c0      	cbz	r0, 8008f8e <ethernet_input+0x14a>
      ip4_addr_isbroadcast(ipaddr, netif) ||
 8008f1c:	4631      	mov	r1, r6
 8008f1e:	f7fc f87c 	bl	800501a <ip4_addr_isbroadcast_u32>
  if (ip4_addr_isany(ipaddr) ||
 8008f22:	4683      	mov	fp, r0
 8008f24:	bb98      	cbnz	r0, 8008f8e <ethernet_input+0x14a>
      ip4_addr_ismulticast(ipaddr)) {
 8008f26:	9b01      	ldr	r3, [sp, #4]
 8008f28:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      ip4_addr_isbroadcast(ipaddr, netif) ||
 8008f2c:	2be0      	cmp	r3, #224	; 0xe0
 8008f2e:	d02e      	beq.n	8008f8e <ethernet_input+0x14a>
  i = etharp_find_entry(ipaddr, flags, netif);
 8008f30:	4651      	mov	r1, sl
 8008f32:	a801      	add	r0, sp, #4
 8008f34:	f7ff fd5a 	bl	80089ec <etharp_find_entry.isra.0>
  if (i < 0) {
 8008f38:	2800      	cmp	r0, #0
 8008f3a:	db28      	blt.n	8008f8e <ethernet_input+0x14a>
    arp_table[i].state = ETHARP_STATE_STABLE;
 8008f3c:	2218      	movs	r2, #24
 8008f3e:	4b2c      	ldr	r3, [pc, #176]	; (8008ff0 <ethernet_input+0x1ac>)
 8008f40:	f04f 0c02 	mov.w	ip, #2
 8008f44:	fb02 f100 	mul.w	r1, r2, r0
 8008f48:	eb03 0e01 	add.w	lr, r3, r1
 8008f4c:	f88e c014 	strb.w	ip, [lr, #20]
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 8008f50:	f04f 0c0c 	mov.w	ip, #12
  arp_table[i].netif = netif;
 8008f54:	f8ce 6008 	str.w	r6, [lr, #8]
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 8008f58:	fb12 c200 	smlabb	r2, r2, r0, ip
 8008f5c:	6838      	ldr	r0, [r7, #0]
 8008f5e:	eb03 0c02 	add.w	ip, r3, r2
 8008f62:	5098      	str	r0, [r3, r2]
 8008f64:	88ba      	ldrh	r2, [r7, #4]
 8008f66:	f8ac 2004 	strh.w	r2, [ip, #4]
  if (arp_table[i].q != NULL) {
 8008f6a:	f853 a001 	ldr.w	sl, [r3, r1]
  arp_table[i].ctime = 0;
 8008f6e:	f8ae b012 	strh.w	fp, [lr, #18]
  if (arp_table[i].q != NULL) {
 8008f72:	f1ba 0f00 	cmp.w	sl, #0
 8008f76:	d00a      	beq.n	8008f8e <ethernet_input+0x14a>
    arp_table[i].q = NULL;
 8008f78:	f843 b001 	str.w	fp, [r3, r1]
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
 8008f7c:	464a      	mov	r2, r9
 8008f7e:	463b      	mov	r3, r7
 8008f80:	4651      	mov	r1, sl
 8008f82:	4630      	mov	r0, r6
 8008f84:	f7ff fd20 	bl	80089c8 <etharp_send_ip>
    pbuf_free(p);
 8008f88:	4650      	mov	r0, sl
 8008f8a:	f7fc fe34 	bl	8005bf6 <pbuf_free>
  switch (hdr->opcode) {
 8008f8e:	8aa3      	ldrh	r3, [r4, #20]
 8008f90:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008f94:	f47f af74 	bne.w	8008e80 <ethernet_input+0x3c>
    if (for_us) {
 8008f98:	f1b8 0f00 	cmp.w	r8, #0
 8008f9c:	f43f af70 	beq.w	8008e80 <ethernet_input+0x3c>
      hdr->opcode = htons(ARP_REPLY);
 8008fa0:	2002      	movs	r0, #2
 8008fa2:	f7fb fe1d 	bl	8004be0 <lwip_htons>
      IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
 8008fa6:	69e3      	ldr	r3, [r4, #28]
      hdr->opcode = htons(ARP_REPLY);
 8008fa8:	82a0      	strh	r0, [r4, #20]
      netif->linkoutput(netif, p);
 8008faa:	4629      	mov	r1, r5
      IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
 8008fac:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26
      netif->linkoutput(netif, p);
 8008fb0:	4630      	mov	r0, r6
      IPADDR2_COPY(&hdr->sipaddr, netif_ip4_addr(netif));
 8008fb2:	6873      	ldr	r3, [r6, #4]
 8008fb4:	61e3      	str	r3, [r4, #28]
      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
 8008fb6:	683b      	ldr	r3, [r7, #0]
 8008fb8:	6223      	str	r3, [r4, #32]
 8008fba:	88bb      	ldrh	r3, [r7, #4]
 8008fbc:	84a3      	strh	r3, [r4, #36]	; 0x24
      ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
 8008fbe:	683b      	ldr	r3, [r7, #0]
 8008fc0:	6023      	str	r3, [r4, #0]
 8008fc2:	88bb      	ldrh	r3, [r7, #4]
 8008fc4:	80a3      	strh	r3, [r4, #4]
      ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
 8008fc6:	f8d9 3000 	ldr.w	r3, [r9]
 8008fca:	f8c4 3016 	str.w	r3, [r4, #22]
 8008fce:	f8b9 3004 	ldrh.w	r3, [r9, #4]
 8008fd2:	80bb      	strh	r3, [r7, #4]
      ETHADDR16_COPY(&ethhdr->src, ethaddr);
 8008fd4:	f8d9 3000 	ldr.w	r3, [r9]
 8008fd8:	f8c4 3006 	str.w	r3, [r4, #6]
 8008fdc:	f8b9 3004 	ldrh.w	r3, [r9, #4]
 8008fe0:	8163      	strh	r3, [r4, #10]
      netif->linkoutput(netif, p);
 8008fe2:	69b3      	ldr	r3, [r6, #24]
 8008fe4:	4798      	blx	r3
 8008fe6:	e74b      	b.n	8008e80 <ethernet_input+0x3c>
  if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 8008fe8:	4698      	mov	r8, r3
 8008fea:	e78b      	b.n	8008f04 <ethernet_input+0xc0>
 8008fec:	08009d66 	.word	0x08009d66
 8008ff0:	20003e48 	.word	0x20003e48

08008ff4 <sys_mbox_new>:


/*-----------------------------------------------------------------------------------*/
//  Creates an empty mailbox.
err_t sys_mbox_new(sys_mbox_t *mbox, int size)
{
 8008ff4:	b510      	push	{r4, lr}
 8008ff6:	4604      	mov	r4, r0
	(void ) size;
	
	*mbox = xQueueCreate( archMESG_QUEUE_LENGTH, sizeof( void * ) );
 8008ff8:	2200      	movs	r2, #0
 8008ffa:	2104      	movs	r1, #4
 8008ffc:	2006      	movs	r0, #6
 8008ffe:	f7f9 fe6d 	bl	8002cdc <xQueueGenericCreate>
 8009002:	6020      	str	r0, [r4, #0]
      ++lwip_stats.sys.mbox.used;
      if (lwip_stats.sys.mbox.max < lwip_stats.sys.mbox.used) {
         lwip_stats.sys.mbox.max = lwip_stats.sys.mbox.used;
	  }
#endif /* SYS_STATS */
 if (*mbox == NULL)
 8009004:	fab0 f080 	clz	r0, r0
 8009008:	0940      	lsrs	r0, r0, #5
  return ERR_MEM;
 
 return ERR_OK;
}
 800900a:	4240      	negs	r0, r0
 800900c:	bd10      	pop	{r4, pc}

0800900e <sys_mbox_free>:
  Deallocates a mailbox. If there are messages still present in the
  mailbox when the mailbox is deallocated, it is an indication of a
  programming error in lwIP and the developer should be notified.
*/
void sys_mbox_free(sys_mbox_t *mbox)
{
 800900e:	b510      	push	{r4, lr}
 8009010:	4604      	mov	r4, r0
	if( uxQueueMessagesWaiting( *mbox ) )
 8009012:	6800      	ldr	r0, [r0, #0]
 8009014:	f7fa f8f1 	bl	80031fa <uxQueueMessagesWaiting>
#endif /* SYS_STATS */
			
		// TODO notify the user of failure.
	}

	vQueueDelete( *mbox );
 8009018:	6820      	ldr	r0, [r4, #0]

#if SYS_STATS
     --lwip_stats.sys.mbox.used;
#endif /* SYS_STATS */
}
 800901a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	vQueueDelete( *mbox );
 800901e:	f7fa b913 	b.w	8003248 <vQueueDelete>

08009022 <sys_mbox_post>:

/*-----------------------------------------------------------------------------------*/
//   Posts the "msg" to the mailbox.
void sys_mbox_post(sys_mbox_t *mbox, void *data)
{
 8009022:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8009024:	4605      	mov	r5, r0
 8009026:	ac02      	add	r4, sp, #8
 8009028:	f844 1d04 	str.w	r1, [r4, #-4]!
	while ( xQueueSendToBack(*mbox, &data, portMAX_DELAY ) != pdTRUE ){}
 800902c:	2300      	movs	r3, #0
 800902e:	f04f 32ff 	mov.w	r2, #4294967295
 8009032:	4621      	mov	r1, r4
 8009034:	6828      	ldr	r0, [r5, #0]
 8009036:	f7f9 fe87 	bl	8002d48 <xQueueGenericSend>
 800903a:	2801      	cmp	r0, #1
 800903c:	d1f6      	bne.n	800902c <sys_mbox_post+0xa>
}
 800903e:	b003      	add	sp, #12
 8009040:	bd30      	pop	{r4, r5, pc}

08009042 <sys_mbox_trypost>:


/*-----------------------------------------------------------------------------------*/
//   Try to post the "msg" to the mailbox.
err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
{
 8009042:	b513      	push	{r0, r1, r4, lr}
err_t result;

   if ( xQueueSend( *mbox, &msg, 0 ) == pdPASS )
 8009044:	2300      	movs	r3, #0
{
 8009046:	ac02      	add	r4, sp, #8
   if ( xQueueSend( *mbox, &msg, 0 ) == pdPASS )
 8009048:	6800      	ldr	r0, [r0, #0]
{
 800904a:	f844 1d04 	str.w	r1, [r4, #-4]!
   if ( xQueueSend( *mbox, &msg, 0 ) == pdPASS )
 800904e:	461a      	mov	r2, r3
 8009050:	4621      	mov	r1, r4
 8009052:	f7f9 fe79 	bl	8002d48 <xQueueGenericSend>
#endif /* SYS_STATS */
			
   }

   return result;
}
 8009056:	f110 30ff 	adds.w	r0, r0, #4294967295
 800905a:	bf18      	it	ne
 800905c:	f04f 30ff 	movne.w	r0, #4294967295
 8009060:	b002      	add	sp, #8
 8009062:	bd10      	pop	{r4, pc}

08009064 <sys_arch_mbox_fetch>:

  Note that a function with a similar name, sys_mbox_fetch(), is
  implemented by lwIP.
*/
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
{
 8009064:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8009066:	460d      	mov	r5, r1
 8009068:	4606      	mov	r6, r0
 800906a:	4617      	mov	r7, r2
void *dummyptr;
portTickType StartTime, EndTime, Elapsed;

	StartTime = xTaskGetTickCount();
 800906c:	f7fa fa60 	bl	8003530 <xTaskGetTickCount>
 8009070:	4604      	mov	r4, r0

	if ( msg == NULL )
 8009072:	b905      	cbnz	r5, 8009076 <sys_arch_mbox_fetch+0x12>
	{
		msg = &dummyptr;
 8009074:	ad01      	add	r5, sp, #4
	}
		
	if ( timeout != 0 )
 8009076:	b18f      	cbz	r7, 800909c <sys_arch_mbox_fetch+0x38>
	{
		if ( pdTRUE == xQueueReceive( *mbox, &(*msg), timeout / portTICK_RATE_MS ) )
 8009078:	2300      	movs	r3, #0
 800907a:	463a      	mov	r2, r7
 800907c:	4629      	mov	r1, r5
 800907e:	6830      	ldr	r0, [r6, #0]
 8009080:	f7f9 ffa8 	bl	8002fd4 <xQueueGenericReceive>
 8009084:	2801      	cmp	r0, #1
 8009086:	d103      	bne.n	8009090 <sys_arch_mbox_fetch+0x2c>
		}
	}
	else // block forever for a message.
	{
		while( pdTRUE != xQueueReceive( *mbox, &(*msg), portMAX_DELAY ) ){} // time is arbitrary
		EndTime = xTaskGetTickCount();
 8009088:	f7fa fa52 	bl	8003530 <xTaskGetTickCount>
		Elapsed = (EndTime - StartTime) * portTICK_RATE_MS;
 800908c:	1b00      	subs	r0, r0, r4
		
		return ( Elapsed ); // return time blocked TODO test	
 800908e:	e003      	b.n	8009098 <sys_arch_mbox_fetch+0x34>
			*msg = NULL;
 8009090:	2300      	movs	r3, #0
			return SYS_ARCH_TIMEOUT;
 8009092:	f04f 30ff 	mov.w	r0, #4294967295
			*msg = NULL;
 8009096:	602b      	str	r3, [r5, #0]
	}
}
 8009098:	b003      	add	sp, #12
 800909a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		while( pdTRUE != xQueueReceive( *mbox, &(*msg), portMAX_DELAY ) ){} // time is arbitrary
 800909c:	2300      	movs	r3, #0
 800909e:	f04f 32ff 	mov.w	r2, #4294967295
 80090a2:	4629      	mov	r1, r5
 80090a4:	6830      	ldr	r0, [r6, #0]
 80090a6:	f7f9 ff95 	bl	8002fd4 <xQueueGenericReceive>
 80090aa:	2801      	cmp	r0, #1
 80090ac:	d1f6      	bne.n	800909c <sys_arch_mbox_fetch+0x38>
 80090ae:	e7eb      	b.n	8009088 <sys_arch_mbox_fetch+0x24>

080090b0 <sys_arch_mbox_tryfetch>:
/*
  Similar to sys_arch_mbox_fetch, but if message is not ready immediately, we'll
  return with SYS_MBOX_EMPTY.  On success, 0 is returned.
*/
u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
{
 80090b0:	b507      	push	{r0, r1, r2, lr}
void *dummyptr;

	if ( msg == NULL )
 80090b2:	b901      	cbnz	r1, 80090b6 <sys_arch_mbox_tryfetch+0x6>
	{
		msg = &dummyptr;
 80090b4:	a901      	add	r1, sp, #4
	}

   if ( pdTRUE == xQueueReceive( *mbox, &(*msg), 0 ) )
 80090b6:	2300      	movs	r3, #0
 80090b8:	6800      	ldr	r0, [r0, #0]
 80090ba:	461a      	mov	r2, r3
 80090bc:	f7f9 ff8a 	bl	8002fd4 <xQueueGenericReceive>
   }
   else
   {
      return SYS_MBOX_EMPTY;
   }
}
 80090c0:	f110 30ff 	adds.w	r0, r0, #4294967295
 80090c4:	bf18      	it	ne
 80090c6:	f04f 30ff 	movne.w	r0, #4294967295
 80090ca:	b003      	add	sp, #12
 80090cc:	f85d fb04 	ldr.w	pc, [sp], #4

080090d0 <sys_mbox_valid>:
 80090d0:	6800      	ldr	r0, [r0, #0]
 80090d2:	3000      	adds	r0, #0
 80090d4:	bf18      	it	ne
 80090d6:	2001      	movne	r0, #1
 80090d8:	4770      	bx	lr

080090da <sys_mbox_set_invalid>:
 80090da:	2300      	movs	r3, #0
 80090dc:	6003      	str	r3, [r0, #0]
 80090de:	4770      	bx	lr

080090e0 <sys_sem_new>:

/*-----------------------------------------------------------------------------------*/
//  Creates a new semaphore. The "count" argument specifies
//  the initial state of the semaphore.
err_t sys_sem_new(sys_sem_t *sem, u8_t count)
{
 80090e0:	b538      	push	{r3, r4, r5, lr}
 80090e2:	4605      	mov	r5, r0
 80090e4:	460c      	mov	r4, r1
	vSemaphoreCreateBinary(*sem );
 80090e6:	2203      	movs	r2, #3
 80090e8:	2100      	movs	r1, #0
 80090ea:	2001      	movs	r0, #1
 80090ec:	f7f9 fdf6 	bl	8002cdc <xQueueGenericCreate>
 80090f0:	6028      	str	r0, [r5, #0]
 80090f2:	b120      	cbz	r0, 80090fe <sys_sem_new+0x1e>
 80090f4:	2300      	movs	r3, #0
 80090f6:	461a      	mov	r2, r3
 80090f8:	4619      	mov	r1, r3
 80090fa:	f7f9 fe25 	bl	8002d48 <xQueueGenericSend>
	if(*sem == NULL)
 80090fe:	6828      	ldr	r0, [r5, #0]
 8009100:	b138      	cbz	r0, 8009112 <sys_sem_new+0x32>
      ++lwip_stats.sys.sem.err;
#endif /* SYS_STATS */	
		return ERR_MEM;
	}
	
	if(count == 0)	// Means it can't be taken
 8009102:	b924      	cbnz	r4, 800910e <sys_sem_new+0x2e>
	{
		xSemaphoreTake(*sem,1);
 8009104:	4623      	mov	r3, r4
 8009106:	2201      	movs	r2, #1
 8009108:	4621      	mov	r1, r4
 800910a:	f7f9 ff63 	bl	8002fd4 <xQueueGenericReceive>
 	if (lwip_stats.sys.sem.max < lwip_stats.sys.sem.used) {
		lwip_stats.sys.sem.max = lwip_stats.sys.sem.used;
	}
#endif /* SYS_STATS */
		
	return ERR_OK;
 800910e:	2000      	movs	r0, #0
}
 8009110:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_MEM;
 8009112:	f04f 30ff 	mov.w	r0, #4294967295
 8009116:	bd38      	pop	{r3, r4, r5, pc}

08009118 <sys_arch_sem_wait>:

  Notice that lwIP implements a function with a similar name,
  sys_sem_wait(), that uses the sys_arch_sem_wait() function.
*/
u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
{
 8009118:	b570      	push	{r4, r5, r6, lr}
 800911a:	460e      	mov	r6, r1
 800911c:	4605      	mov	r5, r0
portTickType StartTime, EndTime, Elapsed;

	StartTime = xTaskGetTickCount();
 800911e:	f7fa fa07 	bl	8003530 <xTaskGetTickCount>
 8009122:	4604      	mov	r4, r0

	if(	timeout != 0)
 8009124:	b15e      	cbz	r6, 800913e <sys_arch_sem_wait+0x26>
	{
		if( xSemaphoreTake( *sem, timeout / portTICK_RATE_MS ) == pdTRUE )
 8009126:	2300      	movs	r3, #0
 8009128:	4632      	mov	r2, r6
 800912a:	6828      	ldr	r0, [r5, #0]
 800912c:	4619      	mov	r1, r3
 800912e:	f7f9 ff51 	bl	8002fd4 <xQueueGenericReceive>
 8009132:	2801      	cmp	r0, #1
 8009134:	d10d      	bne.n	8009152 <sys_arch_sem_wait+0x3a>
		}
	}
	else // must block without a timeout
	{
		while( xSemaphoreTake(*sem, portMAX_DELAY) != pdTRUE){}
		EndTime = xTaskGetTickCount();
 8009136:	f7fa f9fb 	bl	8003530 <xTaskGetTickCount>
		Elapsed = (EndTime - StartTime) * portTICK_RATE_MS;
 800913a:	1b00      	subs	r0, r0, r4

		return ( Elapsed ); // return time blocked	
 800913c:	bd70      	pop	{r4, r5, r6, pc}
		while( xSemaphoreTake(*sem, portMAX_DELAY) != pdTRUE){}
 800913e:	2300      	movs	r3, #0
 8009140:	f04f 32ff 	mov.w	r2, #4294967295
 8009144:	6828      	ldr	r0, [r5, #0]
 8009146:	4619      	mov	r1, r3
 8009148:	f7f9 ff44 	bl	8002fd4 <xQueueGenericReceive>
 800914c:	2801      	cmp	r0, #1
 800914e:	d1f6      	bne.n	800913e <sys_arch_sem_wait+0x26>
 8009150:	e7f1      	b.n	8009136 <sys_arch_sem_wait+0x1e>
			return SYS_ARCH_TIMEOUT;
 8009152:	f04f 30ff 	mov.w	r0, #4294967295
		
	}
}
 8009156:	bd70      	pop	{r4, r5, r6, pc}

08009158 <sys_sem_valid>:
	vQueueDelete(*sem);
}
/*-----------------------------------------------------------------------------------*/
int sys_sem_valid(sys_sem_t *sem)                                               
{
  if (*sem == SYS_SEM_NULL)
 8009158:	6800      	ldr	r0, [r0, #0]
    return 0;
  else
    return 1;                                       
}
 800915a:	3000      	adds	r0, #0
 800915c:	bf18      	it	ne
 800915e:	2001      	movne	r0, #1
 8009160:	4770      	bx	lr

08009162 <sys_sem_set_invalid>:

/*-----------------------------------------------------------------------------------*/                                                                                                                                                                
void sys_sem_set_invalid(sys_sem_t *sem)                                        
{                                                                               
  *sem = SYS_SEM_NULL;                                                          
 8009162:	2300      	movs	r3, #0
 8009164:	6003      	str	r3, [r0, #0]
 8009166:	4770      	bx	lr

08009168 <sys_init>:
/*-----------------------------------------------------------------------------------*/
// Initialize sys arch
void sys_init(void)
{
	// keep track of how many threads have been created
	s_nextthread = 0;
 8009168:	2200      	movs	r2, #0
 800916a:	4b01      	ldr	r3, [pc, #4]	; (8009170 <sys_init+0x8>)
 800916c:	801a      	strh	r2, [r3, #0]
 800916e:	4770      	bx	lr
 8009170:	20003f3a 	.word	0x20003f3a

08009174 <sys_mutex_new>:
                                      /* Mutexes*/
/*-----------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------*/
#if LWIP_COMPAT_MUTEX == 0
/* Create a new mutex*/
err_t sys_mutex_new(sys_mutex_t *mutex) {
 8009174:	b510      	push	{r4, lr}
 8009176:	4604      	mov	r4, r0

  *mutex = xSemaphoreCreateMutex();
 8009178:	2001      	movs	r0, #1
 800917a:	f7f9 fea7 	bl	8002ecc <xQueueCreateMutex>
 800917e:	6020      	str	r0, [r4, #0]
		if(*mutex == NULL)
 8009180:	fab0 f080 	clz	r0, r0
 8009184:	0940      	lsrs	r0, r0, #5
 	if (lwip_stats.sys.mutex.max < lwip_stats.sys.mutex.used) {
		lwip_stats.sys.mutex.max = lwip_stats.sys.mutex.used;
	}
#endif /* SYS_STATS */
        return ERR_OK;
}
 8009186:	4240      	negs	r0, r0
 8009188:	bd10      	pop	{r4, pc}

0800918a <sys_mutex_free>:
{
#if SYS_STATS
      --lwip_stats.sys.mutex.used;
#endif /* SYS_STATS */
			
	vQueueDelete(*mutex);
 800918a:	6800      	ldr	r0, [r0, #0]
 800918c:	f7fa b85c 	b.w	8003248 <vQueueDelete>

08009190 <sys_sem_free>:
 8009190:	f7ff bffb 	b.w	800918a <sys_mutex_free>

08009194 <sys_mutex_lock>:
}
/*-----------------------------------------------------------------------------------*/
/* Lock a mutex*/
void sys_mutex_lock(sys_mutex_t *mutex)
{
	sys_arch_sem_wait(mutex, 0);
 8009194:	2100      	movs	r1, #0
 8009196:	f7ff bfbf 	b.w	8009118 <sys_arch_sem_wait>

0800919a <sys_mutex_unlock>:

/*-----------------------------------------------------------------------------------*/
/* Unlock a mutex*/
void sys_mutex_unlock(sys_mutex_t *mutex)
{
	xSemaphoreGive(*mutex);
 800919a:	2300      	movs	r3, #0
 800919c:	6800      	ldr	r0, [r0, #0]
 800919e:	461a      	mov	r2, r3
 80091a0:	4619      	mov	r1, r3
 80091a2:	f7f9 bdd1 	b.w	8002d48 <xQueueGenericSend>

080091a6 <sys_sem_signal>:
 80091a6:	f7ff bff8 	b.w	800919a <sys_mutex_unlock>
	...

080091ac <sys_thread_new>:
  function "thread()". The "arg" argument will be passed as an argument to the
  thread() function. The id of the new thread is returned. Both the id and
  the priority are system dependent.
*/
sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread , void *arg, int stacksize, int prio)
{
 80091ac:	b510      	push	{r4, lr}
 80091ae:	4604      	mov	r4, r0
 80091b0:	4608      	mov	r0, r1
 80091b2:	4619      	mov	r1, r3
xTaskHandle CreatedTask;
int result;

   if ( s_nextthread < SYS_THREAD_MAX )
 80091b4:	4b0b      	ldr	r3, [pc, #44]	; (80091e4 <sys_thread_new+0x38>)
{
 80091b6:	b086      	sub	sp, #24
   if ( s_nextthread < SYS_THREAD_MAX )
 80091b8:	881b      	ldrh	r3, [r3, #0]
 80091ba:	2b05      	cmp	r3, #5
 80091bc:	d902      	bls.n	80091c4 <sys_thread_new+0x18>
		   return NULL;
	   }
   }
   else
   {
      return NULL;
 80091be:	2000      	movs	r0, #0
   }
}
 80091c0:	b006      	add	sp, #24
 80091c2:	bd10      	pop	{r4, pc}
      result = xTaskCreate( thread, name, stacksize, arg, prio, &CreatedTask );
 80091c4:	2300      	movs	r3, #0
 80091c6:	9303      	str	r3, [sp, #12]
 80091c8:	9302      	str	r3, [sp, #8]
 80091ca:	ab05      	add	r3, sp, #20
 80091cc:	9301      	str	r3, [sp, #4]
 80091ce:	9b08      	ldr	r3, [sp, #32]
 80091d0:	9300      	str	r3, [sp, #0]
 80091d2:	4613      	mov	r3, r2
 80091d4:	b28a      	uxth	r2, r1
 80091d6:	4621      	mov	r1, r4
 80091d8:	f7fa f945 	bl	8003466 <xTaskGenericCreate>
	   if(result == pdPASS)
 80091dc:	2801      	cmp	r0, #1
 80091de:	d1ee      	bne.n	80091be <sys_thread_new+0x12>
		   return CreatedTask;
 80091e0:	9805      	ldr	r0, [sp, #20]
 80091e2:	e7ed      	b.n	80091c0 <sys_thread_new+0x14>
 80091e4:	20003f3a 	.word	0x20003f3a

080091e8 <low_level_output>:
 *       to become availale since the stack doesn't retry to send a packet
 *       dropped because of memory failure (except for the TCP timers).
 */

static err_t low_level_output(struct netif *netif, struct pbuf *p)
{
 80091e8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  err_t errval;
  struct pbuf *q;
  uint8_t *buffer = (uint8_t *)(heth.TxDesc->Buffer1Addr);
 80091ec:	4a25      	ldr	r2, [pc, #148]	; (8009284 <low_level_output+0x9c>)
  uint32_t framelength = 0;
  uint32_t bufferoffset = 0;
  uint32_t byteslefttocopy = 0;
  uint32_t payloadoffset = 0;
  DmaTxDesc = heth.TxDesc;
  bufferoffset = 0;
 80091ee:	f04f 0800 	mov.w	r8, #0
{
 80091f2:	460c      	mov	r4, r1
      /* Get bytes in current lwIP buffer */
      byteslefttocopy = q->len;
      payloadoffset = 0;
    
      /* Check if the length of data to copy is bigger than Tx buffer size*/
      while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
 80091f4:	f240 5bf4 	movw	fp, #1524	; 0x5f4
  uint8_t *buffer = (uint8_t *)(heth.TxDesc->Buffer1Addr);
 80091f8:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
  uint32_t framelength = 0;
 80091fa:	4647      	mov	r7, r8
 80091fc:	9200      	str	r2, [sp, #0]
  uint8_t *buffer = (uint8_t *)(heth.TxDesc->Buffer1Addr);
 80091fe:	68ab      	ldr	r3, [r5, #8]
  for(q = p; q != NULL; q = q->next)
 8009200:	b92c      	cbnz	r4, 800920e <low_level_output+0x26>
      bufferoffset = bufferoffset + byteslefttocopy;
      framelength = framelength + byteslefttocopy;
    }
  
  /* Prepare transmit descriptors to give to DMA */ 
  HAL_ETH_TransmitFrame(&heth, framelength);
 8009202:	4639      	mov	r1, r7
 8009204:	481f      	ldr	r0, [pc, #124]	; (8009284 <low_level_output+0x9c>)
 8009206:	f7f7 f9fb 	bl	8000600 <HAL_ETH_TransmitFrame>
  
  errval = ERR_OK;
 800920a:	4620      	mov	r0, r4
 800920c:	e004      	b.n	8009218 <low_level_output+0x30>
      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
 800920e:	682a      	ldr	r2, [r5, #0]
 8009210:	2a00      	cmp	r2, #0
 8009212:	da11      	bge.n	8009238 <low_level_output+0x50>
        errval = ERR_USE;
 8009214:	f06f 0007 	mvn.w	r0, #7
  
error:
  
  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
  if ((heth.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
 8009218:	9b00      	ldr	r3, [sp, #0]
 800921a:	f241 0214 	movw	r2, #4116	; 0x1014
 800921e:	681b      	ldr	r3, [r3, #0]
 8009220:	5899      	ldr	r1, [r3, r2]
 8009222:	0689      	lsls	r1, r1, #26
 8009224:	d505      	bpl.n	8009232 <low_level_output+0x4a>
  {
    /* Clear TUS ETHERNET DMA flag */
    heth.Instance->DMASR = ETH_DMASR_TUS;
 8009226:	2120      	movs	r1, #32
 8009228:	5099      	str	r1, [r3, r2]

    /* Resume DMA transmission*/
    heth.Instance->DMATPDR = 0;
 800922a:	2100      	movs	r1, #0
 800922c:	f241 0204 	movw	r2, #4100	; 0x1004
 8009230:	5099      	str	r1, [r3, r2]
  }
  return errval;
}
 8009232:	b003      	add	sp, #12
 8009234:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      byteslefttocopy = q->len;
 8009238:	f8b4 900a 	ldrh.w	r9, [r4, #10]
      while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
 800923c:	4646      	mov	r6, r8
      payloadoffset = 0;
 800923e:	f04f 0a00 	mov.w	sl, #0
      while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
 8009242:	eb06 0809 	add.w	r8, r6, r9
 8009246:	1998      	adds	r0, r3, r6
 8009248:	6861      	ldr	r1, [r4, #4]
 800924a:	45d8      	cmp	r8, fp
 800924c:	d808      	bhi.n	8009260 <low_level_output+0x78>
      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
 800924e:	464a      	mov	r2, r9
 8009250:	4451      	add	r1, sl
 8009252:	9301      	str	r3, [sp, #4]
      framelength = framelength + byteslefttocopy;
 8009254:	444f      	add	r7, r9
      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
 8009256:	f000 fcd4 	bl	8009c02 <memcpy>
  for(q = p; q != NULL; q = q->next)
 800925a:	6824      	ldr	r4, [r4, #0]
 800925c:	9b01      	ldr	r3, [sp, #4]
 800925e:	e7cf      	b.n	8009200 <low_level_output+0x18>
        memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
 8009260:	ebab 0606 	sub.w	r6, fp, r6
 8009264:	4451      	add	r1, sl
 8009266:	4632      	mov	r2, r6
 8009268:	f000 fccb 	bl	8009c02 <memcpy>
        DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
 800926c:	68ed      	ldr	r5, [r5, #12]
        if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
 800926e:	682b      	ldr	r3, [r5, #0]
 8009270:	2b00      	cmp	r3, #0
 8009272:	dbcf      	blt.n	8009214 <low_level_output+0x2c>
        payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
 8009274:	44b2      	add	sl, r6
        framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
 8009276:	4437      	add	r7, r6
        buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
 8009278:	68ab      	ldr	r3, [r5, #8]
        byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
 800927a:	f2a8 59f4 	subw	r9, r8, #1524	; 0x5f4
        bufferoffset = 0;
 800927e:	2600      	movs	r6, #0
 8009280:	e7df      	b.n	8009242 <low_level_output+0x5a>
 8009282:	bf00      	nop
 8009284:	20008f54 	.word	0x20008f54

08009288 <ethernetif_input>:
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
void ethernetif_input( void const * argument ) 
 
{
 8009288:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800928c:	4682      	mov	sl, r0
  struct pbuf *p;
  struct netif *netif = (struct netif *) argument;
  
  for( ;; )
  {
    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
 800928e:	4c37      	ldr	r4, [pc, #220]	; (800936c <ethernetif_input+0xe4>)
 8009290:	f04f 31ff 	mov.w	r1, #4294967295
 8009294:	6820      	ldr	r0, [r4, #0]
 8009296:	f7f9 f967 	bl	8002568 <osSemaphoreWait>
 800929a:	2800      	cmp	r0, #0
 800929c:	d1f8      	bne.n	8009290 <ethernetif_input+0x8>
  if (HAL_ETH_GetReceivedFrame_IT(&heth) != HAL_OK)
 800929e:	4c34      	ldr	r4, [pc, #208]	; (8009370 <ethernetif_input+0xe8>)
 80092a0:	4620      	mov	r0, r4
 80092a2:	f7f7 fa1f 	bl	80006e4 <HAL_ETH_GetReceivedFrame_IT>
 80092a6:	4605      	mov	r5, r0
 80092a8:	2800      	cmp	r0, #0
 80092aa:	d1f0      	bne.n	800928e <ethernetif_input+0x6>
  buffer = (uint8_t *)heth.RxFrameInfos.buffer;
 80092ac:	6c23      	ldr	r3, [r4, #64]	; 0x40
  len = heth.RxFrameInfos.length;
 80092ae:	8fa1      	ldrh	r1, [r4, #60]	; 0x3c
  buffer = (uint8_t *)heth.RxFrameInfos.buffer;
 80092b0:	9301      	str	r3, [sp, #4]
  if (len > 0)
 80092b2:	bb01      	cbnz	r1, 80092f6 <ethernetif_input+0x6e>
  struct pbuf *p = NULL;
 80092b4:	2700      	movs	r7, #0
    dmarxdesc = heth.RxFrameInfos.FSRxDesc;
 80092b6:	6b23      	ldr	r3, [r4, #48]	; 0x30
    for (i=0; i< heth.RxFrameInfos.SegCount; i++)
 80092b8:	2200      	movs	r2, #0
 80092ba:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 80092bc:	4282      	cmp	r2, r0
 80092be:	d14d      	bne.n	800935c <ethernetif_input+0xd4>
    heth.RxFrameInfos.SegCount =0;  
 80092c0:	2300      	movs	r3, #0
  if ((heth.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
 80092c2:	f241 0214 	movw	r2, #4116	; 0x1014
    heth.RxFrameInfos.SegCount =0;  
 80092c6:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((heth.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
 80092c8:	6823      	ldr	r3, [r4, #0]
 80092ca:	5899      	ldr	r1, [r3, r2]
 80092cc:	0609      	lsls	r1, r1, #24
 80092ce:	d505      	bpl.n	80092dc <ethernetif_input+0x54>
    heth.Instance->DMASR = ETH_DMASR_RBUS;
 80092d0:	2180      	movs	r1, #128	; 0x80
 80092d2:	5099      	str	r1, [r3, r2]
    heth.Instance->DMARPDR = 0;
 80092d4:	f241 0208 	movw	r2, #4104	; 0x1008
 80092d8:	2100      	movs	r1, #0
 80092da:	5099      	str	r1, [r3, r2]
    {
      do
      {   
        p = low_level_input( netif );
        if   (p != NULL)
 80092dc:	2f00      	cmp	r7, #0
 80092de:	d0d6      	beq.n	800928e <ethernetif_input+0x6>
        {
          if (netif->input( p, netif) != ERR_OK )
 80092e0:	f8da 3010 	ldr.w	r3, [sl, #16]
 80092e4:	4651      	mov	r1, sl
 80092e6:	4638      	mov	r0, r7
 80092e8:	4798      	blx	r3
 80092ea:	2800      	cmp	r0, #0
 80092ec:	d0d7      	beq.n	800929e <ethernetif_input+0x16>
          {
            pbuf_free(p);
 80092ee:	4638      	mov	r0, r7
 80092f0:	f7fc fc81 	bl	8005bf6 <pbuf_free>
 80092f4:	e7d3      	b.n	800929e <ethernetif_input+0x16>
    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
 80092f6:	2203      	movs	r2, #3
 80092f8:	2004      	movs	r0, #4
 80092fa:	f7fc fca3 	bl	8005c44 <pbuf_alloc>
  if (p != NULL)
 80092fe:	4607      	mov	r7, r0
 8009300:	2800      	cmp	r0, #0
 8009302:	d0d7      	beq.n	80092b4 <ethernetif_input+0x2c>
    dmarxdesc = heth.RxFrameInfos.FSRxDesc;
 8009304:	f8d4 b030 	ldr.w	fp, [r4, #48]	; 0x30
 8009308:	4680      	mov	r8, r0
      byteslefttocopy = q->len;
 800930a:	f8b8 200a 	ldrh.w	r2, [r8, #10]
 800930e:	462e      	mov	r6, r5
      payloadoffset = 0;
 8009310:	f04f 0900 	mov.w	r9, #0
      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
 8009314:	f240 53f4 	movw	r3, #1524	; 0x5f4
 8009318:	18b5      	adds	r5, r6, r2
 800931a:	f8d8 0004 	ldr.w	r0, [r8, #4]
 800931e:	429d      	cmp	r5, r3
 8009320:	9b01      	ldr	r3, [sp, #4]
 8009322:	eb03 0106 	add.w	r1, r3, r6
 8009326:	d808      	bhi.n	800933a <ethernetif_input+0xb2>
      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
 8009328:	4448      	add	r0, r9
 800932a:	f000 fc6a 	bl	8009c02 <memcpy>
    for(q = p; q != NULL; q = q->next)
 800932e:	f8d8 8000 	ldr.w	r8, [r8]
 8009332:	f1b8 0f00 	cmp.w	r8, #0
 8009336:	d1e8      	bne.n	800930a <ethernetif_input+0x82>
 8009338:	e7bd      	b.n	80092b6 <ethernetif_input+0x2e>
        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
 800933a:	f5c6 66be 	rsb	r6, r6, #1520	; 0x5f0
 800933e:	4448      	add	r0, r9
 8009340:	3604      	adds	r6, #4
 8009342:	4632      	mov	r2, r6
        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
 8009344:	44b1      	add	r9, r6
        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
 8009346:	f000 fc5c 	bl	8009c02 <memcpy>
        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
 800934a:	f8db b00c 	ldr.w	fp, [fp, #12]
        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
 800934e:	f2a5 52f4 	subw	r2, r5, #1524	; 0x5f4
        bufferoffset = 0;
 8009352:	2600      	movs	r6, #0
        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
 8009354:	f8db 3008 	ldr.w	r3, [fp, #8]
 8009358:	9301      	str	r3, [sp, #4]
 800935a:	e7db      	b.n	8009314 <ethernetif_input+0x8c>
      dmarxdesc->Status |= ETH_DMARXDESC_OWN;
 800935c:	6819      	ldr	r1, [r3, #0]
    for (i=0; i< heth.RxFrameInfos.SegCount; i++)
 800935e:	3201      	adds	r2, #1
      dmarxdesc->Status |= ETH_DMARXDESC_OWN;
 8009360:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 8009364:	6019      	str	r1, [r3, #0]
      dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
 8009366:	68db      	ldr	r3, [r3, #12]
 8009368:	e7a8      	b.n	80092bc <ethernetif_input+0x34>
 800936a:	bf00      	nop
 800936c:	20003f3c 	.word	0x20003f3c
 8009370:	20008f54 	.word	0x20008f54

08009374 <HAL_ETH_MspInit>:
  if(ethHandle->Instance==ETH)
 8009374:	6802      	ldr	r2, [r0, #0]
 8009376:	4b2d      	ldr	r3, [pc, #180]	; (800942c <HAL_ETH_MspInit+0xb8>)
 8009378:	429a      	cmp	r2, r3
{
 800937a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800937c:	b089      	sub	sp, #36	; 0x24
  if(ethHandle->Instance==ETH)
 800937e:	d152      	bne.n	8009426 <HAL_ETH_MspInit+0xb2>
    __HAL_RCC_ETH_CLK_ENABLE();
 8009380:	f5a3 4390 	sub.w	r3, r3, #18432	; 0x4800
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009384:	2400      	movs	r4, #0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009386:	2702      	movs	r7, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8009388:	2603      	movs	r6, #3
    __HAL_RCC_ETH_CLK_ENABLE();
 800938a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 800938c:	250b      	movs	r5, #11
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800938e:	a903      	add	r1, sp, #12
 8009390:	4827      	ldr	r0, [pc, #156]	; (8009430 <HAL_ETH_MspInit+0xbc>)
    __HAL_RCC_ETH_CLK_ENABLE();
 8009392:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 8009396:	631a      	str	r2, [r3, #48]	; 0x30
 8009398:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800939a:	f002 7200 	and.w	r2, r2, #33554432	; 0x2000000
 800939e:	9200      	str	r2, [sp, #0]
 80093a0:	9a00      	ldr	r2, [sp, #0]
 80093a2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80093a4:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 80093a8:	631a      	str	r2, [r3, #48]	; 0x30
 80093aa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80093ac:	f002 6280 	and.w	r2, r2, #67108864	; 0x4000000
 80093b0:	9201      	str	r2, [sp, #4]
 80093b2:	9a01      	ldr	r2, [sp, #4]
 80093b4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80093b6:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 80093ba:	631a      	str	r2, [r3, #48]	; 0x30
 80093bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80093be:	9704      	str	r7, [sp, #16]
    __HAL_RCC_ETH_CLK_ENABLE();
 80093c0:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80093c4:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80093c6:	9606      	str	r6, [sp, #24]
    __HAL_RCC_ETH_CLK_ENABLE();
 80093c8:	9302      	str	r3, [sp, #8]
 80093ca:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = RMII_MDC_Pin|RMII_RXD0_Pin|RMII_RXD1_Pin;
 80093cc:	2332      	movs	r3, #50	; 0x32
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 80093ce:	9507      	str	r5, [sp, #28]
    GPIO_InitStruct.Pin = RMII_MDC_Pin|RMII_RXD0_Pin|RMII_RXD1_Pin;
 80093d0:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80093d2:	f7f7 fbaf 	bl	8000b34 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = RMII_REF_CLK_Pin|RMII_MDIO_Pin|RMII_CRS_DV_Pin;
 80093d6:	2386      	movs	r3, #134	; 0x86
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80093d8:	a903      	add	r1, sp, #12
 80093da:	4816      	ldr	r0, [pc, #88]	; (8009434 <HAL_ETH_MspInit+0xc0>)
    GPIO_InitStruct.Pin = RMII_REF_CLK_Pin|RMII_MDIO_Pin|RMII_CRS_DV_Pin;
 80093dc:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80093de:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80093e0:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80093e2:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 80093e4:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80093e6:	f7f7 fba5 	bl	8000b34 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = RMII_TXD1_Pin;
 80093ea:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    HAL_GPIO_Init(RMII_TXD1_GPIO_Port, &GPIO_InitStruct);
 80093ee:	a903      	add	r1, sp, #12
 80093f0:	4811      	ldr	r0, [pc, #68]	; (8009438 <HAL_ETH_MspInit+0xc4>)
    GPIO_InitStruct.Pin = RMII_TXD1_Pin;
 80093f2:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80093f4:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80093f6:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80093f8:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 80093fa:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(RMII_TXD1_GPIO_Port, &GPIO_InitStruct);
 80093fc:	f7f7 fb9a 	bl	8000b34 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = RMII_TX_EN_Pin|RMII_TXD0_Pin;
 8009400:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8009404:	a903      	add	r1, sp, #12
 8009406:	480d      	ldr	r0, [pc, #52]	; (800943c <HAL_ETH_MspInit+0xc8>)
    GPIO_InitStruct.Pin = RMII_TX_EN_Pin|RMII_TXD0_Pin;
 8009408:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800940a:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800940c:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800940e:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 8009410:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8009412:	f7f7 fb8f 	bl	8000b34 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(ETH_IRQn, 5, 0);
 8009416:	203d      	movs	r0, #61	; 0x3d
 8009418:	4622      	mov	r2, r4
 800941a:	2105      	movs	r1, #5
 800941c:	f7f6 ff7e 	bl	800031c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ETH_IRQn);
 8009420:	203d      	movs	r0, #61	; 0x3d
 8009422:	f7f6 ffb3 	bl	800038c <HAL_NVIC_EnableIRQ>
}
 8009426:	b009      	add	sp, #36	; 0x24
 8009428:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800942a:	bf00      	nop
 800942c:	40028000 	.word	0x40028000
 8009430:	40020800 	.word	0x40020800
 8009434:	40020000 	.word	0x40020000
 8009438:	40020400 	.word	0x40020400
 800943c:	40021800 	.word	0x40021800

08009440 <HAL_ETH_RxCpltCallback>:
  osSemaphoreRelease(s_xSemaphore);
 8009440:	4b01      	ldr	r3, [pc, #4]	; (8009448 <HAL_ETH_RxCpltCallback+0x8>)
 8009442:	6818      	ldr	r0, [r3, #0]
 8009444:	f7f9 b8b8 	b.w	80025b8 <osSemaphoreRelease>
 8009448:	20003f3c 	.word	0x20003f3c

0800944c <ethernetif_init>:
#if LWIP_NETIF_HOSTNAME
  /* Initialize interface hostname */
  netif->hostname = "lwip";
#endif /* LWIP_NETIF_HOSTNAME */

  netif->name[0] = IFNAME0;
 800944c:	2373      	movs	r3, #115	; 0x73
  MACAddr[1] = 0x80;
 800944e:	2180      	movs	r1, #128	; 0x80
  heth.Instance = ETH;
 8009450:	4a47      	ldr	r2, [pc, #284]	; (8009570 <ethernetif_init+0x124>)
{
 8009452:	b5f0      	push	{r4, r5, r6, r7, lr}
  netif->name[0] = IFNAME0;
 8009454:	f880 302c 	strb.w	r3, [r0, #44]	; 0x2c
  netif->name[1] = IFNAME1;
 8009458:	2374      	movs	r3, #116	; 0x74
{
 800945a:	b08b      	sub	sp, #44	; 0x2c
  heth.Instance = ETH;
 800945c:	4d45      	ldr	r5, [pc, #276]	; (8009574 <ethernetif_init+0x128>)
  netif->name[1] = IFNAME1;
 800945e:	f880 302d 	strb.w	r3, [r0, #45]	; 0x2d
{
 8009462:	4604      	mov	r4, r0
   * is available...) */

#if LWIP_IPV4
#if LWIP_ARP || LWIP_ETHERNET
#if LWIP_ARP
  netif->output = etharp_output;
 8009464:	4b44      	ldr	r3, [pc, #272]	; (8009578 <ethernetif_init+0x12c>)
  MACAddr[1] = 0x80;
 8009466:	f88d 100d 	strb.w	r1, [sp, #13]
  MACAddr[2] = 0xE1;
 800946a:	21e1      	movs	r1, #225	; 0xe1
  netif->output = etharp_output;
 800946c:	6143      	str	r3, [r0, #20]
 
#if LWIP_IPV6
  netif->output_ip6 = ethip6_output;
#endif /* LWIP_IPV6 */

  netif->linkoutput = low_level_output;
 800946e:	4b43      	ldr	r3, [pc, #268]	; (800957c <ethernetif_init+0x130>)
  heth.Instance = ETH;
 8009470:	602a      	str	r2, [r5, #0]
  heth.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
 8009472:	2201      	movs	r2, #1
  netif->linkoutput = low_level_output;
 8009474:	6183      	str	r3, [r0, #24]
  uint32_t regvalue = 0;
 8009476:	2300      	movs	r3, #0
  MACAddr[2] = 0xE1;
 8009478:	f88d 100e 	strb.w	r1, [sp, #14]
  heth.Init.MACAddr = &MACAddr[0];
 800947c:	a903      	add	r1, sp, #12
  uint32_t regvalue = 0;
 800947e:	9301      	str	r3, [sp, #4]
  hal_eth_init_status = HAL_ETH_Init(&heth);
 8009480:	4628      	mov	r0, r5
  heth.Init.PhyAddress = 0;
 8009482:	822b      	strh	r3, [r5, #16]
  MACAddr[0] = 0x00;
 8009484:	f88d 300c 	strb.w	r3, [sp, #12]
  MACAddr[3] = 0x00;
 8009488:	f88d 300f 	strb.w	r3, [sp, #15]
  MACAddr[4] = 0x00;
 800948c:	f88d 3010 	strb.w	r3, [sp, #16]
  MACAddr[5] = 0x00;
 8009490:	f88d 3011 	strb.w	r3, [sp, #17]
  heth.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
 8009494:	61eb      	str	r3, [r5, #28]
  heth.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
 8009496:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
  heth.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
 800949a:	606a      	str	r2, [r5, #4]
  heth.Init.MACAddr = &MACAddr[0];
 800949c:	6169      	str	r1, [r5, #20]
  heth.Init.RxMode = ETH_RXINTERRUPT_MODE;
 800949e:	61aa      	str	r2, [r5, #24]
  heth.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
 80094a0:	622b      	str	r3, [r5, #32]
  hal_eth_init_status = HAL_ETH_Init(&heth);
 80094a2:	f7f7 fa0f 	bl	80008c4 <HAL_ETH_Init>
  if (hal_eth_init_status == HAL_OK)
 80094a6:	b928      	cbnz	r0, 80094b4 <ethernetif_init+0x68>
    netif->flags |= NETIF_FLAG_LINK_UP;
 80094a8:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
 80094ac:	f043 0304 	orr.w	r3, r3, #4
 80094b0:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
  HAL_ETH_DMATxDescListInit(&heth, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
 80094b4:	2304      	movs	r3, #4
 80094b6:	4a32      	ldr	r2, [pc, #200]	; (8009580 <ethernetif_init+0x134>)
 80094b8:	4932      	ldr	r1, [pc, #200]	; (8009584 <ethernetif_init+0x138>)
  osSemaphoreDef(SEM);
 80094ba:	2700      	movs	r7, #0
  HAL_ETH_DMATxDescListInit(&heth, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
 80094bc:	482d      	ldr	r0, [pc, #180]	; (8009574 <ethernetif_init+0x128>)
 80094be:	f7f7 f825 	bl	800050c <HAL_ETH_DMATxDescListInit>
  HAL_ETH_DMARxDescListInit(&heth, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
 80094c2:	2304      	movs	r3, #4
 80094c4:	4a30      	ldr	r2, [pc, #192]	; (8009588 <ethernetif_init+0x13c>)
 80094c6:	4931      	ldr	r1, [pc, #196]	; (800958c <ethernetif_init+0x140>)
 80094c8:	482a      	ldr	r0, [pc, #168]	; (8009574 <ethernetif_init+0x128>)
 80094ca:	f7f7 f85c 	bl	8000586 <HAL_ETH_DMARxDescListInit>
  netif->hwaddr_len = ETHARP_HWADDR_LEN;
 80094ce:	2306      	movs	r3, #6
  osSemaphoreDef(SEM);
 80094d0:	a80a      	add	r0, sp, #40	; 0x28
  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
 80094d2:	2101      	movs	r1, #1
  netif->hwaddr_len = ETHARP_HWADDR_LEN;
 80094d4:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
  netif->hwaddr[0] =  heth.Init.MACAddr[0];
 80094d8:	696b      	ldr	r3, [r5, #20]
  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
 80094da:	ad05      	add	r5, sp, #20
 80094dc:	4e2c      	ldr	r6, [pc, #176]	; (8009590 <ethernetif_init+0x144>)
  netif->hwaddr[0] =  heth.Init.MACAddr[0];
 80094de:	781a      	ldrb	r2, [r3, #0]
 80094e0:	f884 2025 	strb.w	r2, [r4, #37]	; 0x25
  netif->hwaddr[1] =  heth.Init.MACAddr[1];
 80094e4:	785a      	ldrb	r2, [r3, #1]
 80094e6:	f884 2026 	strb.w	r2, [r4, #38]	; 0x26
  netif->hwaddr[2] =  heth.Init.MACAddr[2];
 80094ea:	789a      	ldrb	r2, [r3, #2]
 80094ec:	f884 2027 	strb.w	r2, [r4, #39]	; 0x27
  netif->hwaddr[3] =  heth.Init.MACAddr[3];
 80094f0:	78da      	ldrb	r2, [r3, #3]
  osSemaphoreDef(SEM);
 80094f2:	f840 7d20 	str.w	r7, [r0, #-32]!
  netif->hwaddr[3] =  heth.Init.MACAddr[3];
 80094f6:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28
  netif->hwaddr[4] =  heth.Init.MACAddr[4];
 80094fa:	791a      	ldrb	r2, [r3, #4]
 80094fc:	f884 2029 	strb.w	r2, [r4, #41]	; 0x29
  netif->hwaddr[5] =  heth.Init.MACAddr[5];
 8009500:	795b      	ldrb	r3, [r3, #5]
 8009502:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
  netif->mtu = 1500;
 8009506:	f240 53dc 	movw	r3, #1500	; 0x5dc
 800950a:	8463      	strh	r3, [r4, #34]	; 0x22
    netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
 800950c:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
 8009510:	f043 030a 	orr.w	r3, r3, #10
 8009514:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
 8009518:	f7f9 f812 	bl	8002540 <osSemaphoreCreate>
 800951c:	4b1d      	ldr	r3, [pc, #116]	; (8009594 <ethernetif_init+0x148>)
 800951e:	6018      	str	r0, [r3, #0]
  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
 8009520:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8009522:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8009524:	6833      	ldr	r3, [r6, #0]
  osThreadCreate (osThread(EthIf), netif);
 8009526:	4621      	mov	r1, r4
 8009528:	a805      	add	r0, sp, #20
  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
 800952a:	602b      	str	r3, [r5, #0]
  osThreadCreate (osThread(EthIf), netif);
 800952c:	f7f8 ffe5 	bl	80024fa <osThreadCreate>
  HAL_ETH_Start(&heth);
 8009530:	4810      	ldr	r0, [pc, #64]	; (8009574 <ethernetif_init+0x128>)
 8009532:	f7f7 fac1 	bl	8000ab8 <HAL_ETH_Start>
  HAL_ETH_ReadPHYRegister(&heth, PHY_MICR, &regvalue);
 8009536:	aa01      	add	r2, sp, #4
 8009538:	2111      	movs	r1, #17
 800953a:	480e      	ldr	r0, [pc, #56]	; (8009574 <ethernetif_init+0x128>)
 800953c:	f7f7 f951 	bl	80007e2 <HAL_ETH_ReadPHYRegister>
  regvalue |= (PHY_MICR_INT_EN | PHY_MICR_INT_OE);
 8009540:	9a01      	ldr	r2, [sp, #4]
  HAL_ETH_WritePHYRegister(&heth, PHY_MICR, regvalue );
 8009542:	2111      	movs	r1, #17
 8009544:	480b      	ldr	r0, [pc, #44]	; (8009574 <ethernetif_init+0x128>)
  regvalue |= (PHY_MICR_INT_EN | PHY_MICR_INT_OE);
 8009546:	f042 0203 	orr.w	r2, r2, #3
 800954a:	9201      	str	r2, [sp, #4]
  HAL_ETH_WritePHYRegister(&heth, PHY_MICR, regvalue );
 800954c:	f7f7 f983 	bl	8000856 <HAL_ETH_WritePHYRegister>
  HAL_ETH_ReadPHYRegister(&heth, PHY_MISR, &regvalue);
 8009550:	aa01      	add	r2, sp, #4
 8009552:	2112      	movs	r1, #18
 8009554:	4807      	ldr	r0, [pc, #28]	; (8009574 <ethernetif_init+0x128>)
 8009556:	f7f7 f944 	bl	80007e2 <HAL_ETH_ReadPHYRegister>
  regvalue |= PHY_MISR_LINK_INT_EN;
 800955a:	9a01      	ldr	r2, [sp, #4]
  HAL_ETH_WritePHYRegister(&heth, PHY_MISR, regvalue);   
 800955c:	2112      	movs	r1, #18
 800955e:	4805      	ldr	r0, [pc, #20]	; (8009574 <ethernetif_init+0x128>)
  regvalue |= PHY_MISR_LINK_INT_EN;
 8009560:	f042 0220 	orr.w	r2, r2, #32
 8009564:	9201      	str	r2, [sp, #4]
  HAL_ETH_WritePHYRegister(&heth, PHY_MISR, regvalue);   
 8009566:	f7f7 f976 	bl	8000856 <HAL_ETH_WritePHYRegister>

  /* initialize the hardware */
  low_level_init(netif);

  return ERR_OK;
}
 800956a:	4638      	mov	r0, r7
 800956c:	b00b      	add	sp, #44	; 0x2c
 800956e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009570:	40028000 	.word	0x40028000
 8009574:	20008f54 	.word	0x20008f54
 8009578:	08008d5d 	.word	0x08008d5d
 800957c:	080091e9 	.word	0x080091e9
 8009580:	20008f9c 	.word	0x20008f9c
 8009584:	20007684 	.word	0x20007684
 8009588:	20007704 	.word	0x20007704
 800958c:	20008ed4 	.word	0x20008ed4
 8009590:	08009d6c 	.word	0x08009d6c
 8009594:	20003f3c 	.word	0x20003f3c

08009598 <MX_LWIP_Init>:

/**
  * LwIP initialization function
  */
void MX_LWIP_Init(void)
{
 8009598:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
  /* IP addresses initialization */
  IP_ADDRESS[0] = 192;
 800959c:	4e22      	ldr	r6, [pc, #136]	; (8009628 <MX_LWIP_Init+0x90>)
  IP_ADDRESS[1] = 168;
  IP_ADDRESS[2] = 1;
  IP_ADDRESS[3] = 100;
 800959e:	2364      	movs	r3, #100	; 0x64
  NETMASK_ADDRESS[0] = 255;
  NETMASK_ADDRESS[1] = 255;
  NETMASK_ADDRESS[2] = 255;
  NETMASK_ADDRESS[3] = 0;
  GATEWAY_ADDRESS[0] = 192;
 80095a0:	4c22      	ldr	r4, [pc, #136]	; (800962c <MX_LWIP_Init+0x94>)
  NETMASK_ADDRESS[3] = 0;
 80095a2:	f04f 0800 	mov.w	r8, #0
  IP_ADDRESS[0] = 192;
 80095a6:	21c0      	movs	r1, #192	; 0xc0
  NETMASK_ADDRESS[0] = 255;
 80095a8:	4d21      	ldr	r5, [pc, #132]	; (8009630 <MX_LWIP_Init+0x98>)
  IP_ADDRESS[1] = 168;
 80095aa:	22a8      	movs	r2, #168	; 0xa8
  IP_ADDRESS[2] = 1;
 80095ac:	2701      	movs	r7, #1
  IP_ADDRESS[3] = 100;
 80095ae:	70f3      	strb	r3, [r6, #3]
  NETMASK_ADDRESS[0] = 255;
 80095b0:	23ff      	movs	r3, #255	; 0xff
  GATEWAY_ADDRESS[0] = 192;
 80095b2:	7021      	strb	r1, [r4, #0]
  GATEWAY_ADDRESS[1] = 168;
  GATEWAY_ADDRESS[2] = 1;
  GATEWAY_ADDRESS[3] = 1;
  
  /* Initilialize the LwIP stack with RTOS */
  tcpip_init( NULL, NULL );
 80095b4:	4640      	mov	r0, r8
  IP_ADDRESS[0] = 192;
 80095b6:	7031      	strb	r1, [r6, #0]
  tcpip_init( NULL, NULL );
 80095b8:	4641      	mov	r1, r8
  GATEWAY_ADDRESS[1] = 168;
 80095ba:	7062      	strb	r2, [r4, #1]
  IP_ADDRESS[1] = 168;
 80095bc:	7072      	strb	r2, [r6, #1]
  NETMASK_ADDRESS[0] = 255;
 80095be:	702b      	strb	r3, [r5, #0]
  NETMASK_ADDRESS[1] = 255;
 80095c0:	706b      	strb	r3, [r5, #1]
  NETMASK_ADDRESS[2] = 255;
 80095c2:	70ab      	strb	r3, [r5, #2]
  GATEWAY_ADDRESS[2] = 1;
 80095c4:	70a7      	strb	r7, [r4, #2]
  GATEWAY_ADDRESS[3] = 1;
 80095c6:	70e7      	strb	r7, [r4, #3]
  IP_ADDRESS[2] = 1;
 80095c8:	70b7      	strb	r7, [r6, #2]
  NETMASK_ADDRESS[3] = 0;
 80095ca:	f885 8003 	strb.w	r8, [r5, #3]
  tcpip_init( NULL, NULL );
 80095ce:	f7fb fae9 	bl	8004ba4 <tcpip_init>

  /* IP addresses initialization without DHCP (IPv4) */
  IP4_ADDR(&ipaddr, IP_ADDRESS[0], IP_ADDRESS[1], IP_ADDRESS[2], IP_ADDRESS[3]);
 80095d2:	4918      	ldr	r1, [pc, #96]	; (8009634 <MX_LWIP_Init+0x9c>)
 80095d4:	6833      	ldr	r3, [r6, #0]
  IP4_ADDR(&netmask, NETMASK_ADDRESS[0], NETMASK_ADDRESS[1] , NETMASK_ADDRESS[2], NETMASK_ADDRESS[3]);
 80095d6:	4a18      	ldr	r2, [pc, #96]	; (8009638 <MX_LWIP_Init+0xa0>)
  IP4_ADDR(&ipaddr, IP_ADDRESS[0], IP_ADDRESS[1], IP_ADDRESS[2], IP_ADDRESS[3]);
 80095d8:	600b      	str	r3, [r1, #0]
  IP4_ADDR(&netmask, NETMASK_ADDRESS[0], NETMASK_ADDRESS[1] , NETMASK_ADDRESS[2], NETMASK_ADDRESS[3]);
 80095da:	682b      	ldr	r3, [r5, #0]
  IP4_ADDR(&gw, GATEWAY_ADDRESS[0], GATEWAY_ADDRESS[1], GATEWAY_ADDRESS[2], GATEWAY_ADDRESS[3]);
 80095dc:	6820      	ldr	r0, [r4, #0]
  IP4_ADDR(&netmask, NETMASK_ADDRESS[0], NETMASK_ADDRESS[1] , NETMASK_ADDRESS[2], NETMASK_ADDRESS[3]);
 80095de:	6013      	str	r3, [r2, #0]
  IP4_ADDR(&gw, GATEWAY_ADDRESS[0], GATEWAY_ADDRESS[1], GATEWAY_ADDRESS[2], GATEWAY_ADDRESS[3]);
 80095e0:	4b16      	ldr	r3, [pc, #88]	; (800963c <MX_LWIP_Init+0xa4>)

  /* add the network interface (IPv4/IPv6) with RTOS */
  netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &tcpip_input);
 80095e2:	4c17      	ldr	r4, [pc, #92]	; (8009640 <MX_LWIP_Init+0xa8>)
  IP4_ADDR(&gw, GATEWAY_ADDRESS[0], GATEWAY_ADDRESS[1], GATEWAY_ADDRESS[2], GATEWAY_ADDRESS[3]);
 80095e4:	6018      	str	r0, [r3, #0]
  netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &tcpip_input);
 80095e6:	4817      	ldr	r0, [pc, #92]	; (8009644 <MX_LWIP_Init+0xac>)
 80095e8:	f8cd 8000 	str.w	r8, [sp]
 80095ec:	9002      	str	r0, [sp, #8]
 80095ee:	4816      	ldr	r0, [pc, #88]	; (8009648 <MX_LWIP_Init+0xb0>)
 80095f0:	9001      	str	r0, [sp, #4]
 80095f2:	4620      	mov	r0, r4
 80095f4:	f7fc fa22 	bl	8005a3c <netif_add>

  /* Registers the default network interface */
  netif_set_default(&gnetif);
 80095f8:	4620      	mov	r0, r4
 80095fa:	f7fc fa49 	bl	8005a90 <netif_set_default>

  if (netif_is_link_up(&gnetif))
 80095fe:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
  {
    /* When the netif is fully configured this function must be called */
    netif_set_up(&gnetif);
 8009602:	4620      	mov	r0, r4
  if (netif_is_link_up(&gnetif))
 8009604:	075b      	lsls	r3, r3, #29
 8009606:	d50a      	bpl.n	800961e <MX_LWIP_Init+0x86>
    netif_set_up(&gnetif);
 8009608:	f7fc fa48 	bl	8005a9c <netif_set_up>
    HAL_GPIO_WritePin(GPIOB, LD3_Pin, GPIO_PIN_SET);
 800960c:	463a      	mov	r2, r7
 800960e:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8009612:	480e      	ldr	r0, [pc, #56]	; (800964c <MX_LWIP_Init+0xb4>)
  }

/* USER CODE BEGIN 3 */

/* USER CODE END 3 */
}
 8009614:	b004      	add	sp, #16
 8009616:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_GPIO_WritePin(GPIOB, LD3_Pin, GPIO_PIN_SET);
 800961a:	f7f7 bb75 	b.w	8000d08 <HAL_GPIO_WritePin>
}
 800961e:	b004      	add	sp, #16
 8009620:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    netif_set_down(&gnetif);
 8009624:	f7fc ba49 	b.w	8005aba <netif_set_down>
 8009628:	2000a7a8 	.word	0x2000a7a8
 800962c:	2000a76c 	.word	0x2000a76c
 8009630:	2000a7a4 	.word	0x2000a7a4
 8009634:	2000a7a0 	.word	0x2000a7a0
 8009638:	2000a7ac 	.word	0x2000a7ac
 800963c:	2000a7b0 	.word	0x2000a7b0
 8009640:	2000a770 	.word	0x2000a770
 8009644:	08004ad5 	.word	0x08004ad5
 8009648:	0800944d 	.word	0x0800944d
 800964c:	40020400 	.word	0x40020400

08009650 <StartDefaultTask>:

/* USER CODE END 4 */

/* StartDefaultTask function */
void StartDefaultTask(void const * argument)
{
 8009650:	b508      	push	{r3, lr}
  /* init code for LWIP */
  MX_LWIP_Init();
 8009652:	f7ff ffa1 	bl	8009598 <MX_LWIP_Init>

  tcpecho_init();
 8009656:	f000 fa4d 	bl	8009af4 <tcpecho_init>

  udpecho_init();
 800965a:	f000 fa8d 	bl	8009b78 <udpecho_init>

  /* USER CODE BEGIN 5 */
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
 800965e:	2001      	movs	r0, #1
 8009660:	f7f8 ff66 	bl	8002530 <osDelay>
 8009664:	e7fb      	b.n	800965e <StartDefaultTask+0xe>
	...

08009668 <SystemClock_Config>:
  __HAL_RCC_PWR_CLK_ENABLE();
 8009668:	4b2e      	ldr	r3, [pc, #184]	; (8009724 <SystemClock_Config+0xbc>)
 800966a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800966c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
{
 8009670:	b570      	push	{r4, r5, r6, lr}
  __HAL_RCC_PWR_CLK_ENABLE();
 8009672:	641a      	str	r2, [r3, #64]	; 0x40
{
 8009674:	b0b4      	sub	sp, #208	; 0xd0
  __HAL_RCC_PWR_CLK_ENABLE();
 8009676:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8009678:	2402      	movs	r4, #2
  RCC_OscInitStruct.PLL.PLLM = 4;
 800967a:	2604      	movs	r6, #4
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800967c:	a807      	add	r0, sp, #28
  __HAL_RCC_PWR_CLK_ENABLE();
 800967e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8009682:	9300      	str	r3, [sp, #0]
 8009684:	9b00      	ldr	r3, [sp, #0]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8009686:	4b28      	ldr	r3, [pc, #160]	; (8009728 <SystemClock_Config+0xc0>)
 8009688:	681a      	ldr	r2, [r3, #0]
 800968a:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 800968e:	601a      	str	r2, [r3, #0]
 8009690:	681b      	ldr	r3, [r3, #0]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8009692:	940d      	str	r4, [sp, #52]	; 0x34
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8009694:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
  RCC_OscInitStruct.PLL.PLLM = 4;
 8009698:	960f      	str	r6, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800969a:	9411      	str	r4, [sp, #68]	; 0x44
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800969c:	9301      	str	r3, [sp, #4]
 800969e:	9b01      	ldr	r3, [sp, #4]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80096a0:	2301      	movs	r3, #1
 80096a2:	9307      	str	r3, [sp, #28]
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
 80096a4:	f44f 23a0 	mov.w	r3, #327680	; 0x50000
 80096a8:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80096aa:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 80096ae:	930e      	str	r3, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLN = 216;
 80096b0:	23d8      	movs	r3, #216	; 0xd8
 80096b2:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLQ = 9;
 80096b4:	2309      	movs	r3, #9
 80096b6:	9312      	str	r3, [sp, #72]	; 0x48
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80096b8:	f7f7 fbe2 	bl	8000e80 <HAL_RCC_OscConfig>
 80096bc:	b100      	cbz	r0, 80096c0 <SystemClock_Config+0x58>
 80096be:	e7fe      	b.n	80096be <SystemClock_Config+0x56>
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
 80096c0:	f7f7 fba6 	bl	8000e10 <HAL_PWREx_EnableOverDrive>
 80096c4:	b100      	cbz	r0, 80096c8 <SystemClock_Config+0x60>
 80096c6:	e7fe      	b.n	80096c6 <SystemClock_Config+0x5e>
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 80096c8:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80096cc:	250f      	movs	r5, #15
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80096ce:	9004      	str	r0, [sp, #16]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
 80096d0:	2107      	movs	r1, #7
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 80096d2:	9305      	str	r3, [sp, #20]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80096d4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
 80096d8:	a802      	add	r0, sp, #8
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80096da:	9502      	str	r5, [sp, #8]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80096dc:	9403      	str	r4, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80096de:	9306      	str	r3, [sp, #24]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
 80096e0:	f7f7 fda8 	bl	8001234 <HAL_RCC_ClockConfig>
 80096e4:	b100      	cbz	r0, 80096e8 <SystemClock_Config+0x80>
 80096e6:	e7fe      	b.n	80096e6 <SystemClock_Config+0x7e>
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3|RCC_PERIPHCLK_CLK48;
 80096e8:	4b10      	ldr	r3, [pc, #64]	; (800972c <SystemClock_Config+0xc4>)
  PeriphClkInitStruct.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1;
 80096ea:	9026      	str	r0, [sp, #152]	; 0x98
  PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLL;
 80096ec:	9032      	str	r0, [sp, #200]	; 0xc8
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80096ee:	a813      	add	r0, sp, #76	; 0x4c
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3|RCC_PERIPHCLK_CLK48;
 80096f0:	9313      	str	r3, [sp, #76]	; 0x4c
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80096f2:	f7f7 fe9f 	bl	8001434 <HAL_RCCEx_PeriphCLKConfig>
 80096f6:	4604      	mov	r4, r0
 80096f8:	b100      	cbz	r0, 80096fc <SystemClock_Config+0x94>
 80096fa:	e7fe      	b.n	80096fa <SystemClock_Config+0x92>
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 80096fc:	f7f7 fe46 	bl	800138c <HAL_RCC_GetHCLKFreq>
 8009700:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8009704:	fbb0 f0f3 	udiv	r0, r0, r3
 8009708:	f7f6 fe4c 	bl	80003a4 <HAL_SYSTICK_Config>
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 800970c:	4630      	mov	r0, r6
 800970e:	f7f6 fe5f 	bl	80003d0 <HAL_SYSTICK_CLKSourceConfig>
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 8009712:	4622      	mov	r2, r4
 8009714:	4629      	mov	r1, r5
 8009716:	f04f 30ff 	mov.w	r0, #4294967295
 800971a:	f7f6 fdff 	bl	800031c <HAL_NVIC_SetPriority>
}
 800971e:	b034      	add	sp, #208	; 0xd0
 8009720:	bd70      	pop	{r4, r5, r6, pc}
 8009722:	bf00      	nop
 8009724:	40023800 	.word	0x40023800
 8009728:	40007000 	.word	0x40007000
 800972c:	00200100 	.word	0x00200100

08009730 <main>:
{
 8009730:	b580      	push	{r7, lr}
 8009732:	b08c      	sub	sp, #48	; 0x30
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8009734:	2400      	movs	r4, #0
  HAL_Init();
 8009736:	f7f6 fdb7 	bl	80002a8 <HAL_Init>
  GPIO_InitStruct.Pin = LD3_Pin|LD2_Pin;
 800973a:	f44f 4781 	mov.w	r7, #16512	; 0x4080
  SystemClock_Config();
 800973e:	f7ff ff93 	bl	8009668 <SystemClock_Config>
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8009742:	4b4e      	ldr	r3, [pc, #312]	; (800987c <main+0x14c>)
  HAL_GPIO_Init(User_Blue_Button_GPIO_Port, &GPIO_InitStruct);
 8009744:	a907      	add	r1, sp, #28
 8009746:	484e      	ldr	r0, [pc, #312]	; (8009880 <main+0x150>)
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8009748:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800974a:	2501      	movs	r5, #1
  GPIO_InitStruct.Pin = USB_PowerSwitchOn_Pin;
 800974c:	2640      	movs	r6, #64	; 0x40
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800974e:	f042 0204 	orr.w	r2, r2, #4
 8009752:	631a      	str	r2, [r3, #48]	; 0x30
 8009754:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009756:	f002 0204 	and.w	r2, r2, #4
 800975a:	9201      	str	r2, [sp, #4]
 800975c:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800975e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009760:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8009764:	631a      	str	r2, [r3, #48]	; 0x30
 8009766:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009768:	f002 0280 	and.w	r2, r2, #128	; 0x80
 800976c:	9202      	str	r2, [sp, #8]
 800976e:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8009770:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009772:	f042 0201 	orr.w	r2, r2, #1
 8009776:	631a      	str	r2, [r3, #48]	; 0x30
 8009778:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800977a:	f002 0201 	and.w	r2, r2, #1
 800977e:	9203      	str	r2, [sp, #12]
 8009780:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8009782:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009784:	f042 0202 	orr.w	r2, r2, #2
 8009788:	631a      	str	r2, [r3, #48]	; 0x30
 800978a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800978c:	f002 0202 	and.w	r2, r2, #2
 8009790:	9204      	str	r2, [sp, #16]
 8009792:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8009794:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009796:	f042 0208 	orr.w	r2, r2, #8
 800979a:	631a      	str	r2, [r3, #48]	; 0x30
 800979c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800979e:	f002 0208 	and.w	r2, r2, #8
 80097a2:	9205      	str	r2, [sp, #20]
 80097a4:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 80097a6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80097a8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80097ac:	631a      	str	r2, [r3, #48]	; 0x30
 80097ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80097b0:	9408      	str	r4, [sp, #32]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 80097b2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80097b6:	9306      	str	r3, [sp, #24]
 80097b8:	9b06      	ldr	r3, [sp, #24]
  GPIO_InitStruct.Pin = User_Blue_Button_Pin;
 80097ba:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80097be:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80097c0:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(User_Blue_Button_GPIO_Port, &GPIO_InitStruct);
 80097c2:	f7f7 f9b7 	bl	8000b34 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80097c6:	a907      	add	r1, sp, #28
 80097c8:	482e      	ldr	r0, [pc, #184]	; (8009884 <main+0x154>)
  GPIO_InitStruct.Pin = LD3_Pin|LD2_Pin;
 80097ca:	9707      	str	r7, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80097cc:	9508      	str	r5, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80097ce:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80097d0:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80097d2:	f7f7 f9af 	bl	8000b34 <HAL_GPIO_Init>
  HAL_GPIO_Init(USB_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
 80097d6:	a907      	add	r1, sp, #28
 80097d8:	482b      	ldr	r0, [pc, #172]	; (8009888 <main+0x158>)
  GPIO_InitStruct.Pin = USB_PowerSwitchOn_Pin;
 80097da:	9607      	str	r6, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80097dc:	9508      	str	r5, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80097de:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80097e0:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(USB_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
 80097e2:	f7f7 f9a7 	bl	8000b34 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = USB_OverCurrent_Pin;
 80097e6:	2380      	movs	r3, #128	; 0x80
  HAL_GPIO_Init(USB_OverCurrent_GPIO_Port, &GPIO_InitStruct);
 80097e8:	a907      	add	r1, sp, #28
 80097ea:	4827      	ldr	r0, [pc, #156]	; (8009888 <main+0x158>)
  GPIO_InitStruct.Pin = USB_OverCurrent_Pin;
 80097ec:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80097ee:	9408      	str	r4, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80097f0:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(USB_OverCurrent_GPIO_Port, &GPIO_InitStruct);
 80097f2:	f7f7 f99f 	bl	8000b34 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(GPIOB, LD3_Pin|LD2_Pin, GPIO_PIN_RESET);
 80097f6:	4639      	mov	r1, r7
 80097f8:	4622      	mov	r2, r4
 80097fa:	4822      	ldr	r0, [pc, #136]	; (8009884 <main+0x154>)
  huart3.Init.WordLength = UART_WORDLENGTH_7B;
 80097fc:	f04f 5780 	mov.w	r7, #268435456	; 0x10000000
  HAL_GPIO_WritePin(GPIOB, LD3_Pin|LD2_Pin, GPIO_PIN_RESET);
 8009800:	f7f7 fa82 	bl	8000d08 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(USB_PowerSwitchOn_GPIO_Port, USB_PowerSwitchOn_Pin, GPIO_PIN_RESET);
 8009804:	4631      	mov	r1, r6
 8009806:	4820      	ldr	r0, [pc, #128]	; (8009888 <main+0x158>)
 8009808:	4622      	mov	r2, r4
 800980a:	f7f7 fa7d 	bl	8000d08 <HAL_GPIO_WritePin>
  huart3.Init.WordLength = UART_WORDLENGTH_7B;
 800980e:	f44f 36e1 	mov.w	r6, #115200	; 0x1c200
  huart3.Instance = USART3;
 8009812:	481e      	ldr	r0, [pc, #120]	; (800988c <main+0x15c>)
  huart3.Init.WordLength = UART_WORDLENGTH_7B;
 8009814:	4b1e      	ldr	r3, [pc, #120]	; (8009890 <main+0x160>)
  huart3.Init.StopBits = UART_STOPBITS_1;
 8009816:	60c4      	str	r4, [r0, #12]
  huart3.Init.Parity = UART_PARITY_NONE;
 8009818:	6104      	str	r4, [r0, #16]
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800981a:	6184      	str	r4, [r0, #24]
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
 800981c:	61c4      	str	r4, [r0, #28]
  huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800981e:	6204      	str	r4, [r0, #32]
  huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8009820:	6244      	str	r4, [r0, #36]	; 0x24
  huart3.Init.WordLength = UART_WORDLENGTH_7B;
 8009822:	e880 00c8 	stmia.w	r0, {r3, r6, r7}
  huart3.Init.Mode = UART_MODE_TX_RX;
 8009826:	230c      	movs	r3, #12
 8009828:	6143      	str	r3, [r0, #20]
  if (HAL_UART_Init(&huart3) != HAL_OK)
 800982a:	f7f8 fce2 	bl	80021f2 <HAL_UART_Init>
 800982e:	b100      	cbz	r0, 8009832 <main+0x102>
 8009830:	e7fe      	b.n	8009830 <main+0x100>
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 8009832:	4b18      	ldr	r3, [pc, #96]	; (8009894 <main+0x164>)
  hpcd_USB_OTG_FS.Init.dev_endpoints = 6;
 8009834:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
 8009838:	2206      	movs	r2, #6
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 800983a:	6118      	str	r0, [r3, #16]
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 800983c:	6158      	str	r0, [r3, #20]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 800983e:	6218      	str	r0, [r3, #32]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 8009840:	6258      	str	r0, [r3, #36]	; 0x24
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 8009842:	62d8      	str	r0, [r3, #44]	; 0x2c
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 8009844:	4618      	mov	r0, r3
  hpcd_USB_OTG_FS.Init.Sof_enable = ENABLE;
 8009846:	61dd      	str	r5, [r3, #28]
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
 8009848:	629d      	str	r5, [r3, #40]	; 0x28
  hpcd_USB_OTG_FS.Init.dev_endpoints = 6;
 800984a:	e883 0006 	stmia.w	r3, {r1, r2}
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 800984e:	2202      	movs	r2, #2
 8009850:	60da      	str	r2, [r3, #12]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8009852:	619a      	str	r2, [r3, #24]
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 8009854:	f7f7 fa5d 	bl	8000d12 <HAL_PCD_Init>
 8009858:	4606      	mov	r6, r0
 800985a:	b100      	cbz	r0, 800985e <main+0x12e>
 800985c:	e7fe      	b.n	800985c <main+0x12c>
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
 800985e:	4d0e      	ldr	r5, [pc, #56]	; (8009898 <main+0x168>)
 8009860:	ac07      	add	r4, sp, #28
 8009862:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8009864:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8009866:	682b      	ldr	r3, [r5, #0]
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
 8009868:	4631      	mov	r1, r6
 800986a:	a807      	add	r0, sp, #28
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
 800986c:	6023      	str	r3, [r4, #0]
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
 800986e:	f7f8 fe44 	bl	80024fa <osThreadCreate>
 8009872:	4b0a      	ldr	r3, [pc, #40]	; (800989c <main+0x16c>)
 8009874:	6018      	str	r0, [r3, #0]
  osKernelStart();
 8009876:	f7f8 fe3b 	bl	80024f0 <osKernelStart>
 800987a:	e7fe      	b.n	800987a <main+0x14a>
 800987c:	40023800 	.word	0x40023800
 8009880:	40020800 	.word	0x40020800
 8009884:	40020400 	.word	0x40020400
 8009888:	40021800 	.word	0x40021800
 800988c:	2000a7b8 	.word	0x2000a7b8
 8009890:	40004800 	.word	0x40004800
 8009894:	2000a828 	.word	0x2000a828
 8009898:	08009d80 	.word	0x08009d80
 800989c:	2000a7b4 	.word	0x2000a7b4

080098a0 <HAL_TIM_PeriodElapsedCallback>:
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
/* USER CODE BEGIN Callback 0 */

/* USER CODE END Callback 0 */
  if (htim->Instance == TIM1) {
 80098a0:	6802      	ldr	r2, [r0, #0]
 80098a2:	4b03      	ldr	r3, [pc, #12]	; (80098b0 <HAL_TIM_PeriodElapsedCallback+0x10>)
 80098a4:	429a      	cmp	r2, r3
 80098a6:	d101      	bne.n	80098ac <HAL_TIM_PeriodElapsedCallback+0xc>
    HAL_IncTick();
 80098a8:	f7f6 bd0a 	b.w	80002c0 <HAL_IncTick>
 80098ac:	4770      	bx	lr
 80098ae:	bf00      	nop
 80098b0:	40010000 	.word	0x40010000

080098b4 <HAL_MspInit>:

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80098b4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80098b6:	2003      	movs	r0, #3
 80098b8:	f7f6 fd1e 	bl	80002f8 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 80098bc:	2200      	movs	r2, #0
 80098be:	f06f 000b 	mvn.w	r0, #11
 80098c2:	4611      	mov	r1, r2
 80098c4:	f7f6 fd2a 	bl	800031c <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 80098c8:	2200      	movs	r2, #0
 80098ca:	f06f 000a 	mvn.w	r0, #10
 80098ce:	4611      	mov	r1, r2
 80098d0:	f7f6 fd24 	bl	800031c <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 80098d4:	2200      	movs	r2, #0
 80098d6:	f06f 0009 	mvn.w	r0, #9
 80098da:	4611      	mov	r1, r2
 80098dc:	f7f6 fd1e 	bl	800031c <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 80098e0:	2200      	movs	r2, #0
 80098e2:	f06f 0004 	mvn.w	r0, #4
 80098e6:	4611      	mov	r1, r2
 80098e8:	f7f6 fd18 	bl	800031c <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 80098ec:	2200      	movs	r2, #0
 80098ee:	f06f 0003 	mvn.w	r0, #3
 80098f2:	4611      	mov	r1, r2
 80098f4:	f7f6 fd12 	bl	800031c <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 80098f8:	2200      	movs	r2, #0
 80098fa:	210f      	movs	r1, #15
 80098fc:	f06f 0001 	mvn.w	r0, #1
 8009900:	f7f6 fd0c 	bl	800031c <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 8009904:	2200      	movs	r2, #0
 8009906:	210f      	movs	r1, #15
 8009908:	f04f 30ff 	mov.w	r0, #4294967295

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800990c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 8009910:	f7f6 bd04 	b.w	800031c <HAL_NVIC_SetPriority>

08009914 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8009914:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(huart->Instance==USART3)
 8009916:	6802      	ldr	r2, [r0, #0]
 8009918:	4b0f      	ldr	r3, [pc, #60]	; (8009958 <HAL_UART_MspInit+0x44>)
 800991a:	429a      	cmp	r2, r3
 800991c:	d119      	bne.n	8009952 <HAL_UART_MspInit+0x3e>
  {
  /* USER CODE BEGIN USART3_MspInit 0 */

  /* USER CODE END USART3_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART3_CLK_ENABLE();
 800991e:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
    GPIO_InitStruct.Pin = STLK_RX_Pin|STLK_TX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8009922:	a901      	add	r1, sp, #4
 8009924:	480d      	ldr	r0, [pc, #52]	; (800995c <HAL_UART_MspInit+0x48>)
    __HAL_RCC_USART3_CLK_ENABLE();
 8009926:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8009928:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800992c:	641a      	str	r2, [r3, #64]	; 0x40
 800992e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009930:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8009934:	9300      	str	r3, [sp, #0]
 8009936:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = STLK_RX_Pin|STLK_TX_Pin;
 8009938:	f44f 7340 	mov.w	r3, #768	; 0x300
 800993c:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800993e:	2302      	movs	r3, #2
 8009940:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8009942:	2301      	movs	r3, #1
 8009944:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8009946:	2303      	movs	r3, #3
 8009948:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 800994a:	2307      	movs	r3, #7
 800994c:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800994e:	f7f7 f8f1 	bl	8000b34 <HAL_GPIO_Init>
  /* USER CODE BEGIN USART3_MspInit 1 */

  /* USER CODE END USART3_MspInit 1 */
  }

}
 8009952:	b007      	add	sp, #28
 8009954:	f85d fb04 	ldr.w	pc, [sp], #4
 8009958:	40004800 	.word	0x40004800
 800995c:	40020c00 	.word	0x40020c00

08009960 <HAL_PCD_MspInit>:

void HAL_PCD_MspInit(PCD_HandleTypeDef* hpcd)
{

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hpcd->Instance==USB_OTG_FS)
 8009960:	6803      	ldr	r3, [r0, #0]
 8009962:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
{
 8009966:	b500      	push	{lr}
 8009968:	b089      	sub	sp, #36	; 0x24
  if(hpcd->Instance==USB_OTG_FS)
 800996a:	d121      	bne.n	80099b0 <HAL_PCD_MspInit+0x50>
    PA8     ------> USB_OTG_FS_SOF
    PA10     ------> USB_OTG_FS_ID
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = USB_SOF_Pin|USB_ID_Pin|USB_DM_Pin|USB_DP_Pin;
 800996c:	f44f 53e8 	mov.w	r3, #7424	; 0x1d00
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009970:	a903      	add	r1, sp, #12
 8009972:	4811      	ldr	r0, [pc, #68]	; (80099b8 <HAL_PCD_MspInit+0x58>)
    GPIO_InitStruct.Pin = USB_SOF_Pin|USB_ID_Pin|USB_DM_Pin|USB_DP_Pin;
 8009974:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009976:	2302      	movs	r3, #2
 8009978:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800997a:	2300      	movs	r3, #0
 800997c:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800997e:	2303      	movs	r3, #3
 8009980:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8009982:	230a      	movs	r3, #10
 8009984:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009986:	f7f7 f8d5 	bl	8000b34 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 800998a:	4b0c      	ldr	r3, [pc, #48]	; (80099bc <HAL_PCD_MspInit+0x5c>)
 800998c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800998e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8009992:	635a      	str	r2, [r3, #52]	; 0x34
 8009994:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8009996:	f002 0280 	and.w	r2, r2, #128	; 0x80
 800999a:	9201      	str	r2, [sp, #4]
 800999c:	9a01      	ldr	r2, [sp, #4]
 800999e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80099a0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80099a4:	645a      	str	r2, [r3, #68]	; 0x44
 80099a6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80099a8:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80099ac:	9302      	str	r3, [sp, #8]
 80099ae:	9b02      	ldr	r3, [sp, #8]
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }

}
 80099b0:	b009      	add	sp, #36	; 0x24
 80099b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80099b6:	bf00      	nop
 80099b8:	40020000 	.word	0x40020000
 80099bc:	40023800 	.word	0x40023800

080099c0 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig(). 
  * @param  TickPriority: Tick interrupt priorty.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80099c0:	b510      	push	{r4, lr}
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  
  /*Configure the TIM1 IRQ priority */
  HAL_NVIC_SetPriority(TIM1_UP_TIM10_IRQn, TickPriority ,0); 
 80099c2:	4601      	mov	r1, r0
{
 80099c4:	b088      	sub	sp, #32
  HAL_NVIC_SetPriority(TIM1_UP_TIM10_IRQn, TickPriority ,0); 
 80099c6:	2200      	movs	r2, #0
 80099c8:	2019      	movs	r0, #25
 80099ca:	f7f6 fca7 	bl	800031c <HAL_NVIC_SetPriority>
  
  /* Enable the TIM1 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM1_UP_TIM10_IRQn); 
 80099ce:	2019      	movs	r0, #25
 80099d0:	f7f6 fcdc 	bl	800038c <HAL_NVIC_EnableIRQ>
  
  /* Enable TIM1 clock */
  __HAL_RCC_TIM1_CLK_ENABLE();
 80099d4:	4b14      	ldr	r3, [pc, #80]	; (8009a28 <HAL_InitTick+0x68>)
  
  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 80099d6:	a901      	add	r1, sp, #4
 80099d8:	a803      	add	r0, sp, #12
  __HAL_RCC_TIM1_CLK_ENABLE();
 80099da:	6c5a      	ldr	r2, [r3, #68]	; 0x44
   
  /* Compute the prescaler value to have TIM1 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
  
  /* Initialize TIM1 */
  htim1.Instance = TIM1;
 80099dc:	4c13      	ldr	r4, [pc, #76]	; (8009a2c <HAL_InitTick+0x6c>)
  __HAL_RCC_TIM1_CLK_ENABLE();
 80099de:	f042 0201 	orr.w	r2, r2, #1
 80099e2:	645a      	str	r2, [r3, #68]	; 0x44
 80099e4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80099e6:	f003 0301 	and.w	r3, r3, #1
 80099ea:	9302      	str	r3, [sp, #8]
 80099ec:	9b02      	ldr	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 80099ee:	f7f7 fd03 	bl	80013f8 <HAL_RCC_GetClockConfig>
  uwTimclock = 2*HAL_RCC_GetPCLK2Freq();
 80099f2:	f7f7 fce9 	bl	80013c8 <HAL_RCC_GetPCLK2Freq>
  htim1.Instance = TIM1;
 80099f6:	4b0e      	ldr	r3, [pc, #56]	; (8009a30 <HAL_InitTick+0x70>)
  uwTimclock = 2*HAL_RCC_GetPCLK2Freq();
 80099f8:	0040      	lsls	r0, r0, #1
  htim1.Instance = TIM1;
 80099fa:	6023      	str	r3, [r4, #0]
  + Period = [(TIM1CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim1.Init.Period = (1000000 / 1000) - 1;
 80099fc:	f240 33e7 	movw	r3, #999	; 0x3e7
 8009a00:	60e3      	str	r3, [r4, #12]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 8009a02:	4b0c      	ldr	r3, [pc, #48]	; (8009a34 <HAL_InitTick+0x74>)
 8009a04:	fbb0 f0f3 	udiv	r0, r0, r3
 8009a08:	3801      	subs	r0, #1
  htim1.Init.Prescaler = uwPrescalerValue;
  htim1.Init.ClockDivision = 0;
 8009a0a:	2300      	movs	r3, #0
  htim1.Init.Prescaler = uwPrescalerValue;
 8009a0c:	6060      	str	r0, [r4, #4]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
 8009a0e:	4620      	mov	r0, r4
  htim1.Init.ClockDivision = 0;
 8009a10:	6123      	str	r3, [r4, #16]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8009a12:	60a3      	str	r3, [r4, #8]
  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
 8009a14:	f7f8 f9d4 	bl	8001dc0 <HAL_TIM_Base_Init>
 8009a18:	b920      	cbnz	r0, 8009a24 <HAL_InitTick+0x64>
  {
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim1);
 8009a1a:	4620      	mov	r0, r4
 8009a1c:	f7f8 f8ad 	bl	8001b7a <HAL_TIM_Base_Start_IT>
  }
  
  /* Return function status */
  return HAL_ERROR;
}
 8009a20:	b008      	add	sp, #32
 8009a22:	bd10      	pop	{r4, pc}
  return HAL_ERROR;
 8009a24:	2001      	movs	r0, #1
 8009a26:	e7fb      	b.n	8009a20 <HAL_InitTick+0x60>
 8009a28:	40023800 	.word	0x40023800
 8009a2c:	2000abe8 	.word	0x2000abe8
 8009a30:	40010000 	.word	0x40010000
 8009a34:	000f4240 	.word	0x000f4240

08009a38 <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  osSystickHandler();
 8009a38:	f7f8 bde2 	b.w	8002600 <osSystickHandler>

08009a3c <TIM1_UP_TIM10_IRQHandler>:
void TIM1_UP_TIM10_IRQHandler(void)
{
  /* USER CODE BEGIN TIM1_UP_TIM10_IRQn 0 */

  /* USER CODE END TIM1_UP_TIM10_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 8009a3c:	4801      	ldr	r0, [pc, #4]	; (8009a44 <TIM1_UP_TIM10_IRQHandler+0x8>)
 8009a3e:	f7f8 b8ab 	b.w	8001b98 <HAL_TIM_IRQHandler>
 8009a42:	bf00      	nop
 8009a44:	2000abe8 	.word	0x2000abe8

08009a48 <ETH_IRQHandler>:
void ETH_IRQHandler(void)
{
  /* USER CODE BEGIN ETH_IRQn 0 */

  /* USER CODE END ETH_IRQn 0 */
  HAL_ETH_IRQHandler(&heth);
 8009a48:	4801      	ldr	r0, [pc, #4]	; (8009a50 <ETH_IRQHandler+0x8>)
 8009a4a:	f7f6 be92 	b.w	8000772 <HAL_ETH_IRQHandler>
 8009a4e:	bf00      	nop
 8009a50:	20008f54 	.word	0x20008f54

08009a54 <tcpecho_thread>:
  u16_t len;
      
  LWIP_UNUSED_ARG(arg);

  /* Create a new connection identifier. */
  conn = netconn_new(NETCONN_TCP);
 8009a54:	2200      	movs	r2, #0
 8009a56:	2010      	movs	r0, #16
{
 8009a58:	b570      	push	{r4, r5, r6, lr}
  conn = netconn_new(NETCONN_TCP);
 8009a5a:	4611      	mov	r1, r2
{
 8009a5c:	b086      	sub	sp, #24
  conn = netconn_new(NETCONN_TCP);
 8009a5e:	f7fa f8f9 	bl	8003c54 <netconn_new_with_proto_and_callback>
  
  if (conn!=NULL)
 8009a62:	4606      	mov	r6, r0
 8009a64:	2800      	cmp	r0, #0
 8009a66:	d041      	beq.n	8009aec <tcpecho_thread+0x98>
  {  
    /* Bind connection to well known port number 7. */
    err = netconn_bind(conn, NULL, 7);
 8009a68:	2207      	movs	r2, #7
 8009a6a:	2100      	movs	r1, #0
 8009a6c:	f7fa f93c 	bl	8003ce8 <netconn_bind>
    
    if (err == ERR_OK)
 8009a70:	2800      	cmp	r0, #0
 8009a72:	d138      	bne.n	8009ae6 <tcpecho_thread+0x92>
         accept_err = netconn_accept(conn, &newconn);
    
        /* Process the new connection. */
        if (accept_err == ERR_OK) 
        {
		  HAL_GPIO_WritePin(GPIOB, LD2_Pin, GPIO_PIN_SET);
 8009a74:	4d1e      	ldr	r5, [pc, #120]	; (8009af0 <tcpecho_thread+0x9c>)
      netconn_listen(conn);
 8009a76:	21ff      	movs	r1, #255	; 0xff
 8009a78:	4630      	mov	r0, r6
 8009a7a:	f7fa f95d 	bl	8003d38 <netconn_listen_with_backlog>
         accept_err = netconn_accept(conn, &newconn);
 8009a7e:	a903      	add	r1, sp, #12
 8009a80:	4630      	mov	r0, r6
 8009a82:	f7fa f96b 	bl	8003d5c <netconn_accept>
        if (accept_err == ERR_OK) 
 8009a86:	2800      	cmp	r0, #0
 8009a88:	d1f9      	bne.n	8009a7e <tcpecho_thread+0x2a>
		  HAL_GPIO_WritePin(GPIOB, LD2_Pin, GPIO_PIN_SET);
 8009a8a:	2201      	movs	r2, #1
 8009a8c:	2180      	movs	r1, #128	; 0x80
 8009a8e:	4628      	mov	r0, r5
 8009a90:	f7f7 f93a 	bl	8000d08 <HAL_GPIO_WritePin>
          while (netconn_recv(newconn, &buf) == ERR_OK) 
 8009a94:	a904      	add	r1, sp, #16
 8009a96:	9803      	ldr	r0, [sp, #12]
 8009a98:	f7fa f991 	bl	8003dbe <netconn_recv>
 8009a9c:	b9b8      	cbnz	r0, 8009ace <tcpecho_thread+0x7a>
          {
            do 
            {
              netbuf_data(buf, &data, &len);
              netconn_write(newconn, data, len, NETCONN_COPY);
 8009a9e:	4604      	mov	r4, r0
              netbuf_data(buf, &data, &len);
 8009aa0:	f10d 020a 	add.w	r2, sp, #10
 8009aa4:	a905      	add	r1, sp, #20
 8009aa6:	9804      	ldr	r0, [sp, #16]
 8009aa8:	f7fa ffba 	bl	8004a20 <netbuf_data>
              netconn_write(newconn, data, len, NETCONN_COPY);
 8009aac:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 8009ab0:	2301      	movs	r3, #1
 8009ab2:	9905      	ldr	r1, [sp, #20]
 8009ab4:	9400      	str	r4, [sp, #0]
 8009ab6:	9803      	ldr	r0, [sp, #12]
 8009ab8:	f7fa f9ce 	bl	8003e58 <netconn_write_partly>
          
            } 
            while (netbuf_next(buf) >= 0);
 8009abc:	9804      	ldr	r0, [sp, #16]
 8009abe:	f7fa ffc1 	bl	8004a44 <netbuf_next>
 8009ac2:	2800      	cmp	r0, #0
 8009ac4:	daec      	bge.n	8009aa0 <tcpecho_thread+0x4c>
          
            netbuf_delete(buf);
 8009ac6:	9804      	ldr	r0, [sp, #16]
 8009ac8:	f7fa ff99 	bl	80049fe <netbuf_delete>
 8009acc:	e7e2      	b.n	8009a94 <tcpecho_thread+0x40>
          }
        
          /* Close connection and discard connection identifier. */
          netconn_close(newconn);
 8009ace:	9803      	ldr	r0, [sp, #12]
 8009ad0:	f7fa f9f6 	bl	8003ec0 <netconn_close>
          netconn_delete(newconn);
 8009ad4:	9803      	ldr	r0, [sp, #12]
 8009ad6:	f7fa f8ed 	bl	8003cb4 <netconn_delete>
          HAL_GPIO_WritePin(GPIOB, LD2_Pin, GPIO_PIN_RESET);
 8009ada:	2200      	movs	r2, #0
 8009adc:	2180      	movs	r1, #128	; 0x80
 8009ade:	4628      	mov	r0, r5
 8009ae0:	f7f7 f912 	bl	8000d08 <HAL_GPIO_WritePin>
 8009ae4:	e7cb      	b.n	8009a7e <tcpecho_thread+0x2a>
        }
      }
    }
    else
    {
      netconn_delete(newconn);
 8009ae6:	9803      	ldr	r0, [sp, #12]
 8009ae8:	f7fa f8e4 	bl	8003cb4 <netconn_delete>
    }
  }
}
 8009aec:	b006      	add	sp, #24
 8009aee:	bd70      	pop	{r4, r5, r6, pc}
 8009af0:	40020400 	.word	0x40020400

08009af4 <tcpecho_init>:
/*-----------------------------------------------------------------------------------*/

void tcpecho_init(void)
{
  sys_thread_new("tcpecho_thread", tcpecho_thread, NULL, DEFAULT_THREAD_STACKSIZE, TCPECHO_THREAD_PRIO);
 8009af4:	2304      	movs	r3, #4
{
 8009af6:	b507      	push	{r0, r1, r2, lr}
  sys_thread_new("tcpecho_thread", tcpecho_thread, NULL, DEFAULT_THREAD_STACKSIZE, TCPECHO_THREAD_PRIO);
 8009af8:	2200      	movs	r2, #0
 8009afa:	9300      	str	r3, [sp, #0]
 8009afc:	4904      	ldr	r1, [pc, #16]	; (8009b10 <tcpecho_init+0x1c>)
 8009afe:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009b02:	4804      	ldr	r0, [pc, #16]	; (8009b14 <tcpecho_init+0x20>)
 8009b04:	f7ff fb52 	bl	80091ac <sys_thread_new>
}
 8009b08:	b003      	add	sp, #12
 8009b0a:	f85d fb04 	ldr.w	pc, [sp], #4
 8009b0e:	bf00      	nop
 8009b10:	08009a55 	.word	0x08009a55
 8009b14:	08009e20 	.word	0x08009e20

08009b18 <udpecho_thread>:
{
  err_t err, recv_err;
  
  LWIP_UNUSED_ARG(arg);

  conn = netconn_new(NETCONN_UDP);
 8009b18:	2200      	movs	r2, #0
 8009b1a:	2020      	movs	r0, #32
{
 8009b1c:	b570      	push	{r4, r5, r6, lr}
  conn = netconn_new(NETCONN_UDP);
 8009b1e:	4d14      	ldr	r5, [pc, #80]	; (8009b70 <udpecho_thread+0x58>)
 8009b20:	4611      	mov	r1, r2
 8009b22:	f7fa f897 	bl	8003c54 <netconn_new_with_proto_and_callback>
 8009b26:	462c      	mov	r4, r5
 8009b28:	6028      	str	r0, [r5, #0]
  if (conn!= NULL)
 8009b2a:	b300      	cbz	r0, 8009b6e <udpecho_thread+0x56>
  {
    err = netconn_bind(conn, IP_ADDR_ANY, 7);
 8009b2c:	2207      	movs	r2, #7
 8009b2e:	4911      	ldr	r1, [pc, #68]	; (8009b74 <udpecho_thread+0x5c>)
 8009b30:	f7fa f8da 	bl	8003ce8 <netconn_bind>
    if (err == ERR_OK)
 8009b34:	b9b0      	cbnz	r0, 8009b64 <udpecho_thread+0x4c>
    {
      while (1) 
      {
        recv_err = netconn_recv(conn, &buf);
 8009b36:	1d2e      	adds	r6, r5, #4
 8009b38:	4631      	mov	r1, r6
 8009b3a:	6820      	ldr	r0, [r4, #0]
 8009b3c:	f7fa f93f 	bl	8003dbe <netconn_recv>
      
        if (recv_err == ERR_OK) 
 8009b40:	4605      	mov	r5, r0
 8009b42:	2800      	cmp	r0, #0
 8009b44:	d1f8      	bne.n	8009b38 <udpecho_thread+0x20>
        {
          addr = netbuf_fromaddr(buf);
 8009b46:	6861      	ldr	r1, [r4, #4]
          port = netbuf_fromport(buf);
          netconn_connect(conn, addr, port);
 8009b48:	6820      	ldr	r0, [r4, #0]
 8009b4a:	898a      	ldrh	r2, [r1, #12]
 8009b4c:	3108      	adds	r1, #8
 8009b4e:	f7fa f8df 	bl	8003d10 <netconn_connect>
          buf->addr.addr = 0;
 8009b52:	6861      	ldr	r1, [r4, #4]
          netconn_send(conn,buf);
 8009b54:	6820      	ldr	r0, [r4, #0]
          buf->addr.addr = 0;
 8009b56:	608d      	str	r5, [r1, #8]
          netconn_send(conn,buf);
 8009b58:	f7fa f96c 	bl	8003e34 <netconn_send>
          netbuf_delete(buf);
 8009b5c:	6860      	ldr	r0, [r4, #4]
 8009b5e:	f7fa ff4e 	bl	80049fe <netbuf_delete>
 8009b62:	e7e9      	b.n	8009b38 <udpecho_thread+0x20>
        }
      }
    }
    else
    {
      netconn_delete(conn);
 8009b64:	6828      	ldr	r0, [r5, #0]
    }
  }
}
 8009b66:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      netconn_delete(conn);
 8009b6a:	f7fa b8a3 	b.w	8003cb4 <netconn_delete>
 8009b6e:	bd70      	pop	{r4, r5, r6, pc}
 8009b70:	20003f40 	.word	0x20003f40
 8009b74:	08009c70 	.word	0x08009c70

08009b78 <udpecho_init>:
/*-----------------------------------------------------------------------------------*/
void udpecho_init(void)
{
  sys_thread_new("udpecho_thread", udpecho_thread, NULL, DEFAULT_THREAD_STACKSIZE,UDPECHO_THREAD_PRIO );
 8009b78:	2304      	movs	r3, #4
{
 8009b7a:	b507      	push	{r0, r1, r2, lr}
  sys_thread_new("udpecho_thread", udpecho_thread, NULL, DEFAULT_THREAD_STACKSIZE,UDPECHO_THREAD_PRIO );
 8009b7c:	2200      	movs	r2, #0
 8009b7e:	9300      	str	r3, [sp, #0]
 8009b80:	4904      	ldr	r1, [pc, #16]	; (8009b94 <udpecho_init+0x1c>)
 8009b82:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009b86:	4804      	ldr	r0, [pc, #16]	; (8009b98 <udpecho_init+0x20>)
 8009b88:	f7ff fb10 	bl	80091ac <sys_thread_new>
}
 8009b8c:	b003      	add	sp, #12
 8009b8e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009b92:	bf00      	nop
 8009b94:	08009b19 	.word	0x08009b19
 8009b98:	08009e2f 	.word	0x08009e2f

08009b9c <__libc_init_array>:
 8009b9c:	b570      	push	{r4, r5, r6, lr}
 8009b9e:	4e0d      	ldr	r6, [pc, #52]	; (8009bd4 <__libc_init_array+0x38>)
 8009ba0:	4c0d      	ldr	r4, [pc, #52]	; (8009bd8 <__libc_init_array+0x3c>)
 8009ba2:	1ba4      	subs	r4, r4, r6
 8009ba4:	10a4      	asrs	r4, r4, #2
 8009ba6:	2500      	movs	r5, #0
 8009ba8:	42a5      	cmp	r5, r4
 8009baa:	d109      	bne.n	8009bc0 <__libc_init_array+0x24>
 8009bac:	4e0b      	ldr	r6, [pc, #44]	; (8009bdc <__libc_init_array+0x40>)
 8009bae:	4c0c      	ldr	r4, [pc, #48]	; (8009be0 <__libc_init_array+0x44>)
 8009bb0:	f000 f83a 	bl	8009c28 <_init>
 8009bb4:	1ba4      	subs	r4, r4, r6
 8009bb6:	10a4      	asrs	r4, r4, #2
 8009bb8:	2500      	movs	r5, #0
 8009bba:	42a5      	cmp	r5, r4
 8009bbc:	d105      	bne.n	8009bca <__libc_init_array+0x2e>
 8009bbe:	bd70      	pop	{r4, r5, r6, pc}
 8009bc0:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8009bc4:	4798      	blx	r3
 8009bc6:	3501      	adds	r5, #1
 8009bc8:	e7ee      	b.n	8009ba8 <__libc_init_array+0xc>
 8009bca:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8009bce:	4798      	blx	r3
 8009bd0:	3501      	adds	r5, #1
 8009bd2:	e7f2      	b.n	8009bba <__libc_init_array+0x1e>
 8009bd4:	08009e40 	.word	0x08009e40
 8009bd8:	08009e40 	.word	0x08009e40
 8009bdc:	08009e40 	.word	0x08009e40
 8009be0:	08009e44 	.word	0x08009e44

08009be4 <memcmp>:
 8009be4:	b510      	push	{r4, lr}
 8009be6:	3901      	subs	r1, #1
 8009be8:	4402      	add	r2, r0
 8009bea:	4290      	cmp	r0, r2
 8009bec:	d101      	bne.n	8009bf2 <memcmp+0xe>
 8009bee:	2000      	movs	r0, #0
 8009bf0:	bd10      	pop	{r4, pc}
 8009bf2:	f810 3b01 	ldrb.w	r3, [r0], #1
 8009bf6:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8009bfa:	42a3      	cmp	r3, r4
 8009bfc:	d0f5      	beq.n	8009bea <memcmp+0x6>
 8009bfe:	1b18      	subs	r0, r3, r4
 8009c00:	bd10      	pop	{r4, pc}

08009c02 <memcpy>:
 8009c02:	b510      	push	{r4, lr}
 8009c04:	1e43      	subs	r3, r0, #1
 8009c06:	440a      	add	r2, r1
 8009c08:	4291      	cmp	r1, r2
 8009c0a:	d100      	bne.n	8009c0e <memcpy+0xc>
 8009c0c:	bd10      	pop	{r4, pc}
 8009c0e:	f811 4b01 	ldrb.w	r4, [r1], #1
 8009c12:	f803 4f01 	strb.w	r4, [r3, #1]!
 8009c16:	e7f7      	b.n	8009c08 <memcpy+0x6>

08009c18 <memset>:
 8009c18:	4402      	add	r2, r0
 8009c1a:	4603      	mov	r3, r0
 8009c1c:	4293      	cmp	r3, r2
 8009c1e:	d100      	bne.n	8009c22 <memset+0xa>
 8009c20:	4770      	bx	lr
 8009c22:	f803 1b01 	strb.w	r1, [r3], #1
 8009c26:	e7f9      	b.n	8009c1c <memset+0x4>

08009c28 <_init>:
 8009c28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009c2a:	bf00      	nop
 8009c2c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8009c2e:	bc08      	pop	{r3}
 8009c30:	469e      	mov	lr, r3
 8009c32:	4770      	bx	lr

08009c34 <_fini>:
 8009c34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009c36:	bf00      	nop
 8009c38:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8009c3a:	bc08      	pop	{r3}
 8009c3c:	469e      	mov	lr, r3
 8009c3e:	4770      	bx	lr
